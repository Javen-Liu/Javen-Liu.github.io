<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>KMP算法，及其思想的应用</title>
    <link href="/2021/09/04/KMP%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8F%8A%E5%85%B6%E6%80%9D%E6%83%B3%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2021/09/04/KMP%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8F%8A%E5%85%B6%E6%80%9D%E6%83%B3%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在刷leetcode，在写关于字符串方面的题目。</p><p>在一个字符串匹配的题目中，我使用了暴力匹配的算法，可想而知，复杂度起步就是 O(mn) （m和n分别是要被匹配的字符串和匹配样式字符串的长度）。</p><p>在看大佬们的题解时，发现有人使用了一个叫 KMP 算法的东西。</p><p>好家伙，我还真不知道这是个啥。当时看解析，KMP属实太抽象了，搞不明白啥意思。</p><p>看了半天，把思想搞明白了，看了一眼代码，我还是好家伙，这又是啥玩意。</p><p>然后就果断躺平，想着哪天再把 KMP 复习一下。</p><p>弄着弄着就忘记再去复习复习了。直到今天做另外一道题，<a href="https://leetcode-cn.com/problems/shortest-palindrome/">214. 最短回文串</a>，看到题解里，有人用了 KMP 思想，巧妙地解决了这道题让我想起来，KMP 还得好好在学习一下。</p><h1 id="KMP是什么"><a href="#KMP是什么" class="headerlink" title="KMP是什么"></a>KMP是什么</h1><p><strong>K</strong>nuth-<strong>M</strong>orris-<strong>P</strong>ratt 字符串查找算法，简称为 <strong>KMP算法</strong>，常用于在一个文本串 S 内查找一个模式串 P 的出现位置。</p><h2 id="KMP算法是用来做什么的？"><a href="#KMP算法是用来做什么的？" class="headerlink" title="KMP算法是用来做什么的？"></a>KMP算法是用来做什么的？</h2><p>要了解KMP算法，首先需要了解，这个算法是用来做什么的，应用场景是什么。</p><p>那我们从最简单的字符串匹配开始。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/KMP1.gif" alt="暴力遍历"></p><p>从上面的GIF图中可以看到，在每一次匹配时，逐个匹配字符。</p><p>当出现字符不匹配时，将 <strong>s</strong> 与 <strong>t</strong> 的指针都清零了，并且 <strong>t</strong> 只往后前进一个字符。</p><p>假如 <strong>s</strong> 的长度为m，<strong>t</strong> 的长度为n，那么这种暴力匹配的时间复杂度为 **O((m-n)*n)**。</p><p>目前 <strong>s</strong> 和 <strong>t</strong> 的长度还比较短，如果长度再增长，消耗的时间马上就上去了。</p><p><strong>那么，有没有算法能够帮助我们减少这种字符串匹配的时间嗯？</strong></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们来分析一下，有没有什么方法，能够减少比较的次数。</p><p>在索引为1的地方，我们来分析一下。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/IMG_0235.png" alt="索引为1的情况"></p><p>此时我们前面4个字符都已经匹配了，但是在最后一个字符进行比较时，匹配失败。</p><p>按照暴力法，下一步就是将 <strong>t</strong> 字符串向后移动，并且指针清零。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/IMG_0233.png" alt="下一步"></p><p>但是这一步几乎就是浪费时间，因为 <strong>t</strong> 字符串本身是 ABABC，如果前4个字符匹配了，那么向后移动一位完全不可能匹配上。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/IMG_0236.png" alt="比较"></p><p>我们实际上可以直接跳到第二个 A 处。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/IMG_8F5D32CAEA01-1.jpeg" alt="直接跳到第二个A处"></p><p>有没有什么方法，可以让我们从 <strong>t</strong> 匹配串中提取出信息呢？让我们在匹配失败的时候，可以不用从头开始回溯。</p><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>KMP算法的核心就在于，对于 <strong>t</strong> 匹配串进行了处理，从其中获取了信息，并将其保存，一般称这个数组叫做 next 数组。</p><h2 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h2><p><strong>next数组的值是代表着字符串的前缀与后缀相同的最大长度,(不能包括自身)。</strong></p><p>“前缀”指除了最后一个字符以外，一个字符串的全部头部组合；</p><p>“后缀”指除了第一个字符以外，一个字符串的全部尾部组合。</p><p>举个例子：</p><p>模式串t：    A    B    A    B    A    A</p><p>下标:            0    1    2     3    4    5</p><p>next:            0     0    1    2    3    1</p><ol><li>next[0] 代表 t[0] ~ t[0]，即 “A”，”A”的前缀和后缀都是空集，共有元素的长度为0。</li><li>next[1] 代表 t[0] ~ t[1]，即 “AB”，前缀为”<font color=Red>A</font>“，后缀为”<font color=Red>B</font>“，共有元素的长度为0。</li><li>next[2] 代表 t[0] ~ t[2]，即 “ABA”，前缀为”<font color=Red>A</font>B”，后缀为”B<font color=Red>A</font>“，共有元素的长度为1。</li><li>next[3] 代表 t[0] ~ t[3]，即 “ABAB”，前缀为”<font color=Red>AB</font>A”，后缀为”B<font color=Red>AB</font>“，共有元素的长度为2。</li><li>next[4] 代表 t[0] ~ t[4]，即 “ABABA”，前缀为”<font color=Red>ABA</font>B”，后缀为”B<font color=Red>BABA</font>“，共有元素的长度为3。</li><li>next[5] 代表 t[0] ~ t[5]，即 “ABABAA”，前缀为”<font color=Red>A</font>BABAA”，后缀为”BABA<font color=Red>A</font>“，共有元素的长度为1。</li></ol><p>由此，我们计算出了next</p><h2 id="用next数组来解决上面的例子"><a href="#用next数组来解决上面的例子" class="headerlink" title="用next数组来解决上面的例子"></a>用next数组来解决上面的例子</h2><p>我们已经计算出了上面例子中的next数组。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/KMP2.gif" alt="使用next数组"></p><p>从GIF图可以看到，我们通过next数组，使用 j = next[j-1]，来快速计算恢复的下表，直接将下表从4恢复为2，不用从0开始恢复，从而达到跳跃式匹配。</p><h2 id="个人的理解"><a href="#个人的理解" class="headerlink" title="个人的理解"></a>个人的理解</h2><p>上面的解释相对来说，比较枯燥且难以理解，下面是我自己思考和理解这个算法的过程，也希望我思考的方式可以给读者一定的启发。</p><p>在最开始学习这一块的时候，我特别不能理解，next数组到底是个什么玩意，为什么用上面那种方法计算了next数组，在出现匹配失败时，为什么按照next数组来计算，就能快速回退呢？</p><hr><p>虽然上面对于计算next数组的方法，已经写的比较详细了。</p><p>但是一开始学习时，我仍然不明白这么做是为了干什么。尤其是计算前缀与后缀相同的长度，让我一直有点懵。</p><p>但是我们仔细对照着next数组与原字符串对比。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/IMG_0240.PNG" alt="next数组与原字符串对照"></p><p>对于索引为0和1的字符，即 A 和 B，其next数组的值为0。</p><p>而对于索引为2的字符，即第二个A，我们可以看到，其next数组的值为1。当索引为3的字符，即第二个B匹配失败时，说明前面 “ABA” 前缀字符串匹配是对的，但是加上当前的 “B”，字符串 “ABAB” 匹配失败。</p><p>但是next数组保存了之前 t 字符串的信息，所以我们把前缀变成 “A” ，然后继续匹配，看能不能匹配的上。</p><hr><p>好，那我们在看索引为3的字符，即第二个B。</p><p>其next数组对应的值为2。当我们匹配索引为4的字符，即“C”时，如果匹配失败，表明前缀 “ABAB” 匹配是没问题的，但是加上了 “C”，“ABABC” 匹配不上。</p><p>前面说了，索引为3的 “B” 对应next数组的值为2，那么我们的前缀可以变成 “AB” ，也就是从1开始，到2的字字符串，这样我们再去看能不能匹配的上。</p><h1 id="KMP思想应用"><a href="#KMP思想应用" class="headerlink" title="KMP思想应用"></a>KMP思想应用</h1><p>其实这道leetcode的题并不完全是KMP的题，其只不过借助了KMP算法中next数组的思想。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/shortest-palindrome/">214. 最短回文串</a> 这道题是hard，题目是这样的</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/image-20210913210841207.png" alt="214. 最短回文串"></p><p>题目的主要意思是，从字符串的开头开始找，找到最长的回文串，然后在字符串的开头加上回文串后面的字母，让整个字符串变成回文串。</p><p>比如示例1: “aacecaaa”，其中字符串的前七位组成的 “aacecaa” 是回文串，然后就在字符串的开头加上后面剩下的 “a”， 就组成了 “aaacecaaa”</p><p>比如示例2: “abcd”，从开头找，只有 “a” 算是回文串，所以将 “bcd” 反转后，加在最前面，变成了 “dcbabcd”，成为了回文串。</p><p>所以本题目最大的难点就是从字符串的开头开始，最长的回文串。</p><p>说到回文串，最先想到的就是中心拓展法，也就是本题的暴力解法。</p><p>由于时间复杂度比较高，并且做法和正常的回文串方法一样，所以就不在本文赘述。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>既然是找到最长的，从字符串开头开始找的回文串，那么根据回文串的性质，我们知道该字符串反转之后，从字符串开头开始的回文串，就会变成从字符串末尾开始的回文串。</p><p>比如 “abacd”，反转后变为 “dcaba”，前缀回文是”aba”，所以反转后的后缀回文也是”aba”。</p><p>前缀。。。后缀。。。这不就是KMP计算next的方法吗？</p><p>是的，这道题最巧妙的方法就是用KMP计算next数组的方法。</p><p>我们将字符串和其自身反转后的字符串合并在一起，然后计算next数组。</p><p>比如 “abacd”，我们将其和反转后的 “dcaba” 合并，变为 “abacddcaba”。</p><p>然后通过计算next数组后，直接看next数组最后一个元素，其就代表了前缀回文串的长度。</p><h2 id="但是"><a href="#但是" class="headerlink" title="但是"></a>但是</h2><p>但是，我们用这种合并方式，会出现一种问题。</p><p>比如 “aaa”，如果我们直接合并，最后的到的字符串就是 “aaaaaa”，这显然又问题啊。</p><p>那么我们可以通过在中间添加一个无关的字符，来作为间隔。</p><p>这里我用了 # 作为间隔。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><script src="https://gist.github.com/Javen-Liu/07b612ce014b39b48195f7db86f254cf.js"></script><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>说起来，KMP算法是《算法第四版》里，关于字符串匹配的算法。</p><p>当时看到最后一章看不下去了，错过了这个算法，现在算是补上了。</p><p>唉，偷的懒迟早要补回来。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KMP</tag>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库的事务与隔离级别</title>
    <link href="/2021/08/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <url>/2021/08/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说到事务与事务的隔离级别，读者们应该都不陌生。</p><p>最开始学习Java，然后学习Spring框架，写出web页面的过程中，读者们应该都多多少少看过比如IT黑马、尚硅谷之类培训班的视频作为入门。</p><p>其中我就记得，在讲JDBC连接数据库这一课时，有关于事务的讲解。</p><p>什么是事务？当年视频里讲的一个例子，可以说是非常简洁明了：A给B转钱，两个人的钱数额都存在数据库中。</p><p>那么过程就是：</p><ol><li>获取A和B的钱数额</li><li>A扣除转账金额</li><li>B增加转账金额</li></ol><p>那如果A扣钱之后，在服务器程序处理的过程中，出现了异常，第三步没有执行。</p><p>结果就是A扣了钱，但是B没收到钱。这就是非常大的问题了。</p><p>而事务的存在，就可以保证这三个步骤，要么同时生效，要么都不生效。如果A扣了钱，程序出现了问题，那么事务会帮我们回滚到步骤1之前，也就是说转账就没有发生，避免A扣了钱，但是B没收到的情况发生。</p><hr><p>提到隔离级别，大家应该都在面试经验或者各种其他资料里见过。虽然这是一个面试的重点，但是在有写这篇博客的灵感与思路之前，说实话，对于隔离级别，我也只是见过，印象里学过，但是对其没有自己的理解，该忘还是忘。</p><p>我这个人本来就懒，很多东西我都不愿意背，能理解的最好，理解不了的我是真的记不住。</p><p>其中我只对“脏读”、“不可重复读”之类的词汇有些许的了解，也只肤浅的理解了一些，不过都没怎么记住，实际的项目里，也没有遇到相关的。</p><h1 id="线上项目的一次BUG"><a href="#线上项目的一次BUG" class="headerlink" title="线上项目的一次BUG"></a>线上项目的一次BUG</h1><p>某天，实验室同一级的一位老哥找到我，问了我一个问题：“为什么我用分布式的锁，在锁不住，同一个流程执行了两次，导致数据出现了问题”。</p><p>我一脸懵逼，锁怎么会失效，锁一般来说，作为基础组件库里的东西，都是经过时间检验的，一般不会出现特别的问题啊。</p><p>然后我跟着他去看了下代码。</p><p>具体代码就不列出来了，我只用稍微简单一点的代码，来展示其逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transactionLogic</span><span class="hljs-params">()</span> </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(service.getProperty() == <span class="hljs-keyword">null</span>) &#123;<br>                service.doSomeThing();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这一段代码是用来作为微信支付的回调，当支付成功后，微信后台会调用暴露的API，API所在的controller会调用该方法，进行处理，写入库中。</p><p>微信官方的文档里提到过，在微信支付成功后，对于暴露的API接口，可能会调用多次。因此我们的后台必须对多次的调用进行合适的处理，避免多写入库中，造成数据的错误。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/image-20210810204400837.png" alt="微信支付回调流程"></p><p>可以看到上面代码里的逻辑非常简单，就是用一个锁（lock），先锁住，这样如果微信后台同时发送了多个请求，因为🔒会将后来的请求阻塞住。</p><p>然后🔒释放后，另外的请求获取🔒，此时查询刚刚更新的数据，如果更新的数据仍然为null，说明写入库失败，再次执行。</p><p>如果数据不为null，说明第一个获取到🔒的线程完成了任务，将数据写入了库中。</p><p>整个流程似乎没有任何问题啊。但是日志中错误就是定位到了这里。</p><p>在日志中，可以看到最先抢到🔒的线程确实也完成了任务，那么数据库中的数据应该是更新了的，等第二个线程获取到🔒的时候，mapper.get()得到的应该不是null，所以该线程不进行下面的操作，从而避免了重复写入。</p><p>那么到底是什么魔法造成了这个问题呢？老哥的说法是🔒失效了，但我并不这么认为，锁的使用都是规范的，其必定是按照分析的流程来进行阻塞的。</p><h1 id="无意中的收获"><a href="#无意中的收获" class="headerlink" title="无意中的收获"></a>无意中的收获</h1><p>在无法复现，并且苦苦想不出来具体原因时，我抱着试试的心态在DuckDuckGo中搜索（夹带个私货，DuckDuckGo是一个搜索引擎，而且是不跟踪的，不会给网站留下跟踪数据，同时其搜索的质量还是不错的，不会像 *度 一样，排名靠前的都是 **DN，唯一的门槛可能就是需要科学上网）</p><p>在广撒网式的搜索中，一条搜索结果中的<strong>6</strong>个字突然吸引了我的注意力：<strong>事务隔离级别</strong></p><p>我突然想到以前学过的数据库事务隔离级别中，提到过几种造成数据不一致的问题。</p><p>我抱着试试的心态点了进去，通读全文后，终于明白了这次BUG的问题了，且容我娓娓道来</p><h1 id="数据库的事务隔离级别"><a href="#数据库的事务隔离级别" class="headerlink" title="数据库的事务隔离级别"></a>数据库的事务隔离级别</h1><p>以下内容中部分来源于网络上的博客，博客里讲的都非常好[^1] 。</p><h2 id="三种数据库并发读写造成的问题"><a href="#三种数据库并发读写造成的问题" class="headerlink" title="三种数据库并发读写造成的问题"></a>三种数据库并发读写造成的问题</h2><h3 id="1-脏读"><a href="#1-脏读" class="headerlink" title="1.脏读"></a>1.脏读</h3><p>当事务B修改数据，但还未提交，而此时事务A读取数据，读到了B修改，但是还未提交的数据。如果B回滚，那么B的修改也就没了，事务A读到的数据就是无效的。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/867078-20200606205647093-2074318292.png" alt="脏读"></p><h2 id="2-不可重复读"><a href="#2-不可重复读" class="headerlink" title="2.不可重复读"></a>2.不可重复读</h2><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/867078-20200606205714295-1082205544.png" alt="不可重复读"></p><p>在此问题中，事务A在事务B提交前，读取了id为1的数据，其读到的仍然还是未修改前的数据，在事务B提交后，事务A再次读取id为1的数据，其前后两次读到的数据是不同的，这种情况叫做不可重复读。</p><h2 id="3-幻读"><a href="#3-幻读" class="headerlink" title="3.幻读"></a>3.幻读</h2><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/867078-20200606205727193-197776108.png" alt="幻读"></p><p>id主键唯一，事务A搜索id=10的数据，事务A搜索不到id=10的数据，然后事务B新增id=10的数据并提交，事务A更新id=10的数据却成功，插入id=10却失败，现在搜索id=10也有记录</p><h1 id="回到这个BUG上"><a href="#回到这个BUG上" class="headerlink" title="回到这个BUG上"></a>回到这个BUG上</h1><p>目前成熟的数据库都对上面的问题进行了解决，同时设定了多个事务隔离级别。</p><ul><li><p>**READ-UNCOMMITTED(读取未提交)**： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p></li><li><p>**READ-COMMITTED(读取已提交)**： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p></li><li><p>**REPEATABLE-READ(可重复读)**： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p></li><li><p>**SERIALIZABLE(可串行化)**： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p></li></ul><p>Mysql的默认等级为 <strong>REPEATABLE-READ</strong>，并且Mysql在该等级还解决了幻读。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transactionLogic</span><span class="hljs-params">()</span> </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(service.getProperty() == <span class="hljs-keyword">null</span>) &#123;<br>                service.doSomeThing();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>对于以上代码，使用了 @Transactional 注解来开启事务。该注解的原理其实很好理解，其原理是使用了AOP，在执行该方法前，调用了代码开启了事务，在方法执行结束后，再提交事务，一旦出现异常，就会将修改回滚。</p><p>在阅读了关于数据库隔离级别的文章之后，我对其进行了一定的推断，那就是可能在第一个请求来时，启动了事务，并对数据库里的数据进行了修改。</p><p><strong>但是，但是，</strong>在事务还未提交时，就已经将🔒释放了，此时第二个请求来了，也开启了事务。</p><h1 id="问题的分析与解决"><a href="#问题的分析与解决" class="headerlink" title="问题的分析与解决"></a>问题的分析与解决</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>两个事务的流程就如下所示：</p><table><thead><tr><th>操作顺序</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>开启事务</td><td>开启事务</td></tr><tr><td>2</td><td>获取🔒（成功）</td><td>获取🔒（阻塞）</td></tr><tr><td>3</td><td>判断 service.getProperty()  =&gt;  为空</td><td></td></tr><tr><td>4</td><td>service.doSomeThing()</td><td></td></tr><tr><td>5</td><td>释放🔒</td><td></td></tr><tr><td>6</td><td></td><td>获取到🔒（阻塞结束）</td></tr><tr><td>7</td><td>提交事务</td><td>判断  service.getProperty()  =&gt;  仍然为空</td></tr><tr><td>8</td><td></td><td>service.doSomeThing()</td></tr><tr><td>9</td><td></td><td>释放🔒</td></tr><tr><td>10</td><td></td><td>提交事务</td></tr></tbody></table><blockquote><p>ps：service代表的是另外一个service层类实例，由于项目里配置了全局事务，所以service下的所有方法也都有事务，这里为了简化模型，所以就不计service里的事务。</p></blockquote><p>可以看到，在进入上面 transactionLogic() 方法时，都已经开启了事务，由于Mysql默认是 <strong>可重复读</strong> 级别。也就是说，在事务A开启时，读到数据的 value，无论其他事务做了什么修改并提交，在事务A的流程中，读取到的 value 值都不会变。</p><p>那么问题就迎刃而解了，由于两个相同的请求到来是，都走了 transactionLogic() 方法。</p><p>但是由于进入该方法时，就已经开启了事务，所以无论第一个请求（也就是事务A）对数据库做了怎样的修改并提交，第二个请求（事务B）都无法读取到更新过的数据。</p><p>所以在 service.getProperty() 时，得到的值一直都是 null，里面的逻辑也都又走了一遍。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>那么就是让请求进入方法后，在获得🔒之后，再开启事务，避免了两个事务开启时间相近，就可以解决问题。</p><p>所以解决方法其实很简单，将 transactionLogic() 方法上面，开启事务的注解去掉即可。</p><p>去掉之后，流程就变成下面所示：</p><table><thead><tr><th>操作顺序</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>获取🔒（成功）</td><td>获取🔒（阻塞）</td></tr><tr><td>2</td><td>开启事务</td><td></td></tr><tr><td>3</td><td>判断 service.getProperty()  =&gt;  为空</td><td></td></tr><tr><td>4</td><td>service.doSomeThing()</td><td></td></tr><tr><td>5</td><td>释放🔒</td><td></td></tr><tr><td>6</td><td>提交事务</td><td>获取到🔒（阻塞结束）</td></tr><tr><td>7</td><td></td><td>开启事务</td></tr><tr><td>8</td><td></td><td>判断  service.getProperty()  =&gt;  仍然为空</td></tr><tr><td>9</td><td></td><td>service.doSomeThing()</td></tr><tr><td>10</td><td></td><td>释放🔒</td></tr><tr><td>11</td><td></td><td>提交事务</td></tr></tbody></table><p>可以看到，在获取到🔒之前，是不会开启事务的，这样就避免出现因为可重复读，导致无法及时获取到更新的信息。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次解决这个BUG，让我对于数据库中隔离级别又有了深入的理解。</p><p>同时，很多框架都不是黑盒子，都是可以去分析解决的，就比如这次开启事务与获得🔒的顺序，导致了BUG，如果只是认为这是框架的锅，我弄不懂，不想去分析，那这个BUG就永远无法解决。</p><p>同时，Never stop learning！</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>事务的隔离级别</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的 2021 上半年 - 个人的一些感想与总结</title>
    <link href="/2021/07/13/%E6%88%91%E7%9A%842021%E4%B8%8A%E5%8D%8A%E5%B9%B4%20-%20%E4%B8%AA%E4%BA%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <url>/2021/07/13/%E6%88%91%E7%9A%842021%E4%B8%8A%E5%8D%8A%E5%B9%B4%20-%20%E4%B8%AA%E4%BA%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="我的2021上半年-个人的一些感想与总结"><a href="#我的2021上半年-个人的一些感想与总结" class="headerlink" title="我的2021上半年 - 个人的一些感想与总结"></a>我的2021上半年 - 个人的一些感想与总结</h1><h2 id="开学，成为项目负责人-｜-3月"><a href="#开学，成为项目负责人-｜-3月" class="headerlink" title="开学，成为项目负责人 ｜ 3月"></a>开学，成为项目负责人 ｜ 3月</h2><p>还没开学，老师就在钉钉上通知我，以我为负责人，成立一个项目组。</p><p>这个项目是关于桑蚕的项目，包含了服务器端、后台管理、小程序。同时这个小程序包含了蚕病识别以及蚕座密度检测（其实蚕座密度就是蚕虫数量）。</p><p>老师给我们订了个ddl，在5月20日前完成。</p><p>因为之前没怎么做过算法，所以我对这块心里还是没底的。</p><p>刚开学，3月初到20号这段时间，一直在写需求分析报告和架构设计文档。众所周知，程序员最讨厌的就是别人代码没写文档，以及写文档。</p><p>写文档这个事，还是挺重要的。以前我在学习Java，入门的时候，对于怎样设计、怎样实现，都是很蒙的。就是如果你告诉我，写出来的程序该长成啥样，我可以很快地敲出来。</p><p>但是一旦让我自己设计一下，从头实现，速度就慢了很多。我甚至不愿意去思考，每当我去思考设计架构时，就会去逃避，因为没有对应的方法论来支持我去做这些。</p><p>所以在前期写需求分析以及设计文档时，都磨磨叽叽，实在写不好。所以我们就只能照葫芦画瓢地去写文档，画原型图。就这样两个文档我们写了20天，三个星期。😂</p><p>事实证明，前期的分析做到位了，确实后面开发就快多了。</p><h2 id="开发进入高速状态-｜-4月"><a href="#开发进入高速状态-｜-4月" class="headerlink" title="开发进入高速状态 ｜ 4月"></a>开发进入高速状态 ｜ 4月</h2><p>由于前面设计文档写的详细，对于数据结构的设计，后端的设计，让我们后台开发进展极快。我们是3月20多号开始写后台，在4月初大概3号还是4号的时候，就完成了大概80%。</p><p>不过这个时候的后台还只是个骨架，只不过把CRUD全部弄好了，像登录啊、token验证之类的都还没有去实现。</p><p>在和学长交流之后，我们选择了类似JWT的方式来存储用户信息，将部分信息以token的形式存在用户端。关于这部分的设计在之前的一篇博客中就有。</p><p>在最开始搭建框架，写pom依赖的时候，就出现了一堆问题。</p><p>spring的版本乱选，附带组件的版本也乱选，最后一堆maven依赖冲突。</p><p>后来看了学长们以前项目的pom依赖文件，发现了<parent>标签，是专门来做这种版本管理的，指定了parent后，parent里指定的组件，版本都已经选择好了，不会出现冲突。</p><p>还有一堆以前没踩过的坑，比如我们的controller想写成REST风格，但是又没完全按照这种规范，导致出现了一堆接参问题。这个也为后面开发小程序和web后台埋下了隐患。</p><p>在小程序中，使用wx.request来发送请求时，它默认是 application/json 的形式。我们的controller没有做对应的处理，使用了form表单的形式接参，自然参数都没有被解析出来。</p><p>后来我看了不少项目，发现好多都是使用实体类来接参，并且有对应的注解，来对参数进行校验。</p><p>同时在解决登录token问题时，也深入了解了一下spring带的AOP，学习了一下动态代理。上一篇就是关于动态代理的博客。</p><h2 id="开发小程序与web后台-｜-5月-～-5月底"><a href="#开发小程序与web后台-｜-5月-～-5月底" class="headerlink" title="开发小程序与web后台 ｜ 5月 ～ 5月底"></a>开发小程序与web后台 ｜ 5月 ～ 5月底</h2><p>得益于我在本科大二时，自己学过一些前端的东西，而且在学Java的时候，也写了一些页面，从jsp到thymeleaf，以及后来的vue。</p><p>微型小程序方面，其布局几乎和web那一套差不多（前端大佬勿喷，确实挺像的），所以开发就还算顺利，最多遇到不会的查查手册。</p><p>在开始开发web前，和实验室的克文学长交流之后，我们决定使用vue。因为用vue的人多，而且文档比较齐全，所以vue比较符合我们的需求。</p><p>在网上找了一堆项目后，发现有个叫vue-element-admin的项目，把很多业务的页面都给做好了，直接应用就行。同时这个项目是以element ui为基础的，所以上手较快，我们通过文档，很快就写完了。</p><p>此时是5月底，基础已经开发完了，剩下的就是算法了。</p><p>不过也因为开发任务比较重，所以这段时间没什么积累，博客的产出速度慢了很多。</p><p>同时这个月，因为做项目老师发了补助，在冲动下，🐛了一个switch，为了玩塞尔达（yyds）。</p><p>下面就是美图共赏🐶</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/2021051822351800-F1C11A22FAEE3B82F21B330E1B786A39.jpg" alt="塞尔达与林克在战败后的场景"></p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/2021050421321900_c.jpg" alt="拔大师剑"></p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/2021042413202000_c.jpg" alt="初见杀"></p><p>在五月底，我们实验室出去轰趴了一次，欢送研三学长学姐毕业，学长学姐们都非常厉害，各个都找到了心仪的工作。</p><p>轰趴我们打了麻将、唱了歌、打了牌、玩了switch上的派对游戏，玩的很开心。</p><h2 id="项目接近末尾以及合肥出差-｜-6月"><a href="#项目接近末尾以及合肥出差-｜-6月" class="headerlink" title="项目接近末尾以及合肥出差 ｜ 6月"></a>项目接近末尾以及合肥出差 ｜ 6月</h2><p>6月份我们的项目基本上接近维护阶段，主体开发基本完成，剩下的就是修修补补，完善了。</p><p>本来准备在这个月18号过生日，和室友们一起出去好好恰一顿。结果当周周二，老师告诉我们要去合肥出差谈项目。</p><p>好家伙，这波是特殊的生日过法。而且就正好在生日前一天出差，一直到周六结束。</p><p>到了合肥，老师也把以前毕业的一个学长叫了过来，一起吃了个饭。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/mmexport1625819933432-20210716195917761.jpg" alt="和老师还有学长吃饭"></p><p>后来项目谈完了之后，我们几个一商量，觉得合肥没啥玩的，就定了票，直接跑到南京去了。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/IMG_20210620_124955-20210716195935924.jpg" alt="中山陵"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个学期，因为做项目，加上自己懒，所以没有学什么新的东西。</p><p>这个暑假，准备学一些东西，目前是在看编译原理方面的书，之前一直没有看，觉得要了解一些。</p><p>也确实要做些规划，不能停止学习。</p>]]></content>
    
    
    <categories>
      
      <category>个人总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人总结</tag>
      
      <tag>2021</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>由项目踩坑引发的思考 - 动态代理的原理与手动实现</title>
    <link href="/2021/04/17/%E7%94%B1%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%20-%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/04/17/%E7%94%B1%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%20-%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 最近项目中，由于明文传输user_id有一定的风险，所以采用上一片文章中的方法，将user_id以及一些数据加密为token并保存在客户端。</p><p>每次客户端请求时，携带上token，服务器解析该token获取相关数据。</p><p>不过由于该项目由我们从0开始搭建的，之前没有其他项目踩坑的经历，所以在很多框架结构的设计上，埋下了不少的坑。</p><p>其中之一，就是为了测试方便，一开始写controller时，传user_id等数据时，直接用的是表单形式。</p><p>后来修改为使用token传递后，就要对整个controller进行修改，这工作量就打起来了啊。</p><p>众所周知，我是个懒人（gou），能用代码（或者说使用pc能实现自动化的手段）实现的，除非代码也比较难写（还是懒），否则我坚决不用手改。</p><p>在思考如何解决这个问题时，突然想到之前学习spring（那都是一年以前的故事了）的时候，记得视频里面讲过AOP，即 Aspect Oriented Programming，面向切面编程。</p><p>其就是解决有大量方法需要进行同样操作时，节省代码量以及便利性的一种方法。</p><p>印象里以前JVM及字节码的时候，里面讲到过有些应用，就是使用动态代理，来为所有方法加上一个日志记录的操作，同时mybatis也是通过动态代理，来为mapper接口生成动态实现。</p><h1 id="什么是AOP？"><a href="#什么是AOP？" class="headerlink" title="什么是AOP？"></a>什么是AOP？</h1><p>以下摘自<a href="https://www.cnblogs.com/xrq730/p/4919025.html">博客园的文章</a></p><blockquote><p>AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p><p>AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p><p>使用”横切”技术，AOP把软件系统分为两个部分：<strong>核心关注点</strong>和<strong>横切关注点</strong>。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p></blockquote><h1 id="AOP的使用"><a href="#AOP的使用" class="headerlink" title="AOP的使用"></a>AOP的使用</h1><h2 id="切面（pointcut）"><a href="#切面（pointcut）" class="headerlink" title="切面（pointcut）"></a>切面（pointcut）</h2><p>首先需要定义切面。具体的文档以及使用方法我在此就不赘述了，<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop">Spring文档</a>写的非常清楚。并且由于使用注解相对于xml配置来说，方便很多，所以我在这里用注解的方式来实现。</p><p>因为我们会在小程序与后台交互的过程中使用token，所以首先配置好切面，即pointcut。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/image-20210417164334892-20210418132220350.png"></p><p>由于项目不公开，所以一部分我打码了，不过应该可以理解我的意思，spring提供的API已经非常全面且好用，可以支持各种不同的需求。切面其实也就是确定AOP要作用于的方法。</p><h2 id="通知（advice）"><a href="#通知（advice）" class="headerlink" title="通知（advice）"></a>通知（advice）</h2><p>这里我是用的是 <strong>@Around</strong> 通知。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/image-20210417170114220.png"></p><p>我们在切面所在方法执行前，对header中的token进行解析，并将其装入到当前请求所在环境的RequestAttributes中，这样我们就不用在切面方法执行时，传入参数。直接将这些参数放到请求的环境中，让controller中方法按需求获取，操作空间更大，也不用强制满足方法参数的约束。</p><p>同时为了获取参数更加方便，我封装了一个工具类，省去了重复写获取参数的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">RequestContextHolder.getRequestAttributes().getAttribute(key, RequestAttributes.SCOPE_REQUEST)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/image-20210417171106415.png"></p><p>并且我们知道，每当一个请求过来时，实际上前端控制器是会为每一个请求创建一个线程（简要来说，Spring的实现在此基础上肯定进行了更复杂的封装以满足高吞吐量的需求）。</p><p>而我将参数保存时， <strong>RequestContextHolder.setRequestAttributes()</strong> 中范围设置为了SCOPE_REQUEST，也就是说当前请求所在的线程，都是可以获取到的。也避免了多个请求来时，导致参数被覆盖而出现问题。</p><h1 id="由AOP引发的思考"><a href="#由AOP引发的思考" class="headerlink" title="由AOP引发的思考"></a>由AOP引发的思考</h1><p>AOP的实现原理，完全使用java语言自身特性来实现。</p><p>我查了下相关的资料与博客，AOP使用了JDK与CGLIB的动态代理。</p><p>JDK的动态代理有一个问题，就是他代理的类，必须是接口的实现类，否则无法生成代理类。</p><p>那么既然我们知道了JDK动态代理是基于生成动态代理类，我们能不能自己尝试写一个呢？</p><h1 id="手动实现动态代理"><a href="#手动实现动态代理" class="headerlink" title="手动实现动态代理"></a>手动实现动态代理</h1><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>在开始写动态代理前，我们先看看静态代理。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/image-20210418133747115.png" alt="静态代理"></p><p>实际上如果是静态代理，其实就是代理对象（Proxy对象）将实际的实现类对象（Impl对象）包装在自己内部，当主程序通过多态调用接口类（Interface对象）方法时，代理类可以在实际的实现类方法调用的前、后进行自己的操作。</p><p>不过既然它是静态代理，因此调用的方式、先后顺序以及其代理的接口类都是写死的，极其不通用，所以我们才需要实现“动态”，来满足各种需求。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>我实现的动态代理，其实和静态代理很相似，只不过对于代理的对象，可以进行自定义，同时代理对象的操作也可以定制。</p><p>比如这个项目我想在实现类方法执行前打印一句“Let’s roll”，那个项目我想在实现类方法执行后打印一句“nothing is true, every thing is permitted”，一切都可以自己定制。这样通用性就更好。</p><h4 id="JDK动态代理的实现"><a href="#JDK动态代理的实现" class="headerlink" title="JDK动态代理的实现"></a>JDK动态代理的实现</h4><p>我们先来看一下JDK动态代理中，InvocationHandler类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> Throwable</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其提供了proxy、method、args三个变量。</p><p>proxy代表了动态生成代理类的实例对象，method代表了当前执行的方法，args则是该方法的参数。</p><p>这样就可以在执行method.invoke( )，也就是执行真正实现类方法前或者后，进行各种操作。</p><p>其他的我就不赘述了，读者可以自己去尝试使用JDK动态代理，然后使用如下语句，来设置保存最后的动态代理类。然后看一下生成的动态代理类，就能明白其大致原理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.getProperties().put(<span class="hljs-string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>,<span class="hljs-string">&quot;true&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="自己的实现"><a href="#自己的实现" class="headerlink" title="自己的实现"></a>自己的实现</h4><p>我自己的实现就比较简陋了，没有自定义代理方法和具体实现类方法之间的顺序，只是简单地设置为先运行代理的方法，然后运行实体类方法。</p><p>我的实现分为了5步</p><ol><li>实现InvocationHandler类，将需要运行的代码放入到接口invoke( )方法中</li><li>传入实现类与接口类的Class对象，以及上一步创建好的InvocationHandler类对象</li><li>通过预先写好的模板，通过拼接生成字符串，并将其保存为 $Proxy0.java 文件</li><li>对文件进行编译，生成 $Proxy0.class 字节码文件</li><li>通过 java 的反射机制，动态加载  $Proxy0.class 字节码文件，并在jvm中生成对应的Class类对象，并实例化生成对象，返回方法调用</li></ol><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/image-20210418141300704.png" alt="Test.java 用于测试"></p><p>完成后创建一个Test类，进行测试。</p><p>首先创建一个实现了invoke方法的 InvocationHandler 对象实例，然后通过 UserPersistenceProxy 类的 newInstance 静态方法，生成代理后的对象。</p><p>调用接口类中的方法，根据多态，其会自动判别调用的方法。</p><p>其中 UserInterface 如下图。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/image-20210418141625056.png" alt="接口类"></p><p>而接口的实现类如下图。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/image-20210418141645757.png" alt="实现类"></p><p>此时我们运行该测试，最终 terminal 输出如下：</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/image-20210418141723345.png" alt="最终运行结果"></p><p>确实实现了动态生成字节码，并代理的效果。并且代理类确实是在运行时生成并加载的，相比于静态代理，更加的灵活。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在自己实现了简单的动态代理后，对于动态代理的实现方式，就有了一些自己的理解。</p><p>对于我自己个人来讲，我不太喜欢死记硬背。相反，我更喜欢自己尝试去理解，通过探索、理解的过程，来让大脑自己记住，而不是强迫大脑去记忆。</p><p>这一次的手动实现，虽然实现了基本的效果，但是任然有几个地方，因为时间和精力的问题，没有做好：</p><ol><li>生成的 java 文件需要持久化保存在硬盘中，以文件的形式后，才能被编译。查了一些相关资料之后，发现有专门的一个库，可以直接将拼接好的字符串，在内存中直接编译，并直接动态加载，减少了因为持久化，导致文件IO过程中占用的时间。同时也不用从硬盘中手动读取比特流。</li><li>没有自定义代理方法和实际实现类方法之间调用顺序的逻辑，我为了省事，直接写死了，后续可以借鉴JDK中 InvocationHandler 的形式。</li><li>没有具体去看CGLIB的实现方式。</li></ol><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><script src="https://gist.github.com/Javen-Liu/460be480224c0a20dc8b2f3a693e0ebc.js"></script><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.cnblogs.com/youzhibing/p/10464274.html">设计模式之代理，手动实现动态代理，揭秘原理实现</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>动态代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JWT —— Json Web Token</title>
    <link href="/2021/04/11/JWT%20%E2%80%94%E2%80%94%20JSON%20WEB%20TOKEN/"/>
    <url>/2021/04/11/JWT%20%E2%80%94%E2%80%94%20JSON%20WEB%20TOKEN/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JWT，可能很多读者听过，或者了解过，也可能工作的时候用到过。</p><p>其全称是Json Web Token，具体的中文翻译，我在网络上也没找到比较好的说法，最多就是把token翻译为较为常用的“令牌”一词。</p><p>说到JWT，不得不提session。</p><p>由于HTTP请求是无状态的，打个比方，比如你使用同一个电脑，同一个浏览器，打开淘宝，点击将商品放入购物车中，然后点击购物车。</p><p>在你的视角中，将商品放入购物车，然后点击购物车，都是“你”的行为，这些操作都是“你”做的。但是，服务器是怎么知道，两次请求是“你”做出来的呢？</p><p>那自然需要前端与后端进行配合，识别出这两次操作，是又“你”做出来。如果不识别出来你的身份，那点击购物车查看的时候，说不定会看到别人的购物车。那就乱套了啊！</p><p>所以，才会出现session与cookie，以此来解决这个问题。</p><h1 id="传统的session认证"><a href="#传统的session认证" class="headerlink" title="传统的session认证"></a>传统的session认证</h1><p>我们在服务器，使用session技术，将用户的认证信息存在服务器中，并且在HTTP请求响应时，将其部分信息返回，并告诉浏览器将其保存在cookie中。</p><p>下次客户端（或者叫前端）再发送请求时，带上cookie，服务器就能根据其中的信息，找到session中对应保存的用户信息，服务器自然就知道用户是“你”，并且把你的购物车信息返回。</p><p>session确实也是很不错的解决办法，但是其存在一定的缺陷：</p><h2 id="1-服务器负载量"><a href="#1-服务器负载量" class="headerlink" title="1. 服务器负载量"></a>1. 服务器负载量</h2><p>session是保存在服务器端的，虽然在小型应用中，用户的信息量不大，并且用户数量页不够多。</p><p>但是当应用的规模变大时，用户的信息量变大，用户数量也增加，自然服务器的负载就大了。</p><p>服务器程序运行时，大多数的数据都是存储在内存中，更何况是用户信息这种需要快速查找的数据。一旦存储总量变大，内存就会告急，影响服务器程序的运行。</p><h2 id="2-扩展性"><a href="#2-扩展性" class="headerlink" title="2. 扩展性"></a>2. 扩展性</h2><p>如果服务器使用分布式的微服务，那么就要保证分布式服务器中，每个服务器上的用户数据具有一致性，这样就需要相应的负载均衡器，并保证多个服务器上的数据同步。</p><p>这样也会增加一定的负担</p><h2 id="3-CSRF"><a href="#3-CSRF" class="headerlink" title="3. CSRF"></a>3. CSRF</h2><p>CSRF全称为 Cross-site request forgery，翻译为跨站请求伪造。</p><p>通俗点说就是网站先诱骗用户登录一些需要认证的网站，获取了对应的cookie后，通过该cookie仿造用户的身份，和服务器进行交互，以此实现攻击。</p><p>可以说这是使用session与cookie的一种缺点，但其实际上通过一定的防御措施，是可以避免的，不过在本文就不赘述了，感兴趣的读者可以自己去搜索了解。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>session与cookie技术是用来解决认证问题的一种方法，其从提出到现在，虽然有些缺陷或者不足，但经过这么多年的实践以及改进，可以说已经是非常的成熟了。</p><p>不过由于我们目前的项目前端是小程序，没有cookie（虽然cookie与JWT并不冲突），再加上学长们之前用的就是JWT的方式，所以我们的项目就用了JWT的方式。</p><h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><h2 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h2><p>前面说了那么多，那么到底什么是JWT呢？</p><blockquote><p><strong>JSON Web Token</strong> (<strong>JWT</strong>) is an Internet <a href="https://en.wikipedia.org/wiki/Proposed_standard">proposed standard</a> for creating data with optional signature and/or optional encryption whose <a href="https://en.wikipedia.org/wiki/Payload_(computing)">payload</a> holds <a href="https://en.wikipedia.org/wiki/JSON">JSON</a> that asserts some number of <a href="https://en.wikipedia.org/wiki/Claims-based_identity">claims</a>.</p><p>—— wikipedia</p></blockquote><p>其是一种互联网提议的标准，用于创建具有可选签名和可选加密的数据，其“有效负载”部分持有Json，并断言了一些声明。</p><p>可能读者看完上面的说法， 还是没太搞明白。其通俗地讲，就是一种规范，让服务器按照其规范来进行产生token，并将其返回给客户端。</p><p>当客户端再次请求时，携带该token，服务器获取到token后，通过规定好的算法来解密，获取用户信息。</p><p>也就是说其与session最大的不同，就是session将用户信息，保存在了服务器，每次客户端请求时，以cookie中的数据作为“索引”，在服务器session中查找对应的信息。</p><p>而JWT则是直接将用户的部分信息放入到token中，并通过一定的流程进行加密，避免被人恶意解析。在客户端请求登录后，服务器将token返回，让客户端保存。在后来的请求中，客户端携带上token，服务器从token中直接可以把用户信息取出来。<strong>总而言之，就是用户信息不在服务器中保存了，而是保存在这个token中，减轻了服务器存储的压力。</strong></p><p>那么很显而易见的一个问题就是，token可以被显而易见的取出来，正如cookie一样。因此我们在生成token时，要使用对称的加密算法，进行加密。既然能被获取到已然是事实了，那我们就只能通过不让别人解析有用信息的方法，防止信息泄漏。</p><h2 id="JWT的流程"><a href="#JWT的流程" class="headerlink" title="JWT的流程"></a>JWT的流程</h2><ul><li>用户使用用户名密码（或者小程序的openid）来请求服务器</li><li>服务器验证用户的信息</li><li>服务器通过验证，并发给用户一个token</li><li>客户端存储token，在每次请求时，都带上token</li><li>服务器验证token并从中取出有用的信息</li></ul><h2 id="JWT的构成"><a href="#JWT的构成" class="headerlink" title="JWT的构成"></a>JWT的构成</h2><p>JWT包含了三部分：header、payload 以及 signature</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/image-20210411174631309.png" alt="JWT"></p><h3 id="header（头部）"><a href="#header（头部）" class="headerlink" title="header（头部）"></a>header（头部）</h3><p>header包含了两部分内容：</p><ol><li>声明类型，这里是jwt</li><li>声明加密的算法，通常直接使用HMAC SHA256</li></ol><p>完整的头部是下面这样的</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  &#x27;alg&#x27;: &#x27;HS256&#x27;,<br>  &#x27;typ&#x27;: &#x27;JWT&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后将头部使用base64加密，得到第一部分header：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">eyJhbGciOiJIUzI<span class="hljs-number">1</span><span class="hljs-symbol">NiIsInR5</span>cCI<span class="hljs-number">6</span>IkpX<span class="hljs-attr">VCJ9</span><br></code></pre></td></tr></table></figure><h3 id="payload（负载）"><a href="#payload（负载）" class="headerlink" title="payload（负载）"></a>payload（负载）</h3><p>负载就是存放信息的地方，其中包括了：</p><ol><li>标准中注册的声明</li><li>自定义的声明</li></ol><h4 id="标准中的声明有（建议但是不强制使用）："><a href="#标准中的声明有（建议但是不强制使用）：" class="headerlink" title="标准中的声明有（建议但是不强制使用）："></a>标准中的声明有（建议但是不强制使用）：</h4><ul><li><strong>iss</strong>: jwt签发者</li><li><strong>sub</strong>: jwt所面向的用户</li><li><strong>aud</strong>: 接收jwt的一方</li><li><strong>exp</strong>: jwt的过期时间，这个过期时间必须要大于签发时间</li><li><strong>nbf</strong>: 定义在什么时间之前，该jwt都是不可用的.</li><li><strong>iat</strong>: jwt的签发时间</li><li><strong>jti</strong>: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</li></ul><h4 id="自定义的声明："><a href="#自定义的声明：" class="headerlink" title="自定义的声明："></a>自定义的声明：</h4><p>公共声明可以添加任何信息，一般是放一些不太敏感的信息，该部分实际上也是明文。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;iss&quot;</span>: <span class="hljs-string">&quot;matrix-world.top&quot;</span>,<br>    <span class="hljs-attr">&quot;iat&quot;</span>: <span class="hljs-number">1500218077</span>,<br>    <span class="hljs-attr">&quot;exp&quot;</span>: <span class="hljs-number">1500218077</span>,<br>    <span class="hljs-attr">&quot;aud&quot;</span>: <span class="hljs-string">&quot;blog.matrix-world.top&quot;</span>,<br>    <span class="hljs-attr">&quot;sub&quot;</span>: <span class="hljs-string">&quot;1248540980@qq.com&quot;</span>,<br>    <span class="hljs-attr">&quot;user_id&quot;</span>: <span class="hljs-string">&quot;dc2c4eefe2d141490b6ca612e252f92e&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用base64加密后，得到了第二部分payload：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">eyJpc<span class="hljs-number">3</span>MiOiJtYXRyaXgtd<span class="hljs-number">29</span>ybGQud<span class="hljs-name">G9</span>wIiwiaWF<span class="hljs-number">0</span>Ijox<span class="hljs-symbol">NTAwMjE4</span>MDc<span class="hljs-number">3</span>LCJleHAiOjE<span class="hljs-number">1</span>MDAyMTgw<span class="hljs-symbol">NzcsImF1</span>ZCI<span class="hljs-number">6</span>ImJsb<span class="hljs-number">2</span>cubWF<span class="hljs-number">0</span>cml<span class="hljs-number">4</span>LXd<span class="hljs-attr">vcmxkLnRvcCIsInN1</span>YiI<span class="hljs-number">6</span>IjEy<span class="hljs-symbol">NDg1</span><span class="hljs-symbol">NDA5</span>ODBAcXEuY<span class="hljs-number">29</span>tIiwidX<span class="hljs-symbol">Nlcl9</span>pZCI<span class="hljs-number">6</span>ImRjMm<span class="hljs-name">M0</span>ZWVmZTJkMTQx<span class="hljs-symbol">NDkwYjZjYTYxMmUyNTJmOTJlIn0</span><br></code></pre></td></tr></table></figure><h3 id="signature（签名）"><a href="#signature（签名）" class="headerlink" title="signature（签名）"></a>signature（签名）</h3><p>JWT的签名是header与payload在经过base64加密后，拼接在一起，然后使用声明的加密方式，进行加盐<strong>secret</strong>加密，就构成了签名</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">JED<span class="hljs-number">8</span>D<span class="hljs-number">7</span>KhTdBBe<span class="hljs-symbol">NqLW4</span>d<span class="hljs-number">5</span><span class="hljs-symbol">N_gQr6</span>IeUfjOPw<span class="hljs-number">3</span><span class="hljs-symbol">n3</span>kXea<span class="hljs-symbol">NQ</span><br></code></pre></td></tr></table></figure><p>最终将三个部分拼接，并使用 <strong>.</strong> 进行间隔，就生成了JWT的token</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>从上面的文字中，可以看出，实际上JWT除了最后的signature，其余部分都可以说是明文了。</p><p>我在网络上又找到一篇文章<a href="https://learnku.com/articles/22616">《别再使用JWT作为session系统》</a>，其思路说的也有道理，虽然目前使用JWT比较流行，但是其确实存在一些问题，其作为一次性的授权令牌就是比较好的应用。</p><p>同时JWT的思路也值得借鉴，那就是将信息发给用户，让用户保存，在后续请求中带上该信息，即可减轻服务器的存储压力。</p><p>我们目前的项目，需要保存用户的一些关键信息，并使用其作为索引，以查找数据库中用户更具体的信息。</p><p>直接使用JWT是存在问题的，我们项目的初衷是想隐藏用户id之类的敏感信息，不使其以明文的形式暴露在HTTP请求中，JWT中payload几乎可以说是明文的，不符合要求。</p><p>不过可以借鉴JWT的思路，同时再使用对称加密算法，将信息加密，避免了明文传输。</p><p>看了不少博客以及文章之后，我们项目最终确定使用加密token来保存信息，并且将信息发送给客户端，让客户端保存。时序图如下：</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/image-20210411185533818.png" alt="前后端交互时序图"></p><p>其他再具体的细节就不方便说了，因为实验室的项目和别人是有合作的，因此就不便透露了。</p><p>目前来说，效果还可以，避免用户个别信息明文传输的目标的确是实现了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.jianshu.com/p/576dbf44b2ae">什么是 JWT – JSON WEB TOKEN</a></li><li><a href="https://learnku.com/articles/22616">（译）别再使用 JWT 作为 Session 系统！问题重重且很危险。</a></li><li><a href="https://exp.newsmth.net/topic/6d3ae68713a816f3feaeebd6bb1c4cc9/6">jwt相比普通token，优势在哪？</a></li><li><a href="https://en.wikipedia.org/wiki/JSON_Web_Token">维基百科</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JWT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程是怎样切换的？</title>
    <link href="/2021/02/03/%E7%BA%BF%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E5%88%87%E6%8D%A2%E7%9A%84%EF%BC%9F/"/>
    <url>/2021/02/03/%E7%BA%BF%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E5%88%87%E6%8D%A2%E7%9A%84%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="寒假期间的安排"><a href="#寒假期间的安排" class="headerlink" title="寒假期间的安排"></a>寒假期间的安排</h2><p>很久没有更新文章了，其实寒假的时候写了2020年下半年的总结，但是因为换了个电脑，以前hexo的配置也没同步过来，所以也就没有把文章上传上去。</p><p>寒假一直在看《操作系统真象还原》，看书名应该就能知道，是关于操作系统的书。</p><p>在看这本书之前，我也看了一本入门的书，书名大概叫《30天自制操作系统》，给我当时入了个门。</p><p>但是看完之后，仍然对于整个操作系统，还是没有一个较为系统的概念。</p><p>比如进程的切换啊，内存管理啊，写的都不是很详细。</p><p>寒假我看网上推荐的《操作系统真象还原》，就在放假前，去图书馆借了一本，带回家看。</p><p>虽然对于基础比较好的人来说，这本书写的有点啰嗦，也就是有些概念作者使用较为白话的方式，来解释。</p><p>但是对于我这样一个小白来说，还是有助于理解的。</p><p>与此同时还配合了哈工大李志军老师的《操作系统》公开课，非常受益！非常建议看过入门书籍后的同学，去听听课，做一做配套的实验课，对于理解整个系统是有帮助的。</p><h2 id="关于《crafting-interpreters》"><a href="#关于《crafting-interpreters》" class="headerlink" title="关于《crafting interpreters》"></a>关于《crafting interpreters》</h2><p>寒假同时还一直在看一个外国老哥写的《crafting interpreters》，一本带着你写解释器的书。</p><p>从去年就一直在看，从最开始用Java写，到第二步，使用c语言实现一个解释器，这本书真的就像作者自己说的那样，带你实现一个简单的解释器，破除对于编程语言的蜜汁害怕，让你发现，语言原来没那么高深。（至少语言的本质是能有所了解的）</p><p>去年的博客里，就有我自己翻译这本书的文章，不过一共就只有3篇，后面也没翻译了，因为涉及到的名词还是很多的，同时本人有比较懒。</p><p>当然最最重要的一点，也是为什么我专门写了一个小标题，就是这本书的质量真的非常好，写的也是很通俗易懂，直接看英文，比看我这种二流程序员翻译了一遍，要好很多。</p><p>我的翻译水平也不是很行，真的直接看原文，反而能够理解作者的意思，同时还能get到很多有梗，开玩笑的地方。而且这本书中的所有插图，全是作者自己画的！非常厉害，画的很精美，且很好地帮助读者理解一些概念。</p><p>所以我还是推荐大家直接去这本书的网站去看。目前这本书是作者公开在网络上的，完全免费的，想要了解一些关于编程语言的同学，试着去读一下这本书，还可以锻炼自己的英文阅读能力，以后毕业写论文也绝对是用得上的。</p><h1 id="引出问题"><a href="#引出问题" class="headerlink" title="引出问题"></a>引出问题</h1><p>最开始学习软件方面的时候，是在大三的时候学习了Java课程，OOP给当时的我，带来了很大的影响。</p><p>因为大一的时候，学习了c语言，但也只是学了最简单的数据类型，控制流，再深入的老师也没教，所以我一直又个疑问，那就是学了编程语言，到底怎么做出那些看着很厉害的软件的，就靠这些if else吗？</p><p>后来学了OOP，动手写了一个自动售货机的实验，当时还分成了展示层、服务层和数据层，慢慢地让我了解了怎么写出一个看上去还行的“东西”，起码它可以交互了。</p><p>后来慢慢开始深入地学习Java，学习了框架，开始了解多线程，了解到了JVM。</p><p>但是，仍然有一个问题让我感到很疑惑：多线程里，线程是怎么切换的？</p><p><strong>ps：本文有点硬核，并且作者水平有限，但也尽量做到能够用白话讲这个过程讲清楚。</strong></p><h1 id="C语言文件到底是怎么运行的？"><a href="#C语言文件到底是怎么运行的？" class="headerlink" title="C语言文件到底是怎么运行的？"></a>C语言文件到底是怎么运行的？</h1><p>在讲解线程切换的原理之前，我们先弄清楚C语言文件到底是如何跑起来的。在理解这个问题之后，线程切换就好理解多了</p><p>CPU其实就很像一个流水线上的工人，只不过这个工人的效率实在是太高了。</p><p>CPU只识别的了机械码，也就是那一堆一堆的“0010100101010101……”。</p><p>对于CPU来说，执行这些机械码，效率是很高的。但是缺点嘛，显而易见，那就是人太难看懂了。</p><p>难道我们只能背下来所有的机械码，然后一个一个地输入0和1吗？</p><p>前人们显然也觉得这样写程序效率非常低，而且专业性太高了。</p><p>所以他们在想，我们能不能发明一种东西，我们人类按照规定好的方式写，用这个“东西”帮我们翻译成机械码？对，这就是后来的汇编语言以及对应的编译器。</p><p>后来人们发现汇编语言还是有点晦涩难懂，而且不断地操作那些寄存器，太麻烦了，就不能更方便一些吗？对，这就是后来的C语言。</p><p>总结，也就是说，我们写出来的C语言文件，都是通过gcc（GNU C Complier）来进行编译，转成CPU能直接理解的机械码，让CPU来运行。</p><p>实际上CPU是不认识C语言是什么的，它只会不厌其烦，或者说应该叫，锲而不舍地运行CS：IP指向的下一条机械码（CS：IP本文就不展开介绍了，这又涉及到计算机的基础知识，不清楚的读者建议去搜索，或者看看计算机相关的基础书籍），我们先用我们好理解的C语言写出程序，然后通过gcc这样一个工具，把它变成机械码，让CPU执行。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/image-20210314202800431.png" alt="C语言运行起来的过程"></p><p>总结：我们平常用的高级语言，例如C语言，实质上是使用编译器将其转化为了机械指令，然后CPU运行的就是编译后的机械指令。</p><h1 id="那么Java中的线程，和上面说的C语言有什么联系呢？"><a href="#那么Java中的线程，和上面说的C语言有什么联系呢？" class="headerlink" title="那么Java中的线程，和上面说的C语言有什么联系呢？"></a>那么Java中的线程，和上面说的C语言有什么联系呢？</h1><p>是这样的，用《操作系统真象还原》书中所说的，我们平时使用高级语言（C、Java、python等等）写出来的程序，都是“半成品”。</p><p>为什么说是半成品呢，因为我们的程序在运行时，是属于“用户态”的，是无法使用包括但不限于：读写硬盘（也就是IO操作）、读写内存等操作的。这些操作是由“内核态”的程序来提供的，这些操作是实打实会影响计算机的行为，所以“内核态”的程序（也就是操作系统）不放心用户，害怕用户乱操作会把电脑弄坏，因此操作系统会把这些操作封装起来，只提供一定的接口，让我们“用户态”的程序来调用。</p><p>所以我们写出来的程序只能完成一部分的逻辑操作，涉及到上面说的那些重要操作，就不得不与操作系统进行交互。我们准备好数据，交给操作系统，操作系统做完后，把结果返回给我们，我们的用户程序实际上不知道操作系统怎么完成这些操作的。并且如果用户程序想要搞破坏，操作系统也是有权利拒绝这些违规操作。（甚至可以说一些能很容易破坏计算机正常运行的操作，操作系统都是有责任向用户屏蔽，不提供给用户的）</p><p>而作为高级语言之一的Java，其中的线程，恰好就是操作系统封装好，防止我们乱用，给我们提供的功能。</p><p>所以实质上，Java的线程，底层上来说就是操作系统帮我们做好的线程操作，Java对其进行了一定的封装，只提供一些较为安全且易用的操作。比如HotSpot VM，其每个线程都对应了一个内核级线程。（虚拟机的线程模型有1:1（内核线程）、N:1（用户态线程）、M:N（混合）三种，虚拟机规范中没有规定一定要用哪种，所以三种模型都有被使用，HotSpot VM就是1:1模型，即Java语言中的一个线程与内核级线程是1:1）</p><p>而很多操作系统，都是使用C语言开发后，编译成了机械指令，运行起来的，所以想要知道线程是怎么切换的，还是要看操作系统对于线程切换的实现。</p><h1 id="操作系统的线程"><a href="#操作系统的线程" class="headerlink" title="操作系统的线程"></a>操作系统的线程</h1><p>本文所写的线程实现，出自《操作系统真象还原》这本书中，虽然和linux的实现方式可能有些小的出入，但思路是参考了linux，因此大同小异。</p><h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><p>首先我们要明白，线程切换本质是并发。</p><p>以下举例是在单核CPU运行的情况下，多核我们暂时不讨论，毕竟饭一口一口吃，先弄懂基础的。</p><p>什么是并发？就是在一段时间内，例如1000ms内，我以极快的速度在程序A与程序B之间切换，保证了每运行程序A 2ms之后，就换到程序B运行2ms，再切换回程序A，反反复复。</p><p>那么相比于2ms，1000ms看起来就很长，也就是说，1000ms内，程序A与B每个都平均地运行了500ms。而且由于切换的非常快，在我们人类的宏观来看，就像这1000ms内，程序A与B都在同时运行一样。</p><p>所以<strong>并发</strong>在微观上，<strong>同一时刻</strong> 只有一个程序在运行，只不过由于不停地在切换，所以从宏观上来看，像是两个或多个程序在同时运行。</p><p>而<strong>并行</strong>就是实打实的多个程序在同一时刻同时运行，一个核心的CPU理论上是无法做到这个操作的，只有多个核心可以。</p><h2 id="线程是由谁切换的？"><a href="#线程是由谁切换的？" class="headerlink" title="线程是由谁切换的？"></a>线程是由谁切换的？</h2><p>既然是并发，要涉及到切换来切换去。</p><p>那么是谁来进行的切换呢？总不能用户程序自己切换吧，那不就乱了套嘛！我作为一个开发者，我肯定希望我的程序能一直运行下去啊。</p><p>这也是人之常情，毕竟大家都想争夺资源嘛。但如果满足每个人，或者说程序的要求，让他们自己切换程序，给予它们绝对的自由，那必定乱套。所以这个工作，必须由一个有权威、德高望重的“人”来做，才能保证每个用户程序相对来说的公平。毕竟绝对自由意味着混乱，有一定约束的自由才是合理且可能的自由。</p><p>好吧，我摊牌了，上面说的德高望重的“人”，其实就是操作系统。</p><p>这也是为什么，线程是操作系统管理的一项功能，只给用户程序提供一定的接口，剩下的很多操作用户程序是接触不到的。</p><p>那么读者此时暂停一下阅读，简单思考一下，以什么样的规律来切换呢？</p><p>其实我上面暗示的已经很明显了，对，就是每个程序都固定运行相同的时间。</p><p>实际上操作系统用的也是这种思路，不过操作系统还加了一个优先级，来控制这个运行时间的长短。这段运行的时间叫<strong>时间片</strong>。</p><p>操作系统的优先级决定了时间片的大小，优先级高，自然时间片长，在该程序上运行的时间就越高，从宏观上来说，运行的就越快。</p><h2 id="那么怎么实现每隔一段时间进行切换呢？"><a href="#那么怎么实现每隔一段时间进行切换呢？" class="headerlink" title="那么怎么实现每隔一段时间进行切换呢？"></a>那么怎么实现每隔一段时间进行切换呢？</h2><p>上面说到，切换必须由操作系统来做，保证用户程序不会乱来。</p><p>那么，这个间隔的产生，也一定要经过操作系统之手，由操作系统来协调。</p><p>在计算机系统中，有定时器这样一种芯片，专门用来处理定时操作，为CPU减负。</p><p>计算机系统中有两种定时，一种是CPU硬件内部的定时，这个定时是给CPU提供时序，为CPU提供一个处理指令的节奏。因此这个定时非常重要，不允许软件进行修改（ps：虽然操作系统已经很底层，但其实质还是个软件），硬件厂商也没有提供能够修改该定时的操作。</p><p>而另外一种就是外置定时，提供给”用户”（此处指写操作系统的人）使用，来作为一种节奏，控制程序运行。</p><p>操作系统正是使用该定时器，来定时的。本文不涉及定时器芯片的知识，如果有兴趣，读者可以自己去网上搜索定时器的手册。</p><p>设定一个频率，比如每2ms，定时器就向终端芯片发送中断，告诉CPU，定的时间已经到了。</p><p>此时CPU进入到了中断处理程序，检查当前线程的时间片是否还有，如果还有，就推出中断处理，线程继续运行。如果没有时间片了，则重置其时间片，并把该线程放入到”准备队列”中，以便以后还可以再次调度过来。</p><p>放入队列后，下一步就要切换到别的线程去了。</p><h2 id="终于到线程切换了"><a href="#终于到线程切换了" class="headerlink" title="终于到线程切换了"></a>终于到线程切换了</h2><p>上面所有的内容，都可以总结为一句话：</p><p>CPU通过定时器计时，一旦定时器到了定的时间，就通知CPU，CPU就运行中断处理程序，去检查是否要进行切换。</p><p>那么，到重点了，到底是怎么切换的呢？</p><p>其实很简单，既然CPU只会执行CS：IP指向的指令。那我们直接把CS：IP改成另一个线程的程序中，不就可以了嘛。</p><p>是的，线程切换实质就是修改CS：IP，但是我们切换线程切出去了，总要还得切换回来吧！</p><h2 id="上下文保存"><a href="#上下文保存" class="headerlink" title="上下文保存"></a>上下文保存</h2><p>CPU在运行时，会把数据存到寄存器或者内存中。</p><p>寄存器由于其结构设计，其速度与CPU是同一个数量级的，而内存就慢了很多，因此CPU更倾向于使用寄存器。</p><p>所以CPU经常将内存中的数据加载到寄存器中，然后通过寄存器操作来实现各种功能。</p><p>线程在运行时，部分数据会保存在寄存器中，也就是说，每个线程运行程序时，其寄存器里的值都是不同的，跟当前运行的程序有关。</p><p>那么如果我们直接修改了CS：IP，跳到别的线程了，本来寄存器就少，当前线程全部使用了，切换后的线程要运行，就得把原来寄存器中的值被覆盖了。</p><p>当我们试图切换回来时，原来线程运行时，寄存器的值找不到了，那程序再往下运行就可能出事了。</p><p>所以我们在修改CS：IP前，还要把各种寄存器保存起来，放到一个规定好的数据结构中保存。</p><h2 id="具体的切换代码"><a href="#具体的切换代码" class="headerlink" title="具体的切换代码"></a>具体的切换代码</h2><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/image-20210321192317260.png" alt="switch.S"></p><p>可以看到，在7到12行，是将切换前的线程的上下文进行保存。</p><p>接着从16行开始，加载下一个线程的环境。</p><p>在切换线程时，此时esp指向的栈中，数据的分布入上图所示。</p><h2 id="整个线程切换的流程图"><a href="#整个线程切换的流程图" class="headerlink" title="整个线程切换的流程图"></a>整个线程切换的流程图</h2><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/image-20210321193225049.png" alt="线程切换的流程图"></p><ol><li>可以看到，每当定时器计时结束，会像①一样，进入中断处理程序</li><li>此时，在中断处理程序中，会判断当前线程（也就是线程A）的时间片是否用完，如果用完，意味着就要切换了</li><li>在图中，第一次进入中断处理程序时，假设线程A时间片未用完，所以CPU会按照②，继续执行线程A</li><li>第二次进入中断处理程序时，假设此时线程A的时间片用完了，就会按照③，切换到线程B，也就是上面所说的，保护上下文、加载下个线程的上下文的操作</li><li>后面的操作都是一样的，当线程B时间片用完了，会切换到别的线程</li><li>如果当前不只两个线程，就要涉及到线程切换的调度，后面文章会写到</li></ol><p><strong>从图中可以看出，虽然我们用线程切换，但实际上，每个时刻，只有一个程序在运行，所有的都是在一条时间线上，只不过我们通过多次且频繁地切换，让用户看起来，线程A与线程B都在运行。</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文由于跳过了中断的讲解，直接描述了线程切换，所以讲的可能不太好，有兴趣的读者，还是去找一本比较好的书去看看。</p><p>我也尽自己最大的努力去解释这个过程，毕竟学习掌握的最高境界就是能够给别人讲懂。</p><p>同时本文对于线程调度这一块没有具体展开。调度算法非常多，后面可能会更新关于调度算法的文章。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的 2020 下半年 - 个人的一些感想与总结</title>
    <link href="/2021/01/11/%E6%88%91%E7%9A%842020%E4%B8%8B%E5%8D%8A%E5%B9%B4%20-%20%E4%B8%AA%E4%BA%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <url>/2021/01/11/%E6%88%91%E7%9A%842020%E4%B8%8B%E5%8D%8A%E5%B9%B4%20-%20%E4%B8%AA%E4%BA%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="我的2020下半年-个人的一些感想与总结"><a href="#我的2020下半年-个人的一些感想与总结" class="headerlink" title="我的2020下半年 - 个人的一些感想与总结"></a>我的2020下半年 - 个人的一些感想与总结</h1><h2 id="开学，成为一名烟酒生-｜-9月"><a href="#开学，成为一名烟酒生-｜-9月" class="headerlink" title="开学，成为一名烟酒生 ｜ 9月"></a>开学，成为一名烟酒生 ｜ 9月</h2><p>刚开学，一切都是崭新的，又都是熟悉的。</p><p>本来以为要抢宿舍，所以很早定了开学前一天的酒店。</p><p>结果谁知道，直接给统一分配了。说来也很有意思，一开始导员说因为扩招，房源可能不够，大家在群里义愤填膺，纷纷吐槽学校。</p><p>结果离开学没几天，导员突然通知房源够，并且自己组宿舍。并且让我们自己把宿舍名单填到腾讯的在线文档里。</p><p>我们宿舍的几个，基本都是认识的，一群卧龙凤雏（</p><p>宿舍关系还是很融洽的，一个个都是老带哥了，各种带节奏，停不下来。</p><p>而且宿舍分到了南湖新的越苑宿舍，新的宿舍虽然是赶工才装修好的，但是空间相比于鉴湖六人间来说，还是大了不少，尤其是每个人的柜子大小变大了，能放不少衣服，不像以前鉴湖六人间，衣服都没啥地方放，太难了。</p><p>最让我感觉惊喜的是，居然有个小阳台！太爽了，那种站在阳台上，面朝阳光迎接新的一天的感觉，太舒服了（除了第一个月，其余时间从来没有在太阳刚刚亮的时候醒过 :P ）</p><p>崭新的宿舍，崭新的实验室环境，崭新的同学（好像同学不能用崭新形容？）</p><p>然而转了几圈，还是回到了鉴湖，那熟悉而又陌生的鉴湖。熟悉的鉴湖，因为疫情，只有东门开着，每天进出还要打卡。</p><p>尤其是我们还要去西院上课，就得绕远路从东门出去，再从工大路的一头走到另一头，太累了。每天上课，至少40分钟花在路上，就算是强身健体吧。</p><p>虽然烟酒生和我想象的还是有点出入，但我对实验室的所有设施，我们的d9lab基本都有。比较宽敞的桌子，服务器，外接显示器，基本都有，椅子还挺舒服，哈哈。</p><h2 id="成长、变强-｜-10月"><a href="#成长、变强-｜-10月" class="headerlink" title="成长、变强 ｜ 10月"></a>成长、变强 ｜ 10月</h2><h3 id="课开始多了起来-｜-10月上旬"><a href="#课开始多了起来-｜-10月上旬" class="headerlink" title="课开始多了起来 ｜ 10月上旬"></a>课开始多了起来 ｜ 10月上旬</h3><p>慢慢地课全部都开了，每天基本上就是忙于上课，还好大部分课都是西院，也就走个40分钟。</p><p>有一节《机械学习》课，要去东院，走过去，起码要花费1个小时，简直离谱。</p><p>好在这课是早上第二节上课，也就是9点55上课，我可以8点半起来，然后走过去，顺带在路上吃个早饭。（众所周知，走着路吃饭是湖北人的特殊技能）</p><p>我早上的课，全部都是第二节上课，所以这个学期也没有因为早起而被折磨。倒是我的两个室友，他俩是专硕，和我们学硕的课时间排的不太一样，他们这学期有两门课是早上8点在西院上课，被折磨的不行。</p><p>这个月我们也逐渐脱离了杜哥那边，慢慢地没什么事情了，基本就是自己在学习。</p><p>9月到10月份，我也把《Java核心技术》、《Java并发编程》粗略地看了一遍，不过由于没有项目驱动，收获的知识并没有那么多。</p><h3 id="开始接触到linux-｜-10月中旬"><a href="#开始接触到linux-｜-10月中旬" class="headerlink" title="开始接触到linux ｜ 10月中旬"></a>开始接触到linux ｜ 10月中旬</h3><p>这个学期开学，我准备好好学习一些linux。之前刚考完研那会，自己整了个阿里云的服务器，第一次接触到centos，第一次知道服务器能干这么多事情。</p><p>最开始我搭建了一个个人博客，然后部署了一堆整活的东西，不过最后还是觉得索然无味。而且服务器总共才4G内存，部署不了太多东西。</p><p>那个时候用centos，只知道一些非常基础的指令，也都是听java课学到了一些，要让我自己对系统进行一定的操作和定制的话，仍然还是像个小白。</p><p>尤其是那个vim，最开始我连怎么输入，怎么退出都不知道。这可能也是所有刚接触服务器的同学，都会遇到的问题，实在是太头疼了。</p><p>由于老师给了我一个老项目，是关于皮肤算法的，为了把那个代码跑起来，我只能按照学长说的来配环境。</p><p>当时年少不知Ubuntu香，win10安装依赖把我折磨了3天，仍然还是有问题，尤其是opencv之类的库，需要自己下载源码，用mingw或者vs来编译，CMakeList也看不太懂，被折磨的是在快受不了之后，学长给我指了条明路，换成Ubuntu来安装依赖。</p><p>我立马换到实验室的服务器上进行我的“配环境之旅”。好家伙，按照网上的流程，几句命令行，刷刷刷，就安装好了，看着命令行里不断出现字符，而且大多都夹杂着“Success”之类的字符，那感觉不谈了，太爽了。</p><p>也正是这段时间，我开始接触使用Ubuntu，由于自己指令用的少，很多指令都不会，我就只能遇到问题，去查，或者看看我室友的一本《linux从入门到精通》，去学习。</p><p>果然，学习一个东西，技能，或者说知识，最快的方法，就是使用它。用的次数多了，自然就记得住了。</p><p>那几个星期我使用linux的熟练度慢慢高了起来，对于很多操作，渐渐只用命令行也可以完成了。用多了命令行，就慢慢觉得既然我能只用键盘，加上敲几个指令就能完成的事，我为什么还要用图形界面？</p><p>当时命令行用熟练起来之后，慢慢开始膨胀起来了。其实无论是图形界面还是命令行，都有其存在的意义，没有必要踩一捧一。</p><p>不过确实感觉Ubuntu的命令行，比起win10的cmd，好太多了，整体观感这方面，确实舒服一些。不过win10上也有powershell以及不少还不错的终端可以用，这里就不一一列举了。（不过win10下面有个wsl，即windows subsystem linux，很好用，读者们可以试试）</p><h2 id="linux的使用渐入佳境-｜-11月"><a href="#linux的使用渐入佳境-｜-11月" class="headerlink" title="linux的使用渐入佳境 ｜ 11月"></a>linux的使用渐入佳境 ｜ 11月</h2><h3 id="慢慢开始整活-｜-11月初"><a href="#慢慢开始整活-｜-11月初" class="headerlink" title="慢慢开始整活 ｜ 11月初"></a>慢慢开始整活 ｜ 11月初</h3><p>进入11月，linux的使用也更加熟练了。</p><p>但是有一个问题困扰了我，那就是，如何才能在远程连接我们实验室的服务器呢？毕竟我也是个懒人，在服务器和我自己位置之间来回跑，太累了。</p><p>所以说有些进步都是因为人的“懒”，而促使人来进行折腾、创新（不过我这不算创新，只能算用前人的留下的智慧）</p><p>于是我就分析，为什么我的电脑和服务器都在实验室内，但是我却连接不上服务器呢？</p><p>哦，源赖氏（原来是）因为服务器和我的电脑不在同一个内网。我在网上查阅了一些资料之后，发现内网穿透可以解决这些问题。</p><p>后面的内容就是前两篇博客了。</p><p>而后，我还把Ubuntu给美化了一下，shell也改成了zsh（好看就完事了）。</p><p>经过这段时间的使用以及折腾，我光荣地成为了一名服务器配置工具人（害）。</p><p>基本上关于服务器这那的问题，同级的同学以及学长们，都直接让我来弄，工具人罢了。</p><p>月底，我一个初中同学（准确来说，he’s my son）找到我，让我帮他完成个东西。</p><p>这个🐶东西原来也学过python，这个学期开学他们有一门课要用到python来进行爬虫，大作业就是用爬虫爬取数据信息之后，再进行分析。</p><p>好家伙，我一看，就是爬个taptap的网页。</p><p>好歹我也是学后端的，同时也浅尝辄止过一些前端方面的东西，直接打开chrome就是一个F12，一个刷新，一个查看网络请求。害，就是用了分页查询而已，只需要改变request里面的page属性，就能获取到原始的数据。</p><p>接着就是用正则表达式，来进行模版匹配，最后把数据给他爬出来。用了大概2个小时左右，完成了这个代码，然后把数据发给my son，他直接惊呆了，夸了我一波，顺带薅了他一波羊毛，让他给我点了个奶茶外卖。</p><p>没想到，我python没怎么正规学过，就给他解决了他们小组都无法解决的问题。</p><p>看来，我这一年来的学习，还是变强了一些。其实倒不是掌握了多少门语言，掌握的语言数量，并不与能力成正比。我发现计算机的基础知识，才是我变强的原因，只知其一，而不知其二，永远只能做一个代码搬运工。</p><h3 id="开始学习操作系统-｜-11月底"><a href="#开始学习操作系统-｜-11月底" class="headerlink" title="开始学习操作系统 ｜ 11月底"></a>开始学习操作系统 ｜ 11月底</h3><p>11月也过的很快，每天就在开开兴兴整活，学习自己想学的东西，转眼就到了11月底。</p><p>这段时间，我开始慢慢接触到操作系统方面的知识。</p><p>之前疫情在家，我把操作系统通过慕课上东南大学的《操作系统》课程，把基础知识过了一遍，但是还是感觉没有很好地消化掉。仍然还是一知半解的状态，当时想的是，了解一些皮毛知识就行。</p><p>但是之前看到一个公众号的一篇文章，名叫 <a href="https://mp.weixin.qq.com/s/uno-QuRu7wPwIZFhutBLhA">《程序员都应该挑战的6个项目》</a>，里面都是一些看着好像没什么用（对于找工作），但是对于一个程序员的内功，是一个挑战。</p><p>我觉得读者们都可以看看，这些项目都会推荐相关的书，带领你走进这个方面的大门。</p><p>目前自己写一个编程语言的项目，我已经完成了大半，确实从里面收获了不少，尤其是破除了“编程语言“这层迷雾，有种拨云见日的感觉，对于语言的本质也有了一定的理解。</p><p>虽然仍然还是小白，但是这已经让我在遇到一些问题时，能够从语言本质、底层来思考一些问题。</p><p>把书读了大半，确实受益匪浅。</p><p>说来也是运气好，看了几本书都很不错，让我学到了不少东西，没有因为书选的不好走了弯路。</p><h2 id="开始复习，以及各种考试和大作业-｜-12月"><a href="#开始复习，以及各种考试和大作业-｜-12月" class="headerlink" title="开始复习，以及各种考试和大作业 ｜ 12月"></a>开始复习，以及各种考试和大作业 ｜ 12月</h2><p>这个月开始，考试逐渐多了起来，慢慢地开始复习每一门课。</p><p>操作系统的学习也搁置了起来，主要精力都花费在复习考试上。</p><p>这个月也没啥好说的，每天基本上都是在不想复习和不得不复习之间徘徊。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，这一年，我的成长还是很大的。</p><p>从19年刚开始接触java没多久的小白，慢慢成长为一个懂了一些东西的入门码农。</p><p>虽然还没有正式工作，仍然还是在读书，但是今年的学习状态总体来说符合我自己的预期。</p><p>学了不少东西，有用的，没用的，但是我所理解了的，基本上都装进我的脑子里了。</p><p>在杜哥组里，虽然也经常吐槽杜哥，最后也退出组了，但是这段经历，对于我来说也是一种成长。</p><p>我开始接触各种实际的应用，同时杜哥也给我一些自由来在项目上发挥自己的能力。</p><p>尤其是在写难度控制算法的时候，我很庆幸自己之前读了《算法》这本书，并且把它吸收进我的脑子里，我才能把这个算法写出来。</p><p>虽然这个算法不像目前流行的那些机械学习或者深度学习的算法那样深奥，但这也算是第一次把刚学的知识这么快地应用到实际上。</p><p>还有一件事，向大家推荐一个公众号：码农翻身。</p><p>公众号的作者“刘大”创作的内容，非常有意思。都是用漫画的形式给大家科普各种知识，尤其是关于计算机底层的，非常风趣幽默。</p><p>同时在这里对刘大献上我的敬意，之前在公众号里咨询刘大，刘大也回答了我一些问题，让我对于自己后面学习的路程更加坚定。</p><p>20已过，21继续加油，keep fighting！</p><p>最后送给大家我的一句座右铭：</p><ul><li>Better to run than curse the road</li><li>与其感慨路难行，不如马上出发</li></ul><p>​                                                                                                            —- Javen，2021年1月11日</p>]]></content>
    
    
    <categories>
      
      <category>个人总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2020</tag>
      
      <tag>个人总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>折腾Linux - 2.Shell的进程</title>
    <link href="/2020/11/27/%E6%8A%98%E8%85%BELinux%20-%202.Shell%E7%9A%84%E8%BF%9B%E7%A8%8B/"/>
    <url>/2020/11/27/%E6%8A%98%E8%85%BELinux%20-%202.Shell%E7%9A%84%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="承接上文"><a href="#承接上文" class="headerlink" title="承接上文"></a>承接上文</h1><p>上一篇中，我们实现了内网穿透，这样我们就可以直接使用SSH连接到内网的服务器。</p><p>一旦可以用SSH连接进入设备，我们就可以掌控设备了（当然还需要root的密码）。</p><p>但是我们关闭了终端之后，连接似乎就断了。这是怎么回事呢？</p><p>本篇博客将深入到Linux，分析问题，最终解决这个问题。</p><h1 id="为什么关闭终端，frp也会自动关闭？"><a href="#为什么关闭终端，frp也会自动关闭？" class="headerlink" title="为什么关闭终端，frp也会自动关闭？"></a>为什么关闭终端，frp也会自动关闭？</h1><p>首先我们要先了解一下shell</p><h2 id="something-easy-about-shell"><a href="#something-easy-about-shell" class="headerlink" title="something easy about shell"></a>something easy about shell</h2><p>shell是什么？</p><p>shell可以理解为是一个夹在用户与操作系统之间的程序，我们在shell中输入指定的指令，点击回车后，shell会对我们输入的指令进行解释（interpret）执行，并与操作系统进行交互。</p><p>所以shell的行为可以拆解为三大部分：</p><ul><li>读取输入命令</li><li>解析命令</li><li>执行命令，并将结果输出</li></ul><p>同时shell中的指令分为了两大类：</p><ul><li>shell自身的 builtin 指令，即shell自身支持的指令，例如：cd、ls等</li><li>shell自身无法解析的指令，这一类多数都是用户自己编写的程序</li></ul><hr><p>我们知道，在操作系统中，运行一个程序，都是需要单独开启一个进程（Process），来供程序运行。</p><p>在Unix上只有两种启动进程的方法。 第一个（几乎用不到）是被初始化。 当Linux计算机启动时，将加载其内核。 加载并初始化后，内核仅启动一个进程，称为Init。 此过程将在计算机打开的整个时间范围内运行，并负责加载计算机需要使用的其余过程。</p><p>也就是说，shell再神奇，也是在process上运行的。</p><p>由于大多数程序不是Init，因此仅留下一种实用的方法来启动进程：fork（）系统调用。 调用此函数时，操作系统将复制该过程并启动它们的运行。 原始进程称为“父进程”，新进程称为“子进程”。 fork（）向子进程返回0，并将其子进程的ID（PID）返回给父进程。 从本质上讲，这意味着新流程的唯一方法就是开始现有流程的复制。</p><p>对于shell自身的 builtin 指令，shell 都会在其自身的主线程中，进行执行的操作。</p><p>而对于非shell本身自带的指令，在linux中，其会使用系统提供的 fork 接口，来创建一个子进程，然后在子进程中运行该指令。</p><p>并且在子进程中运行指令时，主线程，也就是shell所在的进程，会等待子进程的执行结果。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201127213109.png"></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="shell中的-“-amp-”-指令"><a href="#shell中的-“-amp-”-指令" class="headerlink" title="shell中的 “&amp;” 指令"></a>shell中的 “&amp;” 指令</h2><p>先做一个实验，在shell中，我们进入到之前frp的文件夹，输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./frps -c ./frps.ini<br></code></pre></td></tr></table></figure><p>按回车之后，程序开始运行，但此时我们发现，shell 中会输出 frps 程序的日志。</p><p>同时，此时我们的 shell 无法进行其他操作，无法输入下一条指令，只是等待这 frps 程序输出。</p><p>如果此时我们想要执行别的命令，要么就终止 frps 程序，要么就重开一个 shell 程序。</p><p>这就和我们上面说的，主线程会等待子线程执行完毕，但是 frps 程序简单来说，是一直在一个循环里等待连接，所以除非启动失败或者手动关闭，否则这个 shell 就只会一直输出 frps 程序执行的日志。</p><p>此时我们键盘输入 ctrl + c，将程序终止。</p><p>然后输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./frps -c ./frps.ini &amp;<br></code></pre></td></tr></table></figure><p>点击回车，运行。</p><p>此时我们发现，我们的 shell 竟然还可以继续输入命令并且运行。</p><p>这正好证实了我们的说法，程序运行在子进程中，同时 shell 的主进程并没有等待子进程程序运行完毕。</p><p>这样不就实现了让 frps 程序在后台运行的效果了嘛。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201128101914.png"></p><p>上图的终端里，下面开启了我们的程序（作为示范），上面使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef | grep frps<br></code></pre></td></tr></table></figure><p>指令，可以看到后台（也就是子进程）是在运行着 frps 的，而且下面的终端主线程并没有等待该终端子线程程序运行结束。</p><h2 id="但是。。。"><a href="#但是。。。" class="headerlink" title="但是。。。"></a>但是。。。</h2><p>但是 &amp; 指令，只是将程序放在了shell的子进程中运行，那如果shell主进程关闭了，子进程会怎么样呢？</p><p>此时我们将下方的终端关闭。并在上面的终端里继续输入 ps -ef | grep frps 指令，会发现：</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201128102422.png"></p><p>程序被关闭了，也就是说子进程也关闭了。</p><p>难道想要内网穿透，还得必须打开一个终端？</p><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p>nohup（全称应该是 “no hangup”）这个指令，可以让运行的程序忽略 HUP 信号。</p><p>那么何为HUP信号呢？每当与当前程序运行所在的进程相关的shell关闭时，也就是shell的主进程关闭时，会向子进程发送该信号，使其正在运行的程序关闭。</p><p>如果使用了nohup指令，则会使当前的程序忽略掉 HUP 信号，也就是你的shell关闭后，其仍然可以继续运行，同时将输出信息，输出到当前目录下的 nohup.out。我们可以在nohup.out里查看程序运行的日志。</p><p>OK，那我们再来实验：</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201128103518.png"></p><p>这次我们使用了nohup指令。然后我们关闭掉下方的shell，也就是启动 frps 程序的主线程。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201128103615.png"></p><p>可以看到，我们将下方的shell关闭后，frps 程序仍然在运行中，我们可以通过 ps 指令与万能的 grep 指令找到他。</p><p>这样我们也就不用把终端一直挂着，而是随用随关闭。内网穿透就像暗地里的守护者一样，不在我们的视野范围内活动，但是没有他，我们就无法从自己的内网访问我们的服务器了。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>本文从进程的角度，以frps为例，说明了linux中关于shell进程的问题。</p><p>当然作者也是linux入门没多久的新人，如果文章中有什么错误，请联系作者，一起讨论。</p><p>另外作者还想多一句嘴，查询这些资料时，国内的论坛指令参差不齐，只有一篇linux中国的文字像个样子，而且还是完全翻译linux.com上的文章，有能力的同学，还是用谷歌，并且用英文搜索，尤其是可以避开某个C字开头的论坛，文章质量太差了。</p><p>linux本身就是因为开源免费而吸引了那么多技术人员、hacker们来维护、开发的，而某些博主<strong>偷窃、转载</strong>别人的linux技术文章，还设置需要钱才可以看。其中对比不免让人感到可笑而无奈。</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="https://linuxhint.com/how_to_use_nohup_linux/">https://linuxhint.com/how_to_use_nohup_linux/</a></li><li><a href="https://superuser.com/questions/152688/why-run-a-linux-shell-command-with">https://superuser.com/questions/152688/why-run-a-linux-shell-command-with</a></li><li><a href="https://brennan.io/2015/01/16/write-a-shell-in-c/%EF%BC%88%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90%E8%AF%BB%E8%80%85%E4%BB%AC%E7%9C%8B%E7%9C%8B%EF%BC%8C%E9%80%A0%E9%80%A0%E8%BD%AE%E5%AD%90%EF%BC%8C%E8%87%AA%E7%84%B6%E5%B0%B1%E4%BC%9A%E5%AF%B9%E8%BD%AE%E5%AD%90%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E6%9C%89%E4%B8%80%E5%AE%9A%E7%9A%84%E8%AE%A4%E7%9F%A5%EF%BC%89">https://brennan.io/2015/01/16/write-a-shell-in-c/（强烈推荐读者们看看，造造轮子，自然就会对轮子的内部结构有一定的认知）</a></li><li><a href="https://www.jb51.net/article/186059.htm">https://www.jb51.net/article/186059.htm</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>运维</tag>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>折腾Linux - 1.内网穿透</title>
    <link href="/2020/11/16/%E6%8A%98%E8%85%BELinux%20-%201.%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <url>/2020/11/16/%E6%8A%98%E8%85%BELinux%20-%201.%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文只是记录自己在学习和做项目过程中，折腾的一些东西，并非专业，本人也是linux入门的小白，因为任务驱动，而产生了兴趣，遂开始整活。</p><p>而且将其记录下来，以后忘记怎么弄了，还可以找出来回顾温习一下。</p><p>如有错误或者我理解不深的地方，希望看管们指出来 ：D</p><p>本小白今年9月也开始了烟酒生（雾）的生活，确实烟酒生和自己想象中的有些出入，有好也有坏。但我们实验室里竟然让我发现了个宝贝，那就是实验室的服务器。不过这个服务器的初衷是用来给学长们跑深度学习的，不过除了要毕业的学长，一般也很少有人用。</p><p>这么好的资源竟然没人用？！那不行，那我得整点活。刚开始的时候，基本上完全不太懂linux，也在慢慢看“字典书”（就是那种指令大全类型的，并未涉及到linux内核原理这些的书）。</p><p>以前自己搞了个阿里云服务器，用xshell整过一些东西，比如最基础的搭建个博客啊，部属个项目啊啥的。然后我试图用xshell徒手连实验室的服务器。</p><p>结果那必然是失败啊，根本ping不通啊。拍查了半天，原来我的电脑是连接的校园网，而实验室的服务器（下面简称服务器）在另外一个网络内，这怎么可能访问嘛。</p><p>查了很多资料，发现有两种种解决方法，分别是路由器端口映射和内网穿透。这就是本篇博客的内容了。</p><h1 id="为什么两个内网下的设备无法连通？"><a href="#为什么两个内网下的设备无法连通？" class="headerlink" title="为什么两个内网下的设备无法连通？"></a>为什么两个内网下的设备无法连通？</h1><p>解答这个问题，需要了解网络模型、公网内网</p><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201116165352.png"></p><p>OSI 七层网络模型由国际标准化组织进行制定，它是正统意义上的国际标准。但其实现过于复杂，且制定周期过长，在其整套标准推出之前，TCP/IP 模型已经在全球范围内被广泛使用，所以 TCP/IP 模型才是事实上的国际标准。TCP/IP 模型定义了应用层、传输层、网际层、网络接口层这四层网络结构，但并没有给出网络接口层的具体内容，因此在学习和开发中，通常将网络接口层替换为 OSI 七层模型中的数据链路层和物理层来进行理解。</p><p><strong>网络接口层</strong>的知识就比较偏向底层硬件。我们平常的做的应用，基本上是在<strong>网际层IP</strong>以及<strong>传输层</strong>的基础上，进行连接，同时在应用层进行各种应用。</p><h2 id="公网与内网"><a href="#公网与内网" class="headerlink" title="公网与内网"></a>公网与内网</h2><ol><li>公有IP地址</li></ol><p>一般称公网中的<strong>IP地址</strong>为公有地址。公有地址由Inter NIC（因特网信息中心）负责，这些<strong>IP地址</strong>分配给<strong>注册</strong>并向Inter NIC提出申请的组织机构。公有地址是全球唯一的，公网中不可能存在两个相同的<strong>IP地址</strong>。</p><p><strong>范围</strong>：除了私有地址以外的地址，都属于公有地址</p><ol start="2"><li>私有IP地址</li></ol><p>一般称内网（即局域网）中的<strong>IP地址</strong>为私有地址。私有地址是<strong>非注册地址</strong>，用于组织机构内部使用。私有地址的范围如下：</p><ul><li>A类IP地址中：10.0.0.0–10.255.255.255</li><li>B类IP地址中：172.16.0.0–172.31.255.255</li><li>C类IP地址中：192.168.0.0–192.168.255.255</li></ul><p>私有地址与公有地址不同，并不是由<strong>Internet</strong>分配的，是不允许出现在<strong>Internet</strong>中的，我们在公网中是看不到<strong>私有IP地址</strong>的，并且公有地址也不会使用上述的三类地址。所以，私有地址是不能直接与<strong>Internet</strong>连接的。</p><p>而如果想用私有地址与Internet连接来访问公网，那该怎么做？这就需要将<strong>私有IP地址</strong>转换成<strong>公网IP地址</strong>，与外部连接。所以，我们平时使用的路由器中会装有一个叫做 <strong>NAT（网络地址转换）</strong> 的软件，我们的路由器中会至少会有一个有效的<strong>公网IP</strong>，<strong>NAT</strong>会将我们的<strong>私有地址</strong>转成路由器中的<strong>公网IP</strong>与外部Internet连接。而同样的，因为使用的是路由器中的<strong>公共的公网IP</strong>来连接Internet，所以这个内网中的PC在Internet中显示的都是路由器的<strong>公共IP</strong>，这样做不仅提供了一定程度的安全，也可以有效的减缓可用的IP地址空间的枯竭问题。</p><p>比较典型的例子就是，我们学校的校园网，就是一个很大的内网，我们在内网中连接wifi，并上网，实际上仍然通过的是 <strong>NAT（网络地址转换）</strong>转换为公网IP来建立连接。</p><h2 id="解决疑惑"><a href="#解决疑惑" class="headerlink" title="解决疑惑"></a>解决疑惑</h2><p>两个设备之间建立连接，相互传送数据，数据会被由多个协议进行封装，即 应用层 - 传输层 - 网络层 - 网络接口层。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201116172011.png"></p><p>我们的设备是连接了路由器的，路由器下的所有设备都连接在该路由器的子网下，简言之，我们的设备都躲在路由器后。</p><p>我们访问一个网站，或建立一个连接，最终都是以路由器的IP发送出去。</p><p>但因为我们的设备A是主动访问一个公网服务器，路由器在建立连接后，是可以根据我们主动的访问时，网络协议中的信息，而将公网服务器发回来的信息，正确地发送给我们的设备A。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201116184031.png"></p><p>可是如果另外一个设备B，想要主动地来访问我们的设备A，这个时候，设备B访问的是路由器的IP。而路由器其实也不明白，设备B到底是想和内网下哪一个设备进行连接，因为内网下的设备对外暴露出来的，都是路由器的IP。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/image-20201116184203613.png"></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="1-路由器端口映射"><a href="#1-路由器端口映射" class="headerlink" title="1.路由器端口映射"></a>1.路由器端口映射</h2><p>路由器端口映射，原理就是指定路由器的一个固定端口（比如6000），使所有访问路由器IP（121.40.XXX.XXX:6000）的数据或信息，都转发到指定设备A的指定端口（例如22端口，用于SSH）。</p><p>那么最终的效果就是我直接访问 121.40.XXX.XXX:6000，路由器知道是转发给设备A的22端口，那我就可以访问到内网中，设备A的22端口了。</p><p>但是设备A除了我设置好的22端口，其他端口仍然还是无法访问，如果想要访问另一个端口，需要在路由器的端口映射中加入响应的映射配置即可。</p><p>可惜的是，我们实验室服务器网络连接的路由器，我不知道管理密码 ：( 。这种方案只能舍弃</p><h2 id="2-内网穿透"><a href="#2-内网穿透" class="headerlink" title="2.内网穿透"></a>2.内网穿透</h2><p>搜索了一些关于内网穿透的工具，比如花生壳、frp以及很多专门做内网穿透的软件，最后发现，除了frp，其他基本上都是收费，就算有免费的，也基本上是半残废。</p><p>但是frp唯一一个要求就是你需要有个自己的云服务器，并且云服务器有公网IP。</p><p>这不，我正好有个阿里云学生机，虽然学生机啥都不行，但它便宜啊！而且还带公网IP，要什么自行车？！</p><p>frp的具体原理图如下：</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201117170928.png"></p><p>下面就开始我们的配置</p><h3 id="2-1-frp服务端安装配置"><a href="#2-1-frp服务端安装配置" class="headerlink" title="2.1 frp服务端安装配置"></a>2.1 frp服务端安装配置</h3><p>这里服务端，就是我们的阿里云服务器，使其作为frp的server端，接收client的连接</p><p>首先我们在终端依次输入下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 获取github上frp打包好的release包</span><br>wget https://github.com/fatedier/frp/releases/download/v0.22.0/frp_0.22.0_linux_amd64.tar.gz<br><span class="hljs-meta">#</span><span class="bash"> 解压下载的.tar.gz压缩文件</span><br>tar -zxvf frp_0.22.0_linux_amd64.tar.gz <br></code></pre></td></tr></table></figure><p>这里注意一点，由于服务器使用的是centos，因此一定要选的linux，其次amd64代表了设备的架构，一般都是amd64。如果选择错误的平台类型，自然下载下来的文件是无法运行的。</p><p>解压之后的文件目录如下图</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201117172039.png"></p><p>其中 frpc_remote_ftp.ini 以及 nohup.out 是后续加进来的，如果解压后目录里没有是正常的。</p><p>此时，我们输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim frps.ini<br><span class="hljs-meta">#</span><span class="bash"> 如果提示没有权限，则在命令前加上 sudo ，并输入root的密码即可</span><br><span class="hljs-meta">#</span><span class="bash"> 例如：sudo vim frps.ini</span><br></code></pre></td></tr></table></figure><p>其初始化配置文件：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><br><span class="hljs-attr">bind_port</span> = <span class="hljs-number">7000</span><br></code></pre></td></tr></table></figure><p>bind_port 代表了 frps 作为 server 监听的是 7000 端口，这个设置可以自定义。</p><p>然后我们在非插入模式下输入 :wq ，并点击回车退出vim。（具体vim的操作，自行百度。当然如果为了省事，可以使用 gedit 指令来打开文件）</p><p>此时，我们在当前 frp 文件的目录下输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./frps -c ./frps.ini<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201117172600.png"></p><p>如果命令行出现上述输出，则表示启动成功，接下来就是内网设备启动 frpc 连接到 frps</p><h3 id="2-2-frp客户端配置"><a href="#2-2-frp客户端配置" class="headerlink" title="2.2 frp客户端配置"></a>2.2 frp客户端配置</h3><p>在我们的内网设备中，仍然需要下载 frp。下载以及解压的方式同 [2.1frp服务器端配置](#2.1 frp服务端安装配置) 一样。</p><p>解压后，进入目录，因为内网设备是作为 client ，连接到 server，因此我们启动的是 frpc。</p><p>接下来我们配置 frpc.ini，命令行中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim frpc.ini<br><span class="hljs-meta">#</span><span class="bash"> 如果提示没有权限，则在命令前加上 sudo ，并输入root的密码即可</span><br></code></pre></td></tr></table></figure><p>其初始化配置文件：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><br><span class="hljs-comment"># 此处需要修改为公网设备的IP</span><br><span class="hljs-attr">server_addr</span> = <span class="hljs-number">121</span>.XXX.XXX.XXX<br><span class="hljs-comment"># 注意此处的server_port需要与服务器端配置中的bind_port相同</span><br><span class="hljs-attr">server_port</span> = <span class="hljs-number">7000</span><br><br><span class="hljs-section">[ssh]</span><br><span class="hljs-attr">type</span> = tcp<br><span class="hljs-attr">local_ip</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-attr">local_port</span> = <span class="hljs-number">22</span><br><span class="hljs-comment"># 此处配置的端口就是后续用ssh访问时，预设的端口</span><br><span class="hljs-attr">remote_port</span> = <span class="hljs-number">6000</span><br></code></pre></td></tr></table></figure><p>修改完毕并退出后，我们在命令行中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./frpc -c ./frpc.ini<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201117173924.png"></p><p>如果没有黄色报错，那么久启动成功了</p><h3 id="2-3连接测试"><a href="#2-3连接测试" class="headerlink" title="2.3连接测试"></a>2.3连接测试</h3><p>此时我们打开自己电脑的 xshell，创建一个新的连接：</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201118143303.png"></p><p>其中 “名称” 可以随便填，“主机” 填的就是我们公网IP设备的IP地址（例如 121.XXX.XXX.XXX），端口号一定要与frp客户端配置中的 remote_port 相同。</p><p>配置好之后，点击确定，然后连接即可。</p><p>当然这一步作者只简单描述了步骤，关于具体xshell的操作，可以自行谷歌。</p><p>至此，我们的frp内网穿透就完成了。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>我们完成了内网穿透，可以通过转发，来访问到内网服务器的22端口，以此建立起ssh连接。</p><p>但是仍然有些许问题：</p><ol><li>我们运行 frpc 或者 frps 程序后，此时终端会等待 frpc 与 frps 程序运行完毕，才可以运行其他指令。那为了保证连接，难道必须一直打开终端吗？</li><li>每次关机之后，frpc 与 frps 就会关闭。对于公网IP设备，本来就是云服务器，一直开着还没啥问题。但是内网设备有时是需要重启的，那怎么才能让 frp 程序随开机自启动呢？</li></ol><p>上面两个问题也是我之前的疑问，不过后来查询各种资料与博客，才解决掉，总的来说算是处理的比较不错，基本上只要内网设备开着机，我就能连上。</p><p>具体的做法，由于篇幅限制，就不在这篇博客里赘述了，下一篇博客会写关于这方面的内容。</p><p>当然由于人之初，性本懒 （  : P  ），更新还是随缘。</p><p>最后还是感谢读者看完这篇文章，谢谢支持</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="https://juejin.im/post/6844904049800642568">https://juejin.im/post/6844904049800642568</a></li><li><a href="https://www.jianshu.com/p/ad7cd1d5be45">https://www.jianshu.com/p/ad7cd1d5be45</a></li><li><a href="https://juejin.im/post/6844903766701899784">https://juejin.im/post/6844903766701899784</a></li><li><a href="https://sspai.com/post/52523">https://sspai.com/post/52523</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>运维</tag>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 笔记 - 16 垃圾回收相关概念</title>
    <link href="/2020/08/29/JVM%20-%2016.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <url>/2020/08/29/JVM%20-%2016.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc() 的理解"></a>System.gc() 的理解</h1><ul><li> 在默认情况下，通过 System.gc() 或者 Runtime.getRuntime().gc() 的调用，<strong>会显式触发Full GC</strong>，同时对老年嗲和新生代进行回收，尝试释放被丢弃对象占用的内存</li><li>然而 System.gc() 调用附带一个免责申明，无法保证对垃圾收集器的调用</li><li>JVM实现者可以通过 System.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无需手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用 System.gc()</li></ul><h1 id="内存溢出（OOM）"><a href="#内存溢出（OOM）" class="headerlink" title="内存溢出（OOM）"></a>内存溢出（OOM）</h1><ul><li>内存溢出相对于内存泄露来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一</li><li>由于GC一直在发展，所以一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况</li><li>大多数情况下，GC会进行各种年龄段的垃圾回收，知道最后会Full GC，这时候会回收大量内存，供应用程序继续使用</li><li>javadoc中对于OutOfMemoryError的解释是，<strong>没有空闲内存，并且垃圾收集器也无法提供贡多内存</strong></li></ul><h2 id="没有空闲内存的情况"><a href="#没有空闲内存的情况" class="headerlink" title="没有空闲内存的情况"></a>没有空闲内存的情况</h2><p>Java虚拟机的堆内存不够，原因有二：</p><ol><li><p>Java虚拟机的堆内存设置不够</p><p>比如：可能存在内存泄露问题；也很有可能是堆的大小不合理，比如我们要处理比较客观的数据量，但是没有显示指定JVM堆大小或者指定数值偏小。我们可以通过 -Xms 和 -Xmx 来设置</p></li><li><p>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</p><p>对于老版本的Oracle JDK，因为用接待的大小是有限的，并且JVM对于永久代垃圾回收（如：常量池回收、卸载不再需要的类）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError非常多见，尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间， 也会导致OOM问题。对应的异常信息会标记出来和永久代相关：</p><p><strong>“java.lang.OutOfMemoryError: PermGen space”</strong></p><p>随着元空间的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，信息变成了：</p><p><strong>“java.lang.OutOfMemoryError: Metaspace”</strong></p></li></ol><p>这里面隐含着一层意思是，在抛出OutOfMemoryError之前，通常垃圾收集器会被处罚，尽其所能去清除出空间</p><ul><li>例如：在引用机制分析中，涉及到JVM回去尝试回收<strong>软引用指向的对象</strong>等</li><li>在java.nio.BIts.reservememory()中，我们能清楚的看到，System.gc()会被调用，以清除空间</li></ul><p>当然，也不是任何情况下垃圾收集器都会被触发的</p><ul><li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutOfMemoryError</li></ul><h1 id="内存泄漏（Memory-Leak）"><a href="#内存泄漏（Memory-Leak）" class="headerlink" title="内存泄漏（Memory Leak）"></a>内存泄漏（Memory Leak）</h1><p>也称为“存储渗漏”。<strong>严格来说，只有对象不在呗程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏</strong></p><p>但实际情况下很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做<strong>宽泛意义上的“内存泄露”</strong></p><p>尽管内存泄露并不会立即引起程序崩溃，但是一旦发生内存泄露，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutOfMemory异常，导致程序崩溃</p><p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200831163504.png"></p><h1 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h1><p>Stop-the-World，简称STW，指的是GC时间发生过程中，<strong>会产生应用程序的停顿。停顿产生时整个应用程序线程会被暂停，没有任何响应</strong>，有点像卡死的感觉，这个停顿称为STW</p><p>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿</p><ul><li>分析工作必须在一个能确保一致性的快照中进行</li><li>一致性指整个分析期间整个执行系统看起来像是被冻结在某个时间点上</li><li><strong>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</strong></li></ul><p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是卡顿造成，所以需要减少STW的发生</p><ul><li>STW和采用哪款GC无关，所有的GC都有这个事件</li><li>哪怕是G1也不能完全避免STW情况下在，只能说垃圾回收器越来越优秀，收集效率越来越高，尽可能地缩短了暂停时间</li><li>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉</li><li>开发中不要用System.gc()，会导致STW的发生</li></ul><h1 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h1><h2 id="并发（Concurrent）"><a href="#并发（Concurrent）" class="headerlink" title="并发（Concurrent）"></a>并发（Concurrent）</h2><ul><li>在操作系统各种，是指一个时间段中有几个程序都除以以启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行</li><li>并发并不是真正意义上的“同时执行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间内来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时进行</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200831171808.png"></p><h2 id="并行（Parallel）"><a href="#并行（Parallel）" class="headerlink" title="并行（Parallel）"></a>并行（Parallel）</h2><ul><li>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称为并行</li><li>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行</li><li>适合科学计算，后台处理等弱交互场景</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200831172407.png"></p><h2 id="垃圾回收的并行和并发"><a href="#垃圾回收的并行和并发" class="headerlink" title="垃圾回收的并行和并发"></a>垃圾回收的并行和并发</h2><p>并发与并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p><ul><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程任处于等待状态，如ParNew、Parallel Scavenge、Parallel Old</li><li>串行（Serial）：相较于并行的概念，单线程执行。如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收，回收完在启动程序的线程</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200831173635.png"></p><ul><li>并发（Concurrent）：值用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行<ul><li>用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上</li><li>如：CMS、G1</li></ul></li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200831174317.png"></p><h1 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h1><h2 id="安全点（Safe-Point）"><a href="#安全点（Safe-Point）" class="headerlink" title="安全点（Safe Point）"></a>安全点（Safe Point）</h2><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点”</p><p>Safe Point的选择很重要，<strong>如果太少可能导致GC等待时间太长，如果太频繁可能导致运行时的性能问题</strong>。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。</p><p>比如：<strong>选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等</strong></p><hr><p>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p><ul><li><p>抢先式中断：（目前没有虚拟机采用了）</p><p>首先中断所有线程，如果还有线程不在安全点，就恢复线程，让线程跑到安全点</p></li><li><p>主动式中断：</p><p>设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起</p></li></ul><h2 id="安全区域（Safe-Region）"><a href="#安全区域（Safe-Region）" class="headerlink" title="安全区域（Safe Region）"></a>安全区域（Safe Region）</h2><p>Safe Point机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safe Point。</p><p><strong>但是程序“不执行”的时候？</strong>例如线程处于Sleep状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决</p><p><strong>安全区域是指一段代码中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的</strong>。我们吧Safe Region看作是被扩展了的Safe Point</p><hr><p>实际执行时：</p><ol><li>当线程运行到Safe Region的代码时，首先表示已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略表示为Safe Region状态的线程；</li><li>当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止</li></ol><h1 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h1><p>我们希望能描述这样一类对象：当内存空间还不够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象</p><p>在JDK1.2版本之后，Java对于引用的概念进行了扩充，将引用分为了强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Week Reference）和虚引用（Phantom Reference）4中，这4中引用强度一次逐渐减弱</p><p>除了强引用之外，其他三种引用均可以在java.lang.ref包中找到</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200901173040.png"></p><p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用</p><ul><li><strong>强引用（Strong Reference）：</strong>最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似 “Object object = new Object()” 这种引用关系。<strong>无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象</strong></li><li><strong>软引用（Soft Reference）：</strong>在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果回收后还没有足够的内存，才会抛出内存溢出异常（即，内存不足就回收）</li><li><strong>弱引用（Week Reference）：</strong>被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象</li><li><strong>虚引用（Phantom Reference）：</strong>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时，收到一个系统通知</li></ul><h2 id="强引用（Strong-Reference）——-不回收"><a href="#强引用（Strong-Reference）——-不回收" class="headerlink" title="强引用（Strong Reference）——  不回收"></a>强引用（Strong Reference）——  不回收</h2><p>在Java程序中，最常见的引用类型就是强引用（<strong>普通系统99%以上都是强引用</strong>），也就是我们最常见的普通对象引用，<strong>也是默认的引用类型</strong></p><p>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为一个指向该对象的强引用。</p><p><strong>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象</strong></p><p>对于普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应引用赋值为null，就是可以当做垃圾被收集了，当然具体回收机制还是要看垃圾收集策略</p><p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及、虚可触及的，在一定条件下，都是可以被回收的。所以<strong>强引用是造成Java内存泄露的主要原因</strong></p><h2 id="软引用（Soft-Reference）——-内存不足即回收"><a href="#软引用（Soft-Reference）——-内存不足即回收" class="headerlink" title="软引用（Soft Reference）——  内存不足即回收"></a>软引用（Soft Reference）——  内存不足即回收</h2><p>软引用是用来描述一些还有用，但是非必须的对象。<strong>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收</strong>，如果这次回收还没有足够的内存，才会抛出内存溢出异常</p><p>软引用通常用来实现内存敏感的缓存。比如：<strong>高速缓存</strong>就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）</p><p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理</p><h2 id="弱引用（Week-Reference）——-发现即回收"><a href="#弱引用（Week-Reference）——-发现即回收" class="headerlink" title="弱引用（Week Reference）——  发现即回收"></a>弱引用（Week Reference）——  发现即回收</h2><p>弱引用也是用来描述那些非必须对象，<strong>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止</strong>。在系统GC时，只要发现弱引用，不管系统堆空间是否充足，都会回收掉只被弱引用关联的对象</p><p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，<strong>弱引用对象可以存在较长的时间</strong></p><p>弱引用和软引用一样，在构造弱引用时，也可以制定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况</p><p><strong>软引用、弱引用都非常适合来保存那些可有可无的缓存数据</strong>。如果这么做，当系统内存不足时，这些花奴才能数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用</p><h2 id="虚引用（Phantom-Reference）——-对象回收跟踪"><a href="#虚引用（Phantom-Reference）——-对象回收跟踪" class="headerlink" title="虚引用（Phantom Reference）——  对象回收跟踪"></a>虚引用（Phantom Reference）——  对象回收跟踪</h2><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个</p><p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时可能被垃圾回收器回收</p><p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法获取对象时，总是null</p><p><strong>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知</strong></p><h2 id="终结器引用（Final-Reference）"><a href="#终结器引用（Final-Reference）" class="headerlink" title="终结器引用（Final Reference）"></a>终结器引用（Final Reference）</h2><ul><li>它用于实现对象的finalize()方法，也可以成为终结器引用</li><li>无需动手编码，其内部配合引用队列使用</li><li>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize()方法，第二次GC时才能回首被引用对象</li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 笔记 - 15 垃圾回收相关算法</title>
    <link href="/2020/08/24/JVM%20-%2015.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"/>
    <url>/2020/08/24/JVM%20-%2015.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="标记阶段：引用计数算法"><a href="#标记阶段：引用计数算法" class="headerlink" title="标记阶段：引用计数算法"></a>标记阶段：引用计数算法</h1><h2 id="垃圾标记阶段：对象存活判断"><a href="#垃圾标记阶段：对象存活判断" class="headerlink" title="垃圾标记阶段：对象存活判断"></a>垃圾标记阶段：对象存活判断</h2><ul><li>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先<strong>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象</strong>。只有被标记为已经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为<strong>垃圾标记阶段</strong></li><li>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡</li><li>判断对象存活一般有两种方法：<strong>引用计数法</strong> 和 <strong>可达性分析算法</strong></li></ul><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><ul><li>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的<strong>引用计数器属性，用于记录对象被引用的情况</strong></li><li>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收</li><li><strong>优点</strong>：实现简单，垃圾对象便于识别，判定效率高，回收没有延迟性</li><li><strong>缺点</strong>：<ul><li>它需要单独的字段存储计数器，这样的做法增加了存储空间的开销</li><li>每次幅值都需要重新更新计数器，伴随着加法与减法操作，增加了时间的开销</li><li>引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法</li></ul></li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200824163626.png" alt="循环引用"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>引用计数算法，是很多语言的资源回收选择，例如Python，它同时支持引用计数和垃圾收集机制</li><li>具体哪种最优是看具体场景，有些大规模的实践中仅保留技术机制，以提高吞吐量</li><li>Java并没有选择引用计数，是因为其无法解决循环引用</li></ul><h1 id="标记阶段：可达性分析算法"><a href="#标记阶段：可达性分析算法" class="headerlink" title="标记阶段：可达性分析算法"></a>标记阶段：可达性分析算法</h1><h2 id="可达性分析（或跟搜索算法、跟踪性垃圾收集）"><a href="#可达性分析（或跟搜索算法、跟踪性垃圾收集）" class="headerlink" title="可达性分析（或跟搜索算法、跟踪性垃圾收集）"></a>可达性分析（或跟搜索算法、跟踪性垃圾收集）</h2><ul><li>相对于引用计数算法而言，可行性分析算法不仅永阳具备实现简单和执行高效等特点，更重要的是该算法可以有效地<strong>解决引用计数算法中循环引用的问题，放置内存泄露的发生</strong></li><li>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常叫做<strong>追踪性垃圾收集（Tracing Garbage Collection）</strong></li></ul><hr><ul><li>所谓“GC Roots”根集合就是一组必须活跃的引用</li><li>基本思路：<ul><li>可达性分析算法是以根对象集合（GC Roots）为起始点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达</strong></li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接地连接着，搜索过的路径成为<strong>引用链</strong>（Reference Chain）</li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象</li><li>在可达性分析算法中，只有能够被根对象集合直接或间接链接的对象才是存活对象</li></ul></li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200824170230.png" alt="可达性分析算法"></p><h2 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h2><p>在Java语言中，GC Roots包括以下几类元素：</p><ul><li>虚拟机栈中引用的对象，比如：各个线程被调用的方法中时用到的参数、局部变量等</li><li>本地方法栈内JNI（通常说的本地方法）引用的对象</li><li>方法区中类静态属性引用的对象，比如：Java类的引用类型静态变量</li><li>方法区中常量引用的对象，比如：字符串常量池（String Table）里的引用</li><li>所有被同步锁synchronized持有的对象</li><li>Java虚拟机内部的引用，比如基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统累计加载器等</li><li>反应Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200824172028.png"></p><ul><li>除了这些固定的GC Roots集合以外，根据用户选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（Partial GC）</li><li>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这店不满足的话，分析结果的准确性就无法保证</li><li>这单也是导致GC进行时必须 <strong>“Stop The World”</strong> 的一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，<strong>枚举根节点时也是必须要停顿的</strong></li></ul><h1 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>Java语言提供了对象终止（finalization）机制来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong></li><li>当垃圾收集器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个 对象的finalize()方法</li><li>finalize()方法允许在子类中重写，<strong>用于在对象被回收时进行资源释放</strong>。通常这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等</li><li>永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点：<ul><li>在finalize()时可能会导致对象复活</li><li>finalize()方法的执行时间是没有保障的，它完全有GC线程决定，极端情况下，若不发生GC，则finalize()没有执行的机会</li><li>一个糟糕的finalize()会严重的影响GC的性能</li></ul></li><li>由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态</li><li>如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了。一般来说，此对象需要被回收。但事实上， 也并非是“非死不可”的，这时候它们暂时处于“缓刑”的阶段。<strong>一个无法触及的对象有可能在某一个条件下“复活自己”</strong>，如果这样，那么对于它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态，如下：<ul><li><strong>可触及的：</strong>从根节点开始，可以到达这个对象</li><li><strong>可复活的：</strong>对象的所有引用都被释放，但是独享有可能在finalize()中复活</li><li><strong>不可触及的：</strong>对象的finalize()被嗲用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，<strong>因为finalize()只会被调用一次</strong></li></ul></li><li>以上三种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收</li></ul><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><p>判断一个对象objA是否可回收，至少姚经理两次标记过程：</p><ol><li>如果对象objA到 GC Roots 没有引用链，则进行第一次标记</li><li>如果筛选，判断此对象是否有必要执行finalize()方法<ol><li>如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的</li><li>如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，有一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行</li><li><strong>finalize()方法是对象脱逃死亡的最后机会</strong>，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后对象再次出现没有引用存在的情况。在这种情况下，finalize()方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize()方法只会被调用一次</li></ol></li></ol><h1 id="清除阶段：标记-清除（Mark-Sweep）算法"><a href="#清除阶段：标记-清除（Mark-Sweep）算法" class="headerlink" title="清除阶段：标记 - 清除（Mark - Sweep）算法"></a>清除阶段：标记 - 清除（Mark - Sweep）算法</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>标记-清除算法是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并应用于lisp语言</p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>当堆中的有效内存空间被耗尽的时候，就会停止整个程序（stop the world），然后进行两项工作，第一项是标记，第二项则是清楚</p><ul><li>标记：Collector从引用的根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象</li><li>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200828151731.png"></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>效率不太高</li><li>在进行GC时，需要停止整个程序，导致用户体验差</li><li>这种方式清理出来的空闲内存是不连续的，产生内存碎片。需要维护一个空闲列表</li></ul><h2 id="注意：何为清除？"><a href="#注意：何为清除？" class="headerlink" title="注意：何为清除？"></a>注意：何为清除？</h2><ul><li>这里所谓的清除并不是真的置空，而是把需要清楚地对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够用，如果够，则存放</li></ul><h1 id="清除阶段：幅值算法"><a href="#清除阶段：幅值算法" class="headerlink" title="清除阶段：幅值算法"></a>清除阶段：幅值算法</h1><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage”。其在论文中描述的算法被人们称为幅值（Copying）算法</p><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存角色，最后完成垃圾回收</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200828153302.png"></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>幅值过去以后保证空间的连续性，不会出现“碎片”问题</li></ul><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><ul><li>此算法的缺点也很明显，就是需要两倍的内存空间</li><li>对于G1这种分拆成为大连region的GC，幅值而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li><li>除非系统中的垃圾对象非常多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在新生代，对常规应用的垃圾回收，一次通常可以回收70~99%的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代</p><h1 id="清楚阶段：标记-压缩（或标记-整理、Mark-Compact）算法"><a href="#清楚阶段：标记-压缩（或标记-整理、Mark-Compact）算法" class="headerlink" title="清楚阶段：标记 - 压缩（或标记-整理、Mark - Compact）算法"></a>清楚阶段：标记 - 压缩（或标记-整理、Mark - Compact）算法</h1><h2 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h2><p>幅值算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，<strong>基于老年垃圾回收的特性，需要使用其他的算法</strong></p><p>标记-清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后哈辉产生内存碎片，所以JVM的设计者需要在此基础上进行修改。标记-压缩算法由此诞生</p><h2 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h2><ul><li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用的对象</li><li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放</li><li>之后清除边界外的所有空间</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200828155104.png"></p><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><ul><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可</li><li>消除了复制算法中，内存减半的高额代价</li></ul><h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><ul><li>从效率上来说，标记-整理算法是要低于复制算法的</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li><li>移动过程中，需要全称暂停用户应用程序，即STW</li></ul><h1 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h1><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200828161433.png"></p><p>效率上来说，复制算法是比较不错的，但是却浪费了太多的内存</p><p>为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说跟平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段</p><h1 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h1><p>Q：难道就没有一种最好的算法吗？</p><p>A：无，没有最好的算法，只有最合适的算法</p><hr><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生</p><p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，<strong>不同生命周期的对象可以采取不同的收集方式，以便提高收集效率</strong>。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p><p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如<strong>Http请求中的Seesion对象、线程、Socket链接</strong>，这类对象跟语无直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，，这些对象生命周期会比较短，比如：<strong>String对象</strong>，由于其不可变得特性，系统会产生大量的这些对象，有些对象甚至只使用一次即可回收</p><hr><p>目前几乎所有的GC都是采用分代收集（Generational Collecting）算法执行垃圾回收的</p><p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点</p><ul><li>年轻代：<ul><li>特点：区域相对老年代较小，对象生命周期短，存活率低，回收频繁</li><li>这种情况复制算法的回收整理，速度是最快的。复制算法的效率之和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过HotSpot中的两个Survivor区的设计得到缓解</li></ul></li><li>老年代：<ul><li>特点：区域较大，对象生命周期较长，存活率高，回收不及年轻代频繁</li><li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现<ul><li>Mark阶段的开销与存活对象的数量成正比</li><li>Sweep阶段的开销与所管理区域的大小成正比</li><li>Compact阶段的开销与存活对象的数据成正比</li></ul></li></ul></li></ul><hr><p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施；当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理</p><p>分代思想被现有的虚拟机刚放使用。几乎所有的垃圾回收器都区分新生代和老年代</p><h1 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h1><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在<strong>Stop the World</strong>状态下，应用程序所以的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，<strong>将严重影响用户体验或者系统的稳定性</strong>。为了解决这个问题，即对实时垃圾收集算法的研究直接导致增量收集（Incremental Collecting）算法的诞生</p><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，<strong>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成</strong></p><p>总的来说，增量收集算法的基础仍然是传统的标记-清除和复制算法。增量收集算法通过<strong>对线程冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</strong></p><h2 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h2><p>使用这种方法，由于在垃圾回收过程中，间接性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，<strong>造成系统吞吐量的下降</strong></p><h1 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h1><p>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间也越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理的回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿</p><p>分代算法将按照对象的生命周期长短划分为两个部分，分区算法将整个堆空间划分成连续的不同小区间</p><p>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 笔记 - 14 垃圾回收概述</title>
    <link href="/2020/08/22/JVM%20-%2014.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/08/22/JVM%20-%2014.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200822102843.png"></p><ul><li>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生</li><li>关于垃圾收集有三个经典问题：<ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul></li><li>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为了现代语言的标配，即使经过了如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战。</li></ul><h1 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h1><ul><li>什么是垃圾（Garbage）？<ul><li>垃圾是指在运行程序汇总没有任何指针指向的对象，这个对象就是需要被回收的垃圾</li><li>外文：An object is considered garbage when it can no longer be reached from any pointer in the running program.</li></ul></li><li>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出</li></ul><h1 id="为什么需要GC"><a href="#为什么需要GC" class="headerlink" title="为什么需要GC"></a>为什么需要GC</h1><ul><li>对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都要被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样</li><li>除了释放没用的对象，垃圾回收也可以清楚内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一段，以便JVM将整理出来的内存分配给新的对象</li><li>随着应用程序所应付的业务越来越庞大，复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化</li></ul><h1 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h1><ul><li><p>在早起的C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">MibBridge *pBridge = <span class="hljs-keyword">new</span> <span class="hljs-built_in">cmBaseGroupBridge</span>();<br><span class="hljs-keyword">if</span>(pBridge-&gt;<span class="hljs-built_in">Register</span>(kDestroy) != NO_ERROR)<br>    <span class="hljs-keyword">delete</span> pBridge;<br></code></pre></td></tr></table></figure></li><li><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，知道出现内存溢出并造成应用程序崩溃</p></li><li><p>现在，除了Java以外，C#、Python、Ruby等语言都是用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式已经成为现代开发语言必备的标准</p></li></ul><h1 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h1><ul><li>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险<ul><li>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让人头疼</li></ul></li><li>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</li></ul><hr><p>担忧：</p><ul><li>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就是<strong>弱化了Java开发人员在程序出现内存溢出时，定位问题和解决问题的能力</strong></li><li>此时，了解JVM的自动内存分配和内存回收勋就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutOfMemoryError时，快速地根据错误异常日志定位问题和解决问题</li><li>当需要排查各种内存溢出、内存泄露问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术<strong>实施必要的监控和调节</strong></li></ul><hr><ul><li>垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收，其中Java堆是垃圾收集器的工作重点</li><li>从次数上讲<ul><li>频繁收集Young区</li><li>较少收集Old区</li><li>基本不动Perm区（或元空间）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用PY查找固定代码所在的文件</title>
    <link href="/2020/08/19/%E7%94%A8PY%E6%9F%A5%E6%89%BE%E5%9B%BA%E5%AE%9A%E4%BB%A3%E7%A0%81%E6%89%80%E5%9C%A8%E7%9A%84%E6%96%87%E4%BB%B6/"/>
    <url>/2020/08/19/%E7%94%A8PY%E6%9F%A5%E6%89%BE%E5%9B%BA%E5%AE%9A%E4%BB%A3%E7%A0%81%E6%89%80%E5%9C%A8%E7%9A%84%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h1><p>今天给我们项目组的某一个项目集成友盟+的统计。由于该项目之前集成过firebase，然后因为一些原因，firebase被弃用了，相关sdk都删掉了，原来的统计事件都给注释掉了（还好我当时机制，没有删掉，而是给注释上了，否则这次相当于重新找统计的点，更麻烦）。</p><p>由于C#文件巨多，一个一个找那怕是要累死我。突然我一想，之前自己学过一点爬虫，写了几个小demo，尤其是正则表达式让我印象深刻。所以我就在想，可不可以用正则，来找出有之前注释掉的代码。</p><h1 id="具体逻辑"><a href="#具体逻辑" class="headerlink" title="具体逻辑"></a>具体逻辑</h1><p>在写这段代码之前，我思考了一下，可能后续会有文件夹，所以在这段代码里我用了递归，如果检测到当前路径是文件夹，则会对当前路径再次调用该方法。</p><p>如果是.cs文件，则读取代码内容，让后通过正则表达式匹配，如果匹配上了，则打印当前文件名。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> re<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span>(<span class="hljs-params">path, pattern</span>):</span><br>    files = os.listdir(path)<br>    <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files:<br>        filepath = path+<span class="hljs-string">&#x27;\\&#x27;</span>+file<br>        <span class="hljs-keyword">if</span> os.path.isdir(filepath):<br>            find(filepath, pattern)<br>        <span class="hljs-keyword">elif</span> file.endswith(<span class="hljs-string">&quot;.cs&quot;</span>):<br>            content = <span class="hljs-built_in">open</span>(filepath, mode=<span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>).read()<br>            items = re.findall(pattern, content)<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(items):<br>                <span class="hljs-built_in">print</span>(file)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 此处是需要寻找的目标代码</span><br>    pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;XXXXXXXX&#x27;</span>)<br>    <br>    <span class="hljs-comment"># 此处path是需要寻找的文件夹</span><br>    find(path=<span class="hljs-string">r&#x27;XXXXXXXXXXXX&#x27;</span>, pattern=pattern)<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有的时候，有些较为机械且重复的活，其实是可以借助工具来做，人来做费时又费力，效率不高。</p><p>之前在训练测试脚本的时候，也用到了python来写文件转换，比起认为来做，确实方便了不少。</p><p>平时在工作学习中，还是要善于用这种思维来考虑事情，对于重复度高的事情，可以借助脚本，增加效率。</p>]]></content>
    
    
    <categories>
      
      <category>脚本工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>脚本工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 笔记 - 13 StringTable</title>
    <link href="/2020/08/15/JVM%20-%2013.StringTable/"/>
    <url>/2020/08/15/JVM%20-%2013.StringTable/</url>
    
    <content type="html"><![CDATA[<h1 id="String的基本特性"><a href="#String的基本特性" class="headerlink" title="String的基本特性"></a>String的基本特性</h1><ul><li>String：字符串，使用一对””引起来表示</li><li>String声明为final的，不可被继承</li><li>String实现了Serializable接口：表示字符串是支持序列化的；也实现了Comparable接口：表示String可以比较大小</li><li>String在 jdk8 及以前内部定义了 final char[ ] value 用于存储字符串数据，jdk9 时改为了 byte[ ]</li><li>String的 String Pool 是一个固定大小的Hashtable，默认值大小长度为1009.如果放进 String Pool 的String很多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降</li><li>使用-XX:StringTableSize可设置StringTable的长度</li><li>在jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快</li><li>在jdk7中，StringTable的长度默认值是60013,1009是可设置的最小值</li></ul><h1 id="String的内存分配"><a href="#String的内存分配" class="headerlink" title="String的内存分配"></a>String的内存分配</h1><ul><li>在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</li><li>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的换成常量池比较特殊。它主要使用方法有两种<ul><li>直接使用双引号生命出来的String对象会直接存储在常量池中。比如：String info = “abc”</li><li>如果不是用双引号声明的String对象，可以使用String提供的intern()方法</li></ul></li><li>Java 6以前，字符串常量池存放在永久代中</li><li>Java 7对字符串的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内<ul><li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以在调优应用时，仅需调整堆大小即可</li><li>字符串常量池概念原本使用的比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String.intern()</li></ul></li><li>Java 8中字符串常量在堆中</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200817160832.png"></p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200817160856.png"></p><p><strong>为什么StringTable要调整？</strong></p><ol><li>permSize默认比较小</li><li>永久代垃圾回收频率低</li></ol><h1 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h1><ol><li>常量与常量的拼接结果在常量池，原理是<strong>编译器优化</strong></li><li>常量池中不会存在相同内容的常量</li><li>只要其中有一个是变量，结果就在堆中。<strong>拼接变量的原理是StringBuilder</strong></li><li>如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符创对象放入池中，并返回此对象的地址</li></ol><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200817170054.png"></p><ol><li>字符串拼接操作不一定使用的是StringBuilder，如果拼接符号左右两百年都是字符串变量或常量引用，则仍然使用编译器优化，即非StringBuilder的方式</li><li>针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能用final尽量使用final</li></ol><h1 id="intern-的使用"><a href="#intern-的使用" class="headerlink" title="intern()的使用"></a>intern()的使用</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>如果不是双引号声明的String对象，可以使用String提供的intern方法；intern方法会从字符串常量池中查询当年字符串是否存在，若不存在就会将当前字符串放入常量池中。</p><ul><li>比如：String myInfo = new String(“abc”).intern();</li></ul><p>也就是说，如果在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此下列表达式的值必定是true：</p><ul><li>(“a” + “b” + “c”).intern() == “abc”</li></ul><p>通俗点讲，Interned String 就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p><hr><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>Q：new String(“ab”)会创建几个对象？</strong></p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200818205305.png"></p><p><strong>A：</strong>2个，一个是”ab”字符串常量，放在常量池中，另一个是new出来的String对象实例</p><h1 id="StringTable的垃圾回收"><a href="#StringTable的垃圾回收" class="headerlink" title="StringTable的垃圾回收"></a>StringTable的垃圾回收</h1><p>-XX:+PrintStringTableStatistics，用来查看字符串信息</p><h1 id="G1中的String去重操作"><a href="#G1中的String去重操作" class="headerlink" title="G1中的String去重操作"></a>G1中的String去重操作</h1><ul><li><p>背景：许多Java应用做的测试得出以下结果：</p><ul><li>堆存活数据集合里面String对象占了25%</li><li>堆存活数据集合里面重复的String对象有13.5%</li><li>String对象的平均长度是45</li></ul></li><li><p>许多大规模的Java应用的瓶颈在于内存，测试表明在这些类型的应用里面，Java堆中存活的数据集合差不多25%是String对象。更进一步，这里面差不多一半String对象都是重复的，重复的意思是说：</p><p>string1.equals(string2) = true</p><p>堆上存在重复的String对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复String对象进行去重，这样就能避免浪费内存</p></li><li><p>实现：</p><ul><li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象</li><li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重他引用的String对象</li><li>使用hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组</li><li>如果存在，String对象会被调整引用那个数组，释放对原来的引用，最终会被垃圾收集器回收掉</li><li>如果查找失败，char数组会被插入到hashtable，这样以后就可以共享这个数组</li></ul></li><li><p>命令行选项：</p><ul><li>UseStringDeduplication (bool)：开启String去重，默认是不开启的，需要手动开启</li><li>PrintStringDeduplicationStatistics (bool)：打印详细的去重统计信息</li><li>StringDeduplicationAgeThreshold (uintx)：设置被认为是去重候选对象的年龄门槛</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 笔记 - 12 执行引擎</title>
    <link href="/2020/08/12/JVM%20-%2012.%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <url>/2020/08/12/JVM%20-%2012.%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="执行引擎概述"><a href="#执行引擎概述" class="headerlink" title="执行引擎概述"></a>执行引擎概述</h1><ul><li>执行引擎是Java虚拟机核心的组成部分之一</li><li>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的。<strong>而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地指定指令集和执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式</strong></li><li>JVM的主要任务是负责<strong>装载字节码到其内部</strong>，但字节码并不能直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息</li><li>那么想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是<strong>将字节码指令解释/编译为对应平台上的本地机器指令才可以</strong>。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200813104449.png"></p><ol><li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器</li><li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址</li><li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息</li></ol><h1 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h1><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下图的各个步骤：</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200813104904.png"></p><p>Java代码编译是由Java源码编译器来完成，流程图如下：</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200813105243.png"></p><hr><p><strong>问题：什么是解释器（interpreter），什么是JIT编译器？</strong></p><ul><li>解释器：当Java虚拟机启动时，会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行</li><li>JIT（Just In Time Compiler）编译器：虚拟机将源代码直接编译成和本地机器平台相关的机器语言</li></ul><h1 id="机器码、指令、汇编语言"><a href="#机器码、指令、汇编语言" class="headerlink" title="机器码、指令、汇编语言"></a>机器码、指令、汇编语言</h1><h2 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h2><ul><li>各种用二进制编码方式表示的指令，叫做机器指令码。最开始，人们就用它编写程序，这就是机器语言</li><li>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出错</li><li>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快</li><li>机器指令和CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同</li></ul><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ul><li>由于机器码是由0和1组成的二进制序列，可读性太差，于是人们发明了指令</li><li>指令就是把机器码汇总特定的0和1序列，简化成对应的指令（一般为英文缩写，如mov，inc等），可读性稍好</li><li>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一指令（比如mov），对应的机器码也可能不同</li></ul><h2 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h2><ul><li>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集</li></ul><h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><ul><li>由于指令的可读性还是太差，于是人们又发明了汇编语言</li><li>在汇编语言中，用<strong>助记符（Mnemonics）代替机器指令的操作码</strong>，用<strong>地址符号（Symbol）或标号（Label）</strong>代替指令或操作数的地址</li><li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200813112354.png"></p><h1 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h1><p>JVM设计者们的初衷仅仅只是单纯地为了<strong>满足Java程序实现跨平台特性</strong>，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法</p><ul><li>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机械指令执行</li><li>当一条字节码指令被解释执行完成后，根据PC寄存器中记录的下一条需要被执行的字节码指令操作解释操作</li></ul><hr><p>现状：</p><ul><li>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，<strong>基于解释器执行已经沦落为抵消的代名词</strong>，并且时常被一些C/C++程序员所调侃</li><li>为了解决这个问题，JVM平台支持一种叫做即时编译的技术。即时编译的目的是避免函数被解释执行，而是<strong>将整个函数体译成为机器码，每次函数执行时，只执行编译后的机器码即可</strong>，种方式可以使执行效率大幅度提升</li><li>不过无论何时，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献</li></ul><h1 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h1><h2 id="既然JIT编译器速度很快，那为什么HotSpot仍然还包含解释器呢？"><a href="#既然JIT编译器速度很快，那为什么HotSpot仍然还包含解释器呢？" class="headerlink" title="既然JIT编译器速度很快，那为什么HotSpot仍然还包含解释器呢？"></a>既然JIT编译器速度很快，那为什么HotSpot仍然还包含解释器呢？</h2><p>首先明确：</p><p>当程序启动后，解释器可以马上发挥作用，省去编译时间，立即执行</p><p>而编译器想要发挥作用，把代码编译为本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高</p><p>所以当Java虚拟机启动时，计时器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去很多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码变异成本地代码，获得更高的执行效率</p><p>同时，解释执行在编译器进行激进优化不成立时，作为编译器的“逃生门”</p><h2 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h2><ul><li>Java语言的“编译期”其实是一段“不确定”的操作过程，它可能是是指一个<strong>前端编译器</strong>，把.java文件转化为.class文件的过程</li><li>也可能是<strong>后端运行期编译器</strong>（JIT编译器），把字节码转化成机器码</li><li>害可能是<strong>静态提前编译器</strong>（AOT编译器，Ahead Of Time Compiler）直接把.java文件编译成本地机器代码</li></ul><h2 id="热点代码即探测方式"><a href="#热点代码即探测方式" class="headerlink" title="热点代码即探测方式"></a>热点代码即探测方式</h2><ul><li><strong>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”</strong>，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，简称为OSR（On Stack Replacement）编译</li><li>一个方法究竟要被嗲用多少次，或者一个循环体究竟要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，这里主要依靠热点探测技术</li><li>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测</li><li>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建议2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）<ul><li>方法调用计数器用于统计方法的调用次数</li><li>回边计数器则用于统计循环体执行的循环次数</li></ul></li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200813163312.png"></p><h2 id="HotSpot-VM可以设置程序执行方式"><a href="#HotSpot-VM可以设置程序执行方式" class="headerlink" title="HotSpot VM可以设置程序执行方式"></a>HotSpot VM可以设置程序执行方式</h2><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是<strong>完全采用计时器</strong>执行，还是<strong>完全采用即时编译器</strong>执行，如下：</p><ul><li>-Xint：完全采用解释器模式执行程序</li><li>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li><li>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序</li></ul><h2 id="HotSpot-VM中JIT分类"><a href="#HotSpot-VM中JIT分类" class="headerlink" title="HotSpot VM中JIT分类"></a>HotSpot VM中JIT分类</h2><p>在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器和C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到达地使用哪一种即时编译器，如下：</p><ul><li>-client：指定Java虚拟机运行在Client模式，并使用C1编译器；C1编译器会对字节码<strong>进行简单和可靠的优化，耗时短</strong>。以达到更快的编译速度</li><li>-server：指定Java虚拟机运行在Server模式，并使用C2编译器；C2编译器进行<strong>耗时较长的优化，以及激进优化</strong>。但优化的代码执行效率更高</li></ul><h2 id="C1和C2编译器不同的优化策略"><a href="#C1和C2编译器不同的优化策略" class="headerlink" title="C1和C2编译器不同的优化策略"></a>C1和C2编译器不同的优化策略</h2><ul><li>不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化，冗余消除<ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少战争的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现类进行内敛</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul></li><li>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上右如下几种优化：<ul><li>标量替换：用标量值代替聚合对象的属性值</li><li>栈上分配：对于未逃逸的对象分配在栈上而不是堆上</li><li>同步消除：清除同步操作，通常是synchronized</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 笔记 - 11 直接内存</title>
    <link href="/2020/08/12/JVM%20-%2011.%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/"/>
    <url>/2020/08/12/JVM%20-%2011.%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="直接内存概述"><a href="#直接内存概述" class="headerlink" title="直接内存概述"></a>直接内存概述</h1><ul><li>直接内存不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域</li><li>直接内存是在Java堆外的、直接向系统申请的内存空间</li><li>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</li><li>通常，访问直接内存的速度会优于Java堆。即读写性能高<ul><li>因此处于性能考虑， 读写频繁地场合可能会考虑使用直接内存</li><li>Java的NIO库允许Java程序直接使用直接内存，用于数据缓冲区</li></ul></li></ul><p>非直接缓冲区：</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200812103850.png"></p><p>直接缓冲区：</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200812104014.png"></p><ul><li>当然直接内存也会导致OutOfMemory异常</li><li>由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和仍然受限于操作系统能给出的最大内存</li><li>缺点：<ul><li>分配回收成本较高</li><li>不收JVM内存回收管理</li></ul></li><li>直接内存大小可以通过MaxDirectMemorySize设置</li><li>如果不指定，默认与堆的最大值-Xmx参数一致</li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 笔记 - 10 对象的实例化内存布局与访问定位</title>
    <link href="/2020/08/10/JVM%20-%2010.%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/"/>
    <url>/2020/08/10/JVM%20-%2010.%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h1><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200810095052.png" alt="对象实例化"></p><p>过程：</p><ol><li>加载类元信息</li><li>为对象分配内存</li><li>处理并发问题</li><li>属性的默认初始化（零值初始化）</li><li>设置对象头的信息</li><li>属性的显式初始化、代码块中初始化、构造器中初始化</li></ol><h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200810202502.png"></p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200810203942.png"></p><h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200810204632.png"></p><ul><li><p>句柄访问</p><p><img src="https://upload.cc/i1/2020/05/23/FnTVys.png" alt="句柄访问"></p></li><li><p>指针访问（HotSpot采用）</p><p><img src="https://upload.cc/i1/2020/05/23/yMAOhs.png" alt="直接指针访问"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 笔记 - 9 方法区</title>
    <link href="/2020/08/03/JVM%20-%209.%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
    <url>/2020/08/03/JVM%20-%209.%E6%96%B9%E6%B3%95%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h1><h2 id="1-运行时数据区结构图"><a href="#1-运行时数据区结构图" class="headerlink" title="1. 运行时数据区结构图"></a>1. 运行时数据区结构图</h2><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200803170016.png"></p><h2 id="2-栈、堆、方法区的关系"><a href="#2-栈、堆、方法区的关系" class="headerlink" title="2. 栈、堆、方法区的关系"></a>2. 栈、堆、方法区的关系</h2><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200803170335.png"></p><h1 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h1><h2 id="1-方法区在哪里？"><a href="#1-方法区在哪里？" class="headerlink" title="1. 方法区在哪里？"></a>1. 方法区在哪里？</h2><p>《Java虚拟机规范》中明确说明：“尽管所以的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩”，但对于HotSpot JVM而言，方法区还有一个别名叫做Non-Heap，目的就是为了和堆分开。</p><p>所以方法区看做是一块独立于Java堆的内存空间。</p><h2 id="2-基本理解"><a href="#2-基本理解" class="headerlink" title="2. 基本理解"></a>2. 基本理解</h2><ul><li>方法区（Method Area）和Java堆一样，是各个线程共享的内存区域</li><li>方法区在JVM启动的时候被创建，并且它的实际武理内存空间中和Java堆区一样都可以是不连续的</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多类，导致方法区溢出，虚拟机同样会抛出：java.lang.OutOfMemoryError: Metaspace</li><li>关闭JVM就会释放这个区域的内存</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200803174517.png"></p><h1 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h1><h2 id="1-设置方法区内存的大小"><a href="#1-设置方法区内存的大小" class="headerlink" title="1. 设置方法区内存的大小"></a>1. 设置方法区内存的大小</h2><ul><li>方法区的大小不必是固定的，jvm可以根据应用的需要动态调整</li><li>jdk7及以前：<ul><li>通过-XX:PermSize来设置永久代初始分配空间。默认值是20.75M</li><li>通过-XX:MaxPermSize来设置永久代最大可分配空间。32位机器默认是64M，64位机器默认是82M</li><li>当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError:PermGenspace</li></ul></li><li>jdk8及以后：<ul><li>元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定，替换上述原有的两个参数</li><li>默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制</li><li>与永久代不同，如果不指定大小，默认情况下，虚拟机会好近所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</li><li>对于一个64位的服务器端JVM来说，其默认的-XX:MetaspaceSize值为21MB，这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置</li><li>新的高水位线的值取决于GC后释放了多少元空间。如果释放的内存不足，那么在不超过MaxMetaspaceSize的情况下，适当提高该值。如果释放空间过多，则适当降低该值</li></ul></li></ul><h2 id="2-如何结局OOM"><a href="#2-如何结局OOM" class="headerlink" title="2. 如何结局OOM"></a>2. 如何结局OOM</h2><ol><li>要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是先分清楚到底是出现了内存泄露（Memory Leak）还是内存溢出（Memory Overflow）</li><li>如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾回收器无法自动回收他们的。掌握了泄露对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄露代码的位置</li><li>如果不存在内存泄露，换句话说就是内存中的对象却是都还必须存活着，那就应当检查虚拟机的堆参数，与机器武理内存对比看是否可以调大，从代码检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期间的内存消耗</li></ol><h1 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h1><h2 id="1-方法区存储什么？"><a href="#1-方法区存储什么？" class="headerlink" title="1. 方法区存储什么？"></a>1. 方法区存储什么？</h2><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200804174820.png"></p><p>方法区用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等</p><h2 id="2-方法区内部结构"><a href="#2-方法区内部结构" class="headerlink" title="2. 方法区内部结构"></a>2. 方法区内部结构</h2><h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储一下类型信息：</p><ul><li>这个类型的完整有效名称（全名=包名.类名）</li><li>这个类型直接父类的完整有效类名（对于interface或是java.lang.object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ul><h3 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h3><ul><li>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</li><li>域的相关信息包括：域名称、域类型、域修饰符</li></ul><h3 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h3><p>JVM必须保存所有方法的以下信息，同域信息一样包括生命顺序：</p><ul><li>方法名称</li><li>方法的返回类型（或void）</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符</li><li>方法的字节码、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外）：包括了每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul><h3 id="non-final的类变量"><a href="#non-final的类变量" class="headerlink" title="non-final的类变量"></a>non-final的类变量</h3><ul><li>静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分</li><li>类变量被类的所有实例共享，即时没有类实例时也可以访问</li></ul><h2 id="3-运行时常量池-VS-常量池"><a href="#3-运行时常量池-VS-常量池" class="headerlink" title="3. 运行时常量池 VS 常量池"></a>3. 运行时常量池 VS 常量池</h2><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200805173907.png"></p><ul><li>方法区，内部包含了运行时常量池</li><li>字节码文件，内部包含了常量池</li><li>要弄清楚方法区，需要理解清楚ClassFile，因为家在类的信息都在方法区</li><li>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池</li></ul><h2 id="4-为什么需要常量池？"><a href="#4-为什么需要常量池？" class="headerlink" title="4. 为什么需要常量池？"></a>4. 为什么需要常量池？</h2><p>一个java源文件中的类、接口，编译后产生一个字节码文件。而java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存在常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池</p><h2 id="5-常量池中有什么？"><a href="#5-常量池中有什么？" class="headerlink" title="5. 常量池中有什么？"></a>5. 常量池中有什么？</h2><ul><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ul><h2 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6. 运行时常量池"></a>6. 运行时常量池</h2><ul><li>运行时常量池（Runtime Constant Pool）是方法区的一部分</li><li>常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号应用，这部分内容将在类加载后存放到方法区的运行时常量池中</li><li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池</li><li>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像是数组项一样，是通过索引访问的</li><li>运行时常量池中包含多种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址</li><li>运行时常量池类似于传统编程语言中的符号表（symbol table），但是它包含的数据却比符号表要更丰富一些</li><li>当创建类或接口的运行时常量时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛出OutOfMemoryError异常</li></ul><h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a>7. 小结</h2><p>常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</p><h1 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h1><ol><li><p>首先明确：只有HotSpot有永久代</p></li><li><p>HotSpot中方法区的变化：</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200806162557.png"></p></li></ol><h1 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h1><p>有些人认为方法区是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（例如JDK11中的ZGC就不支持类卸载）</p><p>一般来说<strong>这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻</strong>。但是这部分区域回收<strong>有时又确实是必要的</strong>。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄露</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型</p><h2 id="1-常量池中的两大类常量"><a href="#1-常量池中的两大类常量" class="headerlink" title="1. 常量池中的两大类常量"></a>1. 常量池中的两大类常量</h2><ul><li>常量池中的两大类常量：字面量和符号应用</li><li>字面量比较接近Java语言层次的常量概念，如文本字符串、被蛇您为final的常量值</li><li>符号应用则属于编译原理方面的概念</li><li>HotSpot虚拟机对常量池的回收策略是很明确地，只要常量池中的常量没有被任何地方引用，就可以被回收了</li><li>回收废弃常量与回收Java堆中的对象非常类似</li></ul><h2 id="2-垃圾收集"><a href="#2-垃圾收集" class="headerlink" title="2. 垃圾收集"></a>2. 垃圾收集</h2><ul><li>判断一个常量是否“废弃”还是相对简单的，而要判断一个类型是否属于“不在被使用的类”的条件就比较苛刻了。同时需要满足下面三个条件：<ol><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例</li><li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi的重加载等，否则通常是很难达成的</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问到该类的方法</li></ol></li><li>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并非和对象一样，没有引用了，就必然会被回收。</li><li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力</li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 笔记 - 8 堆</title>
    <link href="/2020/07/28/JVM%20-%208.%E5%A0%86/"/>
    <url>/2020/07/28/JVM%20-%208.%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="堆的核心概述"><a href="#堆的核心概述" class="headerlink" title="堆的核心概述"></a>堆的核心概述</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul><li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域</li><li>Java堆区在JVM启动的时候被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间，且大小是可以调节的</li><li>《Java虚拟机规范》规定，堆可以处于<strong>物理不连续</strong>的内存空间中，但在逻辑上它应该是被视为连续的</li><li>所有线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）</li><li>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上（<strong>“几乎”</strong>所有的对象实例都在这里分配，也就是说并不是全部）</li><li>数组和对象可能永远不会存储在栈上，因为栈帧中保存应用，这个应用指向对象或者数组在堆中的位置</li><li>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会别移除</li><li>堆，是GC执行垃圾回收的重点区域</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200728210153.png" alt="堆"></p><hr><h2 id="2-内存细分"><a href="#2-内存细分" class="headerlink" title="2. 内存细分"></a>2. 内存细分</h2><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200728210818.png"></p><hr><h2 id="3-堆内部结构"><a href="#3-堆内部结构" class="headerlink" title="3. 堆内部结构"></a>3. 堆内部结构</h2><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200728211631.png" alt="堆内部结构"></p><h1 id="设置堆内存大小与OOM"><a href="#设置堆内存大小与OOM" class="headerlink" title="设置堆内存大小与OOM"></a>设置堆内存大小与OOM</h1><h2 id="1-堆空间大小的设置"><a href="#1-堆空间大小的设置" class="headerlink" title="1. 堆空间大小的设置"></a>1. 堆空间大小的设置</h2><ul><li>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项 <strong>“-Xmx”</strong> 和 <strong>“-Xms”</strong> 来进行设置</li><li>“-Xms” 用于表示堆区的起始内存，等价于 -XX:InitialHeapSize</li><li>“-Xmx” 则用于表示堆区的最大内存，等价于 -XX:MaxHeapSize</li><li>一旦堆区中的内存大小超过 “-Xmx” 所指定的最大内存时，将会抛出 OutOfMemoryError 异常</li><li>通常会将 -Xms 和 -Xmx 设置为相同的值，目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区大小，一次提高性能</li><li>默认情况下，初始内存大小：物理电脑内存大小 / 64</li><li>最大内存大小： 物理电脑内存大小 / 4</li></ul><h2 id="2-OutOfMemory"><a href="#2-OutOfMemory" class="headerlink" title="2. OutOfMemory"></a>2. OutOfMemory</h2><h1 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h1><ul><li>存储在JVM中的Java对象可以被划分为两类<ul><li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li><li>另外一类对象的声明周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li></ul></li><li>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（OldGen）</li><li>其中年轻代又可划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫from区、to区）</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200729101709.png" alt="年轻代和老年代"></p><ul><li>在HotSpot中，Eden空间和另外两个Survivor空间缺省所占比例是8:1:1</li><li>当然开发人员可以通过 “-XX:SurvivorRatio” 来调整这个空间比例，例如-XX:SurvivorRatio=8</li><li>几乎所有的Java对象都是在Eden区被new出来的</li><li>绝大部分的Java对象的销毁都是在新生代进行的，即80%的对象“朝生夕死”</li></ul><h1 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配，在哪里分配等问题，而且由于内存分配算法和内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片</p><ol><li>new的对象先放在伊甸园区，此区有大小限制</li><li>当伊甸园的空间被填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不在被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li><li>然后伊甸园中的剩余对象转移到幸存者0区</li><li>如果再次出发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区</li><li>如果再精力垃圾回收，此时会重新放回幸存者0区，接着再取幸存者1区</li><li>什么时候可以去养老区呢？可以设置次数，默认是15次（-XX:MaxTenuringThreshold=<N>进行设置）</li><li>在养老区，相对悠闲。当养老区内存不足时，会触发GC：Major GC，进行养老区的内存清理</li><li>若养老区执行了Major GC之后发现仍然无法进行对象的保存，就会产生OOM异常</li></ol><h2 id="2-对象分配的特殊情况"><a href="#2-对象分配的特殊情况" class="headerlink" title="2. 对象分配的特殊情况"></a>2. 对象分配的特殊情况</h2><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200729110625.png" alt="特殊情况"></p><h1 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a>Minor GC、Major GC、Full GC</h1><h2 id="1-GC概述"><a href="#1-GC概述" class="headerlink" title="1. GC概述"></a>1. GC概述</h2><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收，大部分时候回收的都是指新生代</p><p>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）</p><ul><li>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：<ul><li>新生代收集（Minor GC / Young GC）：只是新生代的垃圾回收</li><li>老年代收集（Major GC / Old GC）：只是老年代的垃圾回收（目前只有CMS GC会有单独收集老年代的行为）</li><li>混合收集（Mixed GC）：收集很饿新生代以及部分老年代的垃圾收集（目前只有G1 GC会有这种行为）</li></ul></li><li>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾回收</li></ul><hr><h2 id="2-新生代GC（Minor-GC）触发机制"><a href="#2-新生代GC（Minor-GC）触发机制" class="headerlink" title="2. 新生代GC（Minor GC）触发机制"></a>2. 新生代GC（Minor GC）触发机制</h2><ul><li>当年轻代空间不足时，就会触发Minor GC，这里的年轻代区满是指Eden区满了，Survivor区满并不会引发GC，每次Minor GC会清理年轻代的内存</li><li>因为Java对象<strong>大多数都具备朝生夕灭</strong>的特性，所以Minor GC非常频繁，一般回收速度也比较快</li><li>Minor GC会引发STW，暂停其他用户的线程，等垃圾回收结束，用户线程才回复运行</li></ul><hr><h2 id="3-老年代GC（Major-GC-）触发机制："><a href="#3-老年代GC（Major-GC-）触发机制：" class="headerlink" title="3. 老年代GC（Major GC ）触发机制："></a>3. 老年代GC（Major GC ）触发机制：</h2><ul><li>指发生在老年代的GC，对象从老年代消失时，我们说”Major GC”或”Full GC”发生了</li><li>出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的手机策略里，就有直接进行Major GC的策略选择过程）</li><li>Major GC的速度一般会比Minor GC慢上10倍以上，STW的时间更长</li><li>如果Major GC后，内存还不足，就报OOM了</li></ul><hr><h2 id="4-Full-GC的触发机制"><a href="#4-Full-GC的触发机制" class="headerlink" title="4. Full GC的触发机制"></a>4. Full GC的触发机制</h2><ul><li>调用System.gc()时，系统建议执行Full GC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden取、Survivor0区向Survivor1区复制时，对象大小大于Survivor1区可用内存时，这把对象转存到老年代，且老年代的可用内存大小小于对象大小</li></ul><blockquote><p>Full GC是开发或者调优中尽量避免的</p></blockquote><h1 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h1><p>为什么需要把Java堆分代？不分代就不能正常工作了吗？</p><ul><li>经研究，不同对象的生命周期不同，70-99%的对象是临时对象</li><li>新生代：有Eden，两块大小相同的Survivor去构成</li><li>老年代：存放新生代精力多次GC仍然存活的对象</li><li>其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室里。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某个地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间来</li></ul><h1 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h1><p>如果对象在Eden出生，并经历过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将年龄设置为1。</p><p>对象在Survivor区中，每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁）时，就会被晋升到老年代区</p><p>对象晋升老年代的阈值，可以通过 -XX:MaxTenuringThreshold 来设置</p><hr><p>针对不同年龄段的对象分配原则如下所示：</p><ul><li>优先分配到Eden</li><li>大对象直接分配到老年代（尽量避免程序中出现过多的大对象）</li><li>长期存活的对象分配到老年代</li><li>动态对象年龄判断（如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一般，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到阈值）</li><li>空间分配担保：-XX:HandlePromotionFailure</li></ul><h1 id="为对象分配内存：TLAB"><a href="#为对象分配内存：TLAB" class="headerlink" title="为对象分配内存：TLAB"></a>为对象分配内存：TLAB</h1><h2 id="1-为什么要有TLAB（Thread-Local-Allocation-Buffer）？"><a href="#1-为什么要有TLAB（Thread-Local-Allocation-Buffer）？" class="headerlink" title="1. 为什么要有TLAB（Thread Local Allocation Buffer）？"></a>1. 为什么要有TLAB（Thread Local Allocation Buffer）？</h2><ul><li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为了避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li></ul><h2 id="2-什么是TLAB？"><a href="#2-什么是TLAB？" class="headerlink" title="2. 什么是TLAB？"></a>2. 什么是TLAB？</h2><ul><li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为<strong>每一个线程分配了一个私有缓冲区域</strong>，它包含在Eden空间内</li><li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong></li></ul><h2 id="3-说明"><a href="#3-说明" class="headerlink" title="3. 说明"></a>3. 说明</h2><ul><li>尽管不是所有的对象实例都能够在TLAB中成功分配，但是<strong>JVM确实是将TLAB作为内存分配的首选</strong></li><li>在程序中，开发人员可以通过选项 “-XX:UseTLAB” 设置是否开启TLAB空间</li><li>默认情况下，TLAB空间的内存非常小，**仅占有整个Eden空间的1%**，当然我们可以通过选项 “-XX:TLABWasteTargetPercent” 设置TLAB空间所占用Eden空间的百分比大小</li><li>一旦对象在TLAB空间分配内存失败，JVM就会尝试着通过<strong>使用加锁机制</strong>确保数据操作的原子性，从而直接在Eden空间中分配内存</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200730163429.png" alt="内存分配"></p><h1 id="小结：堆空间的参数设置"><a href="#小结：堆空间的参数设置" class="headerlink" title="小结：堆空间的参数设置"></a>小结：堆空间的参数设置</h1><p>官网说明：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200731155117.png"></p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200731155252.png"></p><p>在发生Minor GC之前，虚拟机会<strong>检查老年代最大可用的连续空间是否大于新生代所有对象的总空间</strong></p><p>如果大于，则此次Minor GC是安全的</p><p>如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允许担保失败</p><ul><li>如果HandlePromotionFailure=true，那么会继续<strong>检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小</strong><ul><li>如果大于，则尝试进行一次Minor GC，但这次GC仍然是有风险的</li><li>如果小于，则改为进行一次Full GC</li></ul></li><li>如果HandlePromotionFailure=false，则直接进行一次Ful GC</li></ul><p>在JDK6 Update24（或JDK7）之后的规则变成，<strong>只要老年代的连续空间大于新生代对象总大小</strong>，或者<strong>历次晋升的平均大小就会进行Minor GC</strong>，否则将进行Full GC</p><h1 id="堆是分配对象的唯一选择吗？"><a href="#堆是分配对象的唯一选择吗？" class="headerlink" title="堆是分配对象的唯一选择吗？"></a>堆是分配对象的唯一选择吗？</h1><h2 id="1-回答"><a href="#1-回答" class="headerlink" title="1. 回答"></a>1. 回答</h2><p>在《深入理解Java虚拟机》中，关于Java堆内存有这样一段描述：</p><blockquote><p>随着JIT编译的发展和<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换优化技术</strong>将会导致一些微妙的变化，所有的对象都分配到堆上变得不那么“绝对”了。</p></blockquote><p>在Java虚拟机中，对象是在Java堆内分配内存的，这是一个普遍的常识。但是，有一种特殊的情况，那就是<strong>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无须在堆上分配内存，也无需进行垃圾回收，这也是最常见的堆外存储技术。</p><p>此外，前面提到的基于OpenJDK深度定制的TaoBaoVM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap转移至heap外，并且GC不能管理GCIH内部的Java对象，一次达到降低GC的回收频率和提升GC的回收效率的目的</p><h2 id="2-逃逸分析"><a href="#2-逃逸分析" class="headerlink" title="2. 逃逸分析"></a>2. 逃逸分析</h2><ul><li>如何将堆上的对象分配到栈，需要使用逃逸分析手段</li><li>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法</li><li>通过逃逸分析，Java HotSpot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上</li><li>逃逸分析的基本行为就是分析对象动态作用域：<ul><li>当一个对象在方法中被定义后，对象旨在方法内部使用，则认为没有发生逃逸</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生了逃逸。例如作为调用参数传递到其他方法中去</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 笔记 - 7 本地方法栈</title>
    <link href="/2020/07/25/JVM%20-%207.%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/"/>
    <url>/2020/07/25/JVM%20-%207.%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><ul><li>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</li><li>本地方法栈，也是线程私有的</li><li>允许被是线程固定或者是可动态扩展的内存大小<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryErorr异常</li></ul></li><li>本地方法是使用C语言实现的</li><li>它的具体做法是Native Method Stack中登记native方法，在执行引擎执行时加载本地方法库</li></ul><hr><ul><li>当某个线程调用一个本地方法时，他就进入了一个全新的并且不再受虚拟机限制的世界。他和虚拟机拥有同样的权限<ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存</li></ul></li><li>并不是所有的JVM都支持本地方法，因为Java虚拟机规范中并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈</li><li>在HotSpot JVM中，直接将本地方法栈和虚拟机栈合二为一</li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 笔记 - 6 本地方法接口</title>
    <link href="/2020/07/25/JVM%20-%206.%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/"/>
    <url>/2020/07/25/JVM%20-%206.%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是本地方法"><a href="#什么是本地方法" class="headerlink" title="什么是本地方法"></a>什么是本地方法</h1><p>简单地讲，<strong>一个Native Method就是一个Java调用非Java代码的接口</strong>。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特性并非Java所特有，很多其他的变成语言都有这一机制，比如在C++中，你可以使用extern “C” 告知C++编译器去调用一个C的函数</p><h1 id="为什么要用Native-Method？"><a href="#为什么要用Native-Method？" class="headerlink" title="为什么要用Native Method？"></a>为什么要用Native Method？</h1><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了</p><ul><li><p>与Java环境外交互：</p><p>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想象Java需要和一些底层系统，如操作系统或某些硬件交流信息时的情况。本地方法正是这样一种交流机制：它为我们提供了非常简洁的接口，而且我们无需去了解Java应用之外的繁琐细节</p></li><li><p>与操作系统交互：</p><p>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的空间，它由一个解释器和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整地系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。<strong>通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些不分就是用C写的</strong></p></li><li><p>Sun’s Java</p><p>Sun的解释器使用C实现的，这使得它能像一些普通的C一样与外部进行交互</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 笔记 - 5 虚拟机栈</title>
    <link href="/2020/07/20/JVM%20-%205.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
    <url>/2020/07/20/JVM%20-%205.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟机栈概述"><a href="#虚拟机栈概述" class="headerlink" title="虚拟机栈概述"></a>虚拟机栈概述</h1><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。</p><p>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p><hr><p>栈是运行时的单位，而堆是存储的单位。</p><p>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。</p><h2 id="1-虚拟机栈基本内容"><a href="#1-虚拟机栈基本内容" class="headerlink" title="1. 虚拟机栈基本内容"></a>1. 虚拟机栈基本内容</h2><ul><li><p>Java虚拟机栈是什么？</p><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</p><p>虚拟机栈是线程私有的</p></li><li><p>生命周期</p><p>生命周期与线程一致。</p></li><li><p>作用</p><p>主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p></li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200720101835.png" alt="大概示意图"></p><ul><li><p>栈的优点：</p><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</p><p>JVM直接对Java栈的操作只有两个：每个方法执行，伴随着入栈；方法执行结束后，进行出栈</p><p>对于栈来说，不存在垃圾回收问题</p></li></ul><h2 id="2-设置虚拟机栈大小"><a href="#2-设置虚拟机栈大小" class="headerlink" title="2. 设置虚拟机栈大小"></a>2. 设置虚拟机栈大小</h2><p>例：-Xss256k</p><h1 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h1><h2 id="1-栈中存储什么？"><a href="#1-栈中存储什么？" class="headerlink" title="1. 栈中存储什么？"></a>1. 栈中存储什么？</h2><ul><li>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在</li><li>在这个线程中正在执行的每个方法都各自对应一个栈帧（Stack Frame）</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li></ul><h2 id="2-栈运行原理"><a href="#2-栈运行原理" class="headerlink" title="2. 栈运行原理"></a>2. 栈运行原理</h2><ul><li>JVM直接对Java栈的操作只有两个，就是对栈的<strong>“压栈”</strong>和<strong>“出栈”</strong>，遵循“先进后出“原则</li><li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<strong>当前栈帧</strong>（Current Frame），与当前栈帧相对应的方法就是<strong>当前方法</strong>（Current Method），定义这个方法的类就是<strong>当前类</strong>（Current Class）</li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li><li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前帧</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200720105414.png" alt="栈运行图"></p><ul><li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li><li>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出</li></ul><h2 id="3-栈帧的内部结构"><a href="#3-栈帧的内部结构" class="headerlink" title="3. 栈帧的内部结构"></a>3. 栈帧的内部结构</h2><p>每个栈帧中存储着：</p><ul><li><strong>局部变量表</strong>（Local Variables）</li><li><strong>操作数栈</strong>（Operand Stack）（或表达式栈）</li><li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><h1 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h1><h2 id="1-什么是局部变量表"><a href="#1-什么是局部变量表" class="headerlink" title="1. 什么是局部变量表"></a>1. 什么是局部变量表</h2><ul><li>局部变量表也被称之为<strong>局部变量数组</strong>或<strong>本地变量表</strong></li><li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括基本数据类型、对象引用（reference），以及returnAddress类型</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li><li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的 maximum local varibales 数据项中，在方法运行期间是不会改变局部变量表的大小的</li><li>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多</li><li><strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁</li></ul><h2 id="2-Slot"><a href="#2-Slot" class="headerlink" title="2. Slot"></a>2. Slot</h2><ul><li>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束</li><li>局部变量表最基本的存储单元是Slot（变量槽）</li><li>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量</li><li>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress乐行），64位的类型（long和double）占用两个slot</li><li>byte、short、char在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true</li></ul><hr><ul><li>JVM会为局部变量表汇总的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li><li>当一个实例方法被调用时，它的方法参数和方法体内部定义的局部变量将会按照顺序被幅值到局部变量表中的每一个slot上</li><li>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如long和double）</li><li>如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200720134405.png" alt="slot"></p><h2 id="3-静态变量与局部变量的对比"><a href="#3-静态变量与局部变量的对比" class="headerlink" title="3. 静态变量与局部变量的对比"></a>3. 静态变量与局部变量的对比</h2><ul><li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配</li><li>我们知道类变量表有两次初始化阶段，第一次是在“准备阶段“，执行系统初始化，对类变量设置零值，另一次是在”初始化“阶段，赋予程序员在代码中定义的初始值</li><li>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用</li></ul><h2 id="4-补充"><a href="#4-补充" class="headerlink" title="4. 补充"></a>4. 补充</h2><ul><li>栈帧中，与性能调优关系最密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用的局部变量表完成方法的传递</li><li><strong>局部变量表中的变量也是非常重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></li></ul><h1 id="操作数栈（operand-stack）"><a href="#操作数栈（operand-stack）" class="headerlink" title="操作数栈（operand stack）"></a>操作数栈（operand stack）</h1><ul><li>每一个独立的栈帧中除了包含局部变量表以外，还包含一个先进后出（first in last out）的操作数栈，也可以称之为表达式栈（Expression Stack）</li><li>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/ 出栈（pop）</li><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈，使用他们后在把结果压入栈，例如：执行复制、交换、求和等操作</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200722170326.png" alt="操作数栈出栈与入栈"></p><ul><li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong></li><li>操作数栈就是JVM执行引擎的一个工作区，当一个方法开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>这个方法的操作数栈是空的</strong></li><li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译器就定义好了，保存在方法的Code属性中，为max_stack的值</li><li>栈中的任何一个元素可以是Java的任意类型：32bit的类型占用一个栈单位深度，64bit的类型占用两个栈单位深度</li><li>操作数栈<strong>并非采用访问索引的方式来进行数据访问</strong>的，而是只能通过入栈和出栈操作来完成一次数据访问</li><li><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>，并更新PC寄存器中下一条需要执行的字节码指令</li><li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段再次验证</li><li>另外，Java虚拟机的<strong>解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈</li></ul><h1 id="栈顶缓存（Top-of-Stack-Cashing）技术"><a href="#栈顶缓存（Top-of-Stack-Cashing）技术" class="headerlink" title="栈顶缓存（Top-of-Stack-Cashing）技术"></a>栈顶缓存（Top-of-Stack-Cashing）技术</h1><ul><li>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着需要更多的指令分配（instruction dispatch）次数和内存读/写次数</li><li>由于操作数是存储在内存中的，因此频繁地执行内存读写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，一次降低对内存的读写次数，提升执行引擎的执行效率</strong></li></ul><h1 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h1><ul><li>每一个栈帧内部都包含一个<strong>指向运行时常量池中该栈帧所属方法的应用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令</li><li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号应用（Symbolic Reference）保存在class文件的常量池中。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号应用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转化为调用方法的直接引用</strong></li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200722191045.png" alt="动态链接"></p><h1 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h1><h3 id="1-解析与分派"><a href="#1-解析与分派" class="headerlink" title="1. 解析与分派"></a>1. 解析与分派</h3><p>在JVM中，将符号引用转化为调用方法的直接引用与方法的绑定机制相关</p><ul><li><p>静态链接：</p><p>当一个字节码文件被装载进JVM内部时，如果<strong>被调用的目标方法在编译期可知</strong>，且运行期保持不变，这种情况下将调用方法的符号引用转换为直接引用的过程，称之为静态链接</p></li><li><p>动态链接：</p><p>如果<strong>被调用的方法在编译期无法被确定下来</strong>，也就是说，只能够在程序运行期将调用方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接</p></li></ul><hr><p>对应的方法的绑定机制为：早起绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次</strong></p><ul><li><p>早期绑定：</p><p>早期绑定就是指被调用的目标方法如果<strong>在编译期间可知，且运行期保持不变时</strong>，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转化为直接引用</p></li><li><p>晚期绑定：</p><p><strong>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期间根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定</p></li></ul><blockquote><p>OOP语言一大特点是多态，如果要支持多态，那么就必须要具备早期绑定和晚期绑定两种绑定方式</p></blockquote><h3 id="2-虚方法与非虚方法"><a href="#2-虚方法与非虚方法" class="headerlink" title="2. 虚方法与非虚方法"></a>2. 虚方法与非虚方法</h3><p>非虚方法：</p><ul><li>如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变得。这样的方法称为非虚方法</li><li>静态方法、私有方法、、final方法、实例构造器、父类方法都是非虚方法</li><li>其他方法则称为虚方法</li></ul><p>调用指令：</p><ul><li>普通调用指令：<ol><li><strong>invokestatic：调用静态方法，解析阶段确定唯一方法版本</strong></li><li><strong>invokespecial：调用<init>方法、私有父类方法，解析阶段确定唯一方法版本</strong></li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ol></li><li>动态调用指令：<ol><li>invokedynamic：动态解析出需要调用的方法，然后执行</li></ol></li></ul><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持有用户确定方法版本。其中invokestatic指令和invokespecial指令电泳的方法称为非虚方法，其余的（除了final修饰的）都成为虚方法</p><h3 id="3-关于invokedynamic指令"><a href="#3-关于invokedynamic指令" class="headerlink" title="3. 关于invokedynamic指令"></a>3. 关于invokedynamic指令</h3><ul><li>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现 <strong>动态类型语言</strong> 支持而做的一种改进</li><li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层自己吗工具来产生invokedynamic指令。<strong>直到Java8的Lambda表达式的出现，invokeddynamic指令的生成，在Java中才有了直接的生成方式</strong></li><li>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来说比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器</li></ul><h3 id="4-方法重写的本质"><a href="#4-方法重写的本质" class="headerlink" title="4. 方法重写的本质"></a>4. 方法重写的本质</h3><ol><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作c</li><li>如果在类型c中找到与常量中的描述符合，简单名称都相符的方法，则进行访问权限效验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.IllegalAccessError 异常</li><li>否则，按照继承关系从下往上依次对c的各个父类进行第2步的搜索和验证过程</li><li>如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError 异常</li></ol><h3 id="5-虚方法表："><a href="#5-虚方法表：" class="headerlink" title="5. 虚方法表："></a>5. 虚方法表：</h3><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200724163925.png" alt="虚方法表"></p><h1 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h1><ul><li>存放调用该方法的pc寄存器的值</li><li>一个方法的结束，有两种方式：1.正常执行完成；2.出现未处理的异常，非正常退出</li><li>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常推出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息</li></ul><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><ol><li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；</li></ol><blockquote><ol><li>一个方法按在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值得实际数据类型而定</li><li>在字节码指令中，返回指令包含ireturn、lreturn、freturn、dreturn以及areturn，另外还有一个return让你指令供声明为void的方法、实力初始化方法、类和接口的初始化方法使用</li></ol></blockquote><ol start="2"><li>在方法执行过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称异常完成出口</li></ol>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的 2020 上半年 - 个人的一些感想与总结</title>
    <link href="/2020/07/18/%E6%88%91%E7%9A%842020%E4%B8%8A%E5%8D%8A%E5%B9%B4%20-%20%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <url>/2020/07/18/%E6%88%91%E7%9A%842020%E4%B8%8A%E5%8D%8A%E5%B9%B4%20-%20%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="我的-2020-上半年-个人的一些感想与总结"><a href="#我的-2020-上半年-个人的一些感想与总结" class="headerlink" title="我的 2020 上半年 - 个人的一些感想与总结"></a>我的 2020 上半年 - 个人的一些感想与总结</h1><h2 id="躲过了年前的武汉封城-1月上旬-1月末"><a href="#躲过了年前的武汉封城-1月上旬-1月末" class="headerlink" title="躲过了年前的武汉封城 | 1月上旬 ~ 1月末"></a>躲过了年前的武汉封城 | 1月上旬 ~ 1月末</h2><p>2020年1月，考研初试已经结束，考完后感觉整个人都松了口气。</p><p>想着玩几天，再开始学习一些感兴趣东西。</p><p>考完后前几天每天早上睡到9点10点起床，真的很爽，晚上玩玩游戏，打打牌，同学聚在某一个宿舍边打牌边聊天，想晚睡就晚睡，那日子真的很轻松舒服。</p><p>考研期间压抑久了，就像没事出去一起吃好吃的。正好班上玩得好的基本都是一喊恰饭就走，所以那几天吃了不少好吃的，想吃就买。</p><p>最后2019年12月末到2020年1月10日，都是在很欢乐的状态，每天学学感兴趣的东西，晚上吃完饭就娱乐，也没有那么多的拘束，真的很舒服。</p><p>虽然期间还有个课设，同时还参观了武汉当地的一个公司，但也没给我增加啥烦恼。</p><p>然后1月10日之后，由于找的导师的要求，要我们在实验室里体验几天，感受一下实验室的氛围，被留到了16日。</p><p>实验室氛围挺不错的，而且冬天开着空调，很暖和，我的临时位置靠着空调，所以甚至有点热，那几天虽然和之前的规划差不多，但是规定了早上到和晚上走的时间，而且同学们都陆陆续续回家了，所以也安耐不住想回家的心。</p><p>最后还是定了15号的票回了家。</p><p>回来后没啥感觉，当时甚至以为武汉之前传出来的类似“非典“的传染病已经控制住了，就没太在意。</p><p>谁知道没过几天，新闻里的报道让全国都紧张起来了，原来这个传染病不仅没有被控制，甚至有“非典”的势头。同时20号武汉宣布封城，突然庆幸自己早点回来了，要么困在武汉，没有亲戚，没有地方住，那日子太难了。</p><p>不过虽然是从武汉“逃”了回来，但是还是担心自己会不会也携带了病毒。当时还是有点怕的，同时也害怕传给自己的爸妈，我年轻身体可以抗，他们中老年人不一定遭得住。</p><p>虽然疫情像是迷雾一般笼罩着日常的生活，但是渐渐也没有那么担忧和害怕了。甚至一开始还在担心这次疫情，会不会导致我们国家经济大衰落，同时美国等对我们施加制裁。（不过没想到原来我们控制的竟然还算不错的）</p><h2 id="在家与父母度过了一个难忘的“寒假”-2月-4月"><a href="#在家与父母度过了一个难忘的“寒假”-2月-4月" class="headerlink" title="在家与父母度过了一个难忘的“寒假” | 2月 ~ 4月"></a>在家与父母度过了一个难忘的“寒假” | 2月 ~ 4月</h2><p>突然的封城，以及国家和政府的命令，让本来过年串门的计划落空。</p><p>我大哥的两个儿子，也就是我的两个侄子，都和我是从小一起长大，每年过年都一起见面，吃饭。俩侄子中老大比我大两岁，老二比我小一岁，每年就盼望着过年聚在一起，吃个饭。</p><p>尤其是回老家，我们仨总是混在一起，今年因为疫情，没聚在一起，可惜。</p><p>以往过年，初一到初五，就没在家里待过，今年倒是在家老老实实地待着。</p><p>三月初，武汉的疫情形式仍然严峻，我们十堰本来有个二汽，也就是东风汽车，后来总部搬到了武汉，所以有很多二汽员工到了武汉工作，正值过年，都会回来过年。这样一来，本来我们算是离武汉比较远的市，最后也有大概700左右的感染。</p><p>这两个月，我上不了学，爸爸上不了班，妈妈常年待在家中，这样的场面倒是不多见。</p><p>现在想想，好像从开始上学开始，在家就没带过这么长时间。</p><p>我爸也是上班习惯了，突然“放假”这么久，在家坐不住，三月中旬那会，每天吃了中午饭，不运动，搞得晚上都不饿，有的时候晚上都不吃饭。最后结果就是我们家中午蒸米饭的量减少了1/3。</p><p>每天的日程就是：</p><p>我、爸和妈都不约而同地早上10点起床，过一会了直接吃午饭。一是在家出不了门，运动不了，吃多了反而不消化；二是没法采购，省着点吃。经常那个时候太阳也正好挺暖和，我就坐在阳台上看看书。要是早上起不来，那一上午就睡过去了。:D</p><p>中午就正常吃一顿，下午我开始学习自己感兴趣的东西，爸妈中午跑来我的卧室，睡睡午觉，醒了就玩玩手机。</p><p>那段时间不知道为什么，慢慢地能静下心来看看书，这两个月我把《算法》给看完了，当年没好好学，现在觉得这些东西还是挺有意思的。对照着书上，每种数据结构和算法都手敲一遍，基本都弄得清楚来龙去脉（除了那个该死的红黑树，最后的代码实在有点晦涩难懂）</p><p>晚上就简单吃点面条，不过可不是普通的青菜汤面，而是“苞谷碜面条”，不知道其他地方又没有这样吃的（笑）。苞谷碜就是市面上磨碎的那种玉米面，不知道为啥我爸妈特喜欢这样吃，我倒是无感，总不能不吃吧。（苦笑</p><p>那段时间挺舒服的，虽然在家憋得慌，但是挺值得回忆的，难得一家三口都在，虽然爸妈有时候会拌拌嘴，不过最后屁事没有。</p><p>以后可能就没有这样的时间和机会了，害。</p><h2 id="考研的收尾-复试-5月-6月中旬"><a href="#考研的收尾-复试-5月-6月中旬" class="headerlink" title="考研的收尾 - 复试 | 5月 ~ 6月中旬"></a>考研的收尾 - 复试 | 5月 ~ 6月中旬</h2><p>五月初，得知可能五六月份就要复试时，立马去把指定的数目复习了一遍，也就是我们专业课那几门。</p><p>当时还没有准确的通知，表明是否要线上笔试，大家都非常纠结，就怕复习了，结果不笔试；不复习吧，要是通知要笔试，那直接凉了。</p><p>反正这段时间就在忐忑中一直复习。早上起来学习一个半小时，中午休息一会，下午学到五点左右。然后晚上学学java，日子倒也挺充实。</p><p>复试完后，没多久就出结果了，虽然我有优录，并且初试分也不算低，还算可以。但是多多少少还有点开奖前的那种紧张。</p><p>不过最后还是没啥大问题。录取结果出的也不算慢，但是就像刚考完试，等待成绩时焦急的状态一样，总是想着：都复试完了，管那么多干嘛，但还是没事就打开考研群，看到老哥们和我一样，边吹水，边焦急等待，自己也一样莫名急切地看到结果，好让焦虑的心缓一缓。</p><h2 id="初入项目组-6月下旬-写下这篇文章的此时（7月18日开始写的，但是一直拖到了8月11日）"><a href="#初入项目组-6月下旬-写下这篇文章的此时（7月18日开始写的，但是一直拖到了8月11日）" class="headerlink" title="初入项目组 | 6月下旬 ~ 写下这篇文章的此时（7月18日开始写的，但是一直拖到了8月11日）"></a>初入项目组 | 6月下旬 ~ 写下这篇文章的此时（7月18日开始写的，但是一直拖到了8月11日）</h2><p>六月初，复试结束，急急忙忙地进入了现在的项目组。</p><p>初来乍到，之前只学过Java和一点python，不过还好自己对于编程有一定的兴趣，不至于被unity劝退。</p><p>一开始unity对于我来说完全是陌生的，图形界面、C#以及两者的结合使用，让我有点措手不及。</p><p>习惯了对着命令行，那一行一行出来的结果，突然转成GUI形式，有点不适应。</p><p>第一件任务，也算是给我们热身的任务，是集成firebase，一个轻量级的后台，可以为游戏或者应用提供统计事件之类的支持。</p><p>我记得我做的是remote_config以及dynamic_linking。</p><p>一开始什么都不懂，搜了半天中文社区论坛，没有发现和firebase有关的东西，说难听点，自己就是在垃圾堆里找垃圾吃，csdn真的差劲，根本没有相关文章，有一篇，那也都是到处复制粘贴的，真的垃圾（原谅我爆粗口，但是csdn论坛的水平真的是由于平台不作为和垃圾运营造成的）</p><p>这也逼迫着我开始看英文文档，也开始看之前知道，但是看得少的stackoverflow社区，问题也一个个地排解了，实验demo也搞通了，还是挺自豪的:D</p><p>慢慢地也开始上手项目，虽然C#没深入学过，但是其语法和Java蛮像的，因此我上手也算快。</p><p>从六月开始也开始学习JVM，书算是过了一遍，目前在看视频复习，消化。</p><p>项目上，正好遇到要做关于图的搜索，之前算法那本书上学了关于图的算法，所以在项目里也贡献了一些代码。</p><p>而且学长学姐也主要做业务方面的任务，放任我去搞些开放性的东西，正好把我之前学的算法用上了，感觉还是挺好。</p><h2 id="尾声，总结"><a href="#尾声，总结" class="headerlink" title="尾声，总结"></a>尾声，总结</h2><p>这上半年，有偷懒，也有勤奋学习的时候，下半年，要到学校了，继续学习，keep learning！</p>]]></content>
    
    
    <categories>
      
      <category>个人总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2020</tag>
      
      <tag>个人总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 笔记 - 4 程序计数器</title>
    <link href="/2020/07/16/JVM%20-%204.%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
    <url>/2020/07/16/JVM%20-%204.%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="PC-Register"><a href="#PC-Register" class="headerlink" title="PC Register"></a>PC Register</h1><p>JVM中的程序记数寄存器（Program Counter Register）中，Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。</p><p>在这里，并非是广义上所指的物理寄存器，或许将其翻译为PC技术器（或指令计数器）更加贴切。JVM中的PC寄存器是对物理PC寄存器的一种<strong>抽象模拟</strong>。</p><p>作用：PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。有执行引擎读取下一条指令。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200718160916.png" alt="PC寄存器"></p><p>PC寄存器：</p><ul><li>它是一块很小的内存空间，几乎乐意忽略不计。也是运行速度最快的存储区域。</li><li>在JVM规范中，每个线程都要它自己的程序计数器，是线程私有的，生命周期与线程生命保持一致。</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址。</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程回复等基础操作功能都需要依赖这个计数器来完成。</li><li>字节码解释器工作时就是通过这个计数器的值来选取下一条需要执行的字节码指令。</li><li>它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</li></ul><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200718162343.png" alt="举例"></p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200718162814.png" alt="举例2"></p><h1 id="两个常见问题"><a href="#两个常见问题" class="headerlink" title="两个常见问题"></a>两个常见问题</h1><h2 id="1-使用PC寄存器存储字节码指令地址有什么用呢？"><a href="#1-使用PC寄存器存储字节码指令地址有什么用呢？" class="headerlink" title="1. 使用PC寄存器存储字节码指令地址有什么用呢？"></a>1. 使用PC寄存器存储字节码指令地址有什么用呢？</h2><p>因为CPU需要不停的切换各个线程，这时候切换回来之后，就得知道接着从哪里开始继续执行。</p><p>JVM的字节码解释器就需要通过改变PC寄存器的值类明确下一条应该执行什么样的字节码指令。</p><h2 id="2-PC寄存器为什么会被设定为线程私有？"><a href="#2-PC寄存器为什么会被设定为线程私有？" class="headerlink" title="2. PC寄存器为什么会被设定为线程私有？"></a>2. PC寄存器为什么会被设定为线程私有？</h2><p>所谓的多线程在一个特定的时间段内只会执行某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断和恢复。</p><p>为了能够准确地记录各个县城正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可独立进行计算，不会出现相互干扰。</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Crafting Interpreters -  The Lox Language</title>
    <link href="/2020/07/14/Crafting%20Interpreters-%5B3%5D/"/>
    <url>/2020/07/14/Crafting%20Interpreters-%5B3%5D/</url>
    
    <content type="html"><![CDATA[<h1 id="Crafting-Interpreters-1-3-The-Lox-Language"><a href="#Crafting-Interpreters-1-3-The-Lox-Language" class="headerlink" title="Crafting Interpreters - [1-3] The Lox Language"></a>Crafting Interpreters - [1-3] The Lox Language</h1><blockquote><p>你可以为某人做些比让他们吃早餐更好的事情吗？</p><p>​    - Anthony Bourdain</p></blockquote><blockquote><p>因为项目的原因（其实是自己懒），第三节迟迟没有翻译更新，之后应该也是随缘，佛系更新（虽然也确实没人康）。不过这本书确实还不错，顺便还能锻炼阅读英文的能力。</p></blockquote><p>我们将用本书的其余部分来详细阐明Lox语言的每个角落，但是！让你立即开始编写解释器的代码，而不了解我们最终会将Lox实现成什么样，那可能不太现实。</p><p>同时，在接触到文本编辑器之前，我不想让你了解大量的规范术语。所以对于Lox，我会温和、友好地介绍它。这可能会忽略很多细节和边界情况，但我们有足够的时间稍后再做这些。</p><h2 id="3-1-你好，Lox（你好，世界）"><a href="#3-1-你好，Lox（你好，世界）" class="headerlink" title="3.1 你好，Lox（你好，世界）"></a>3.1 你好，Lox（你好，世界）</h2><p>这是我们用Lox写的第一段代码：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cos"><span class="hljs-comment">// Your first Lox program!</span><br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Hello, world!&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><blockquote><p>这两行代码应该是所有人学编程都绕不开的东西。“你好，世界”，简单的一句话，对于编程，或者说整个计算机知识体系大厦来说，就像那个不起眼的门，门外的人只看到了高耸的大厦，而真正吸引人，让这么多计算机专家痴迷的，则是这个大厦里面所包含的精华，即构建信息时代的基石。</p><p>– 来自译者的胡言乱语</p></blockquote><p>正如//注释和尾随分号所暗示的那样，Lox的语法是C系列的成员。 （因为打印是一个内置语句，而不是库函数，所以字符串周围没有括号。）</p><p>不过现在，我不会夸赞说C具有出色的语法。 如果我们想要的是一种精致的东西，那我们可能会模仿Pascal或Smalltalk。 如果我们想全面了解斯堪的纳维亚家具的极简主义，则我们也有方法去实现。精致和极简各有各的好处。</p><p>与c类似的语法相反，你会发现在一门语言中更有价值的东西是：熟悉的感觉。我知道你已经习惯了你所熟悉的风格，因为我们将用于实现Lox的两种语言Java和C也继承了它。在Lox中使用类似的语法可以让你少学一点东西。</p><h2 id="3-2-高级语言"><a href="#3-2-高级语言" class="headerlink" title="3.2 高级语言"></a>3.2 高级语言</h2><p>虽然这本书的内容比我希望的要多，但它仍然不足以容纳像Java这样的大型语言。为了在这本书中展示两个完整的Lox实现，我们的Lox本身必须非常紧凑。</p><p>当我想到那些小而有用的语言时，我首先想到的是高级脚本语言，比如JavaScript、Scheme和Lua。在这三种语言中，Lox看起来最像JavaScript，主要是因为大多数c语法语言都是这样。我们稍后将了解到，Lox确定作用域的方法与Scheme密切相关。我们将在第三部分中构建的C风格的Lox在很大程度上得益于Lua干净、高效的实现。</p><p>Lox与这三种语言在其他两个方面有相同之处：</p><h3 id="3-2-1-动态类型"><a href="#3-2-1-动态类型" class="headerlink" title="3.2.1 动态类型"></a>3.2.1 动态类型</h3><p>Lox是动态类型的。变量可以存储任何类型的值，单个变量甚至可以在不同时间存储不同类型的值。如果你尝试对错误类型的值执行操作，例如，用一个数字除以一个字符串，那么运行时将会检测到错误到并报告。</p><p>而静态类型被人喜欢的原因有很多，但是这些原因都没重要到，让Lox放弃动态类型。静态类型系统需要学习和实现大量的工作。跳过它，我们的书会更加的精简。如果我们把类型检查推迟到运行时，我们就能让解释器启动并更快地执行代码。</p><h3 id="3-2-2-自动内存管理"><a href="#3-2-2-自动内存管理" class="headerlink" title="3.2.2 自动内存管理"></a>3.2.2 自动内存管理</h3><p>高级语言的存在是为了消除容易出错的、低层次的苦差事，没啥比手动管理存储的分配和释放更乏味（c++大佬们可能会乐于其中，我这种渣渣还是希望语言所依附的虚拟机来帮我把这些都安排妥当 <strong>:D</strong> ）。</p><p>有两种主要的内存管理技术:引用计数和跟踪垃圾收集(通常称为垃圾收集或GC)。Ref计数器的实现要简单得多，我认为这就是为什么Perl、PHP和Python一开始都使用它们的原因。但是，随着时间的推移，ref计数的限制变得太麻烦了。所有这些语言最终都添加了完整的跟踪GC，或者至少添加了足够的GC来清理对象循环。</p><p>跟踪垃圾收集乍一听还是挺高端，且让人望而却步的，因为直接在内存的层次上操作确实是有点痛苦的。调试GC有时会让你在梦中看到十六进制转储。但是，请记住，这本书是关于驱散魔法和杀死那些怪物的，所以我们要写我们自己的垃圾收集器。我想你会发现这个算法非常简单，写起来也很有趣。</p><h2 id="3-3-数据类型"><a href="#3-3-数据类型" class="headerlink" title="3.3 数据类型"></a>3.3 数据类型</h2><p>在Lox的小小小小小宇宙中，组成所有物质的原子是内建的数据类型。有以下几种：</p><ul><li><p><strong>Booleans</strong> 布朗值：</p><p>你编代码不可能没有逻辑，同时没有逻辑值你也无法在代码中表示逻辑。<strong>“True” <strong>和 <strong>“False”</strong>，软件的</strong>阴</strong>和<strong>阳</strong>。与一些古老的语言不同的是，Lox有一个专用的布尔类型，它将现有的类型用于表示真与假。</p><p>而布朗值只有两种：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-literal">true</span>; <span class="hljs-regexp">//</span> Not <span class="hljs-literal">false</span>.<br><span class="hljs-literal">false</span>; <span class="hljs-regexp">//</span> Not *<span class="hljs-keyword">not</span>* <span class="hljs-literal">false</span>. 套娃？<br></code></pre></td></tr></table></figure></li><li><p><strong>Numbers</strong> 数值：</p><p>Lox只有一种数字:双精度浮点数。由于浮点数还可以表示范围广泛的整数，因此它在保持简单的同时涵盖了很多领域。</p><p>功能齐全的语言有大量的数字语法，十六进制，科学的表示法，八进制，各种有趣的东西。我们将满足于基本的整数和十进制文字：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-number">1234</span>; <span class="hljs-comment">// An integer.</span><br><span class="hljs-number">12.34</span>; <span class="hljs-comment">// a deciaml number.</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Strings</strong> 字符串：</p><p>在第一个例子中我们已经看到了一个字符串文字。像大多数语言一样，它们被括在双引号中：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-string">&quot;I am a string&quot;</span>;<br><span class="hljs-string">&quot;&quot;</span>;      // The<span class="hljs-built_in"> empty</span><span class="hljs-built_in"> string</span>.<br><span class="hljs-string">&quot;123&quot;</span>; // This <span class="hljs-literal">is</span> a<span class="hljs-built_in"> string</span>,<span class="hljs-built_in"> not</span> a<span class="hljs-built_in"> number</span>.<br></code></pre></td></tr></table></figure><p>当我们开始实现它们时，我们将看到，在那些无害的字符序列中隐藏了相当多的复杂性。</p></li><li><p><strong>Nil</strong> 空（类似null）：</p><p>还有最后一个我们并没有邀请加入到我们这本书中，但似乎总是出现的一位常客。它不代表任何值。它在许多其他语言中被称为null。在Lox中，我们拼写为nil。(当我们实现它时，这将有助于区分当我们讨论Lox的nil和Java或C的null）</p><p>在语言中不使用空值是有很好的理由的，因为空指针错误是对于Java设计人员来说，简直是家常便饭。如果我们在做一种统计类型的语言，可能值得去尝试禁止它。然而，在动态类型的代码中，删除它通常比使用它更烦人。</p></li></ul><h2 id="3-4-表达式"><a href="#3-4-表达式" class="headerlink" title="3.4 表达式"></a>3.4 表达式</h2><p>如果内置数据类型及其文字是原子，那么表达式就必须是分子。其中大多数都是我们所熟悉的。</p><h3 id="3-4-1-算数"><a href="#3-4-1-算数" class="headerlink" title="3.4.1 算数"></a>3.4.1 算数</h3><p>Lox提供了我们熟知的C和其他语言中的基本算术运算符：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">add + <span class="hljs-keyword">me</span>;<br>subtract - <span class="hljs-keyword">me</span>;<br>multiply * <span class="hljs-keyword">me</span>;<br>divide / <span class="hljs-keyword">me</span>;<br></code></pre></td></tr></table></figure><p>操作符两边的子表达式都是操作数。因为有两个，它们被称为二元运算符。(它与二进制的“1 - 0”用法无关)因为操作符固定在操作数的中间，所以这些操作符也称为中缀操作符，而不是前缀操作符(操作符位于操作数的前面)和后缀操作符(它位于操作数的后面)。</p><p>同时有一个算术运算符，它既是中缀又是前缀。那就是 - 操作符，其用于取反：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">-negateMe<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>所有这些运算符都用于数字，其他类型都是错误的。唯独有一个例外，那就是 + 操作符，+ 操作符可以连接两个字符串。</p><h3 id="3-4-2-比较与等于"><a href="#3-4-2-比较与等于" class="headerlink" title="3.4.2 比较与等于"></a>3.4.2 比较与等于</h3><p>and go on，我们还有一些总是返回布尔结果的运算符。我们可以比较数字(而且只能比较数字)，同时返回比较的结果：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">less &lt; than<span class="hljs-comment">;</span><br>lessThen &lt;= orEqual<span class="hljs-comment">;</span><br>greater &gt; than<span class="hljs-comment">;</span><br>greaterThen &gt;= orEqual<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>我们可以测试任何类型的两个值是相等，还是不相等：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>== <span class="hljs-number">2</span>;          //false<br><span class="hljs-string">&quot;cat&quot;</span> != <span class="hljs-string">&quot;dog&quot;</span>;  //true<br></code></pre></td></tr></table></figure><p>甚至是不同类型的数据：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">314 </span>== <span class="hljs-string">&quot;pi&quot;</span>;     //false<br></code></pre></td></tr></table></figure><p>当然，结果肯定为false，任何两种不同类型的数据比较，结果都为false：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">123 </span>== <span class="hljs-string">&quot;123&quot;</span>;    // false<br></code></pre></td></tr></table></figure><p>正如我说的，我通常是反对隐式转换的。（原作者如是说道，不过译者认为隐式转换在开发者了解其原理的情况下，合理利用，还是很方便的，毕竟高级程序语言就是为了贴合人的思维）</p><h3 id="3-4-3-逻辑操作符"><a href="#3-4-3-逻辑操作符" class="headerlink" title="3.4.3 逻辑操作符"></a>3.4.3 逻辑操作符</h3><p>如果操作数为真，则作为前缀!的not操作符返回false，反之亦然：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">!<span class="hljs-literal">true</span>;    <span class="hljs-comment">//false</span><br>!<span class="hljs-literal">false</span>;   <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>另外两个逻辑操作符实际上是伪装为表达式的控制流（Control Flow）构造。and表达式确定两个值是否都为真。如果为false，则返回左操作数，否则返回右操作数：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">false</span> or <span class="hljs-literal">false</span>;   <span class="hljs-comment">//false</span><br><span class="hljs-literal">true</span> or <span class="hljs-literal">false</span>;    <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>and 和 or 之所以说是控制流，是因为它们遵从了短路效应。当 and 操作符左边的操作数为 true 时，该表达式不仅返回 true，其甚至不会执行右边的操作数（当然该操作数也可能是一个表达式）。相反的，如果 or 操作符左边的操作数为 false，那么该表达式会直接返回 false，同时右边的操作数不会执行。</p><h3 id="3-4-4-优先级和分组"><a href="#3-4-4-优先级和分组" class="headerlink" title="3.4.4 优先级和分组"></a>3.4.4 优先级和分组</h3><p>所有这些运算符都具有相同的优先级和结合性，并且和c语言相同。如果优先级没有符合开发者的期望，则可以使用()对内容进行分组：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">var</span> <span class="hljs-built_in">average</span> = (<span class="hljs-built_in">min</span> + <span class="hljs-built_in">max</span>) / <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>因为它们在技术上不是很有趣，所以我从我们的小语言中去掉了典型操作符的其余部分，所以我们的Lox没有按位、移位、模或条件运算符。但如果你能自己实现它，那我会对你刮目相看的 : p</p><p>这些是表达形式(除了一些与我们将在后面讨论的特定特性相关的形式)，所以让我们再上一层。</p><h2 id="3-5-语句式（Statement）"><a href="#3-5-语句式（Statement）" class="headerlink" title="3.5 语句式（Statement）"></a>3.5 语句式（Statement）</h2><p>现在我们来到了语句。表达式（Expression）的主要任务是生成值，而语句（Statement）的主要任务是产生效果。根据定义，语句并不会产生任何值，因此表达式想要改变世界，通常是修改某种状态、读取输入或生成输出。</p><p>下面是一个语句：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">print</span> <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br></code></pre></td></tr></table></figure><p>一个 print 语句计算单个表达式的值，并将结果显示给用户，下面又是一个语句：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-string">&quot;some expression&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>表达式后添加分号 ; ，便提升为语句，这被称为表达式语句。</p><p>如果希望在需要一个语句的地方封装一系列语句，可以将它们封装在一个块中：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&#123;<br><span class="hljs-builtin-name">print</span> <span class="hljs-string">&quot;One statement.&quot;</span>;<br><span class="hljs-builtin-name">print</span> <span class="hljs-string">&quot;Two statement.&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>块</strong> 也会影响作用域，那就是以下部分的东西了。。。</p><h2 id="3-6-变量"><a href="#3-6-变量" class="headerlink" title="3.6 变量"></a>3.6 变量</h2><p>使用var语句声明变量。如果省略了初始化器，则变量的值默认为nil：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var imAVariable = <span class="hljs-string">&quot;here is my value&quot;</span><span class="hljs-comment">;</span><br>var iAmNil<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>一旦声明，你自然通过变量名来访问和对其幅值：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">var breakfast = <span class="hljs-string">&quot;bagels&quot;</span>;<br>print breakfast;  <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;bagels&quot;</span><br>breakfast = <span class="hljs-string">&quot;beignets&quot;</span>;<br>print breakfast;  <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;beignets&quot;</span><br></code></pre></td></tr></table></figure><p>在这里我们没有讨论变量作用域的问题，因为后面的章节中，我们会花大量的时间来实现这些规则，其规则也和C与Java一样。</p><h2 id="3-7-控制流（Control-Flow）"><a href="#3-7-控制流（Control-Flow）" class="headerlink" title="3.7 控制流（Control Flow）"></a>3.7 控制流（Control Flow）</h2><p>如果不能跳过一些代码，或者不止一次地执行某些代码，那对于开发者来讲，简直是噩梦。所以我们需要控制流，控制代码执行的流向。除了我们已经说的逻辑操作符，Lox直接从C的规范中搬过来了三个控制流。</p><p>首当其冲的就是 if 语句，它根据某些条件，来执行两个语句中的一个：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">if</span> (condition) &#123;<br>  <span class="hljs-builtin-name">print</span> <span class="hljs-string">&quot;yes&quot;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-builtin-name">print</span> <span class="hljs-string">&quot;no&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其次是 while 语句，只要符合条件，它就会不断执行其body中的代码：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (a &lt; <span class="hljs-number">10</span>) <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  print a;</span><br><span class="hljs-comment">  a = a + 1;</span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure><p>以及最后的 for 循环：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for (var a = <span class="hljs-number">1</span><span class="hljs-comment">; a &lt; 10; a = a + 1) &#123;</span><br>  print a<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>for 循环的操作与之前的 while 循环相同。大多数现代语言还具有某种 for-in 或 foreach 循环，用于显式地遍历各种序列类型。在真正的语言中，这比我们在这里得到的原始的c风格的for循环要好。不过我们的Lox还是保持原始的味道 。:D</p><h2 id="3-8-方法（Function）"><a href="#3-8-方法（Function）" class="headerlink" title="3.8 方法（Function）"></a>3.8 方法（Function）</h2><p>Lox的方法调用和C很像：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">make<span class="hljs-constructor">Breakfast(<span class="hljs-params">bacon</span>, <span class="hljs-params">eggs</span>, <span class="hljs-params">toast</span>)</span>;<br></code></pre></td></tr></table></figure><p>你还可以不传任何参数地调用方法：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">makeBreakfast()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>与Ruby不同，括号在Lox中是必需的。如果你把它们去掉，解释器执行时不会调用这个函数，而只是把它当做一个引用。</p><p>一个语言不能定义方法，那就不算合格。在Lox中，你可以用 fun 来声明方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printSum</span><span class="hljs-params">(a, b)</span></span> &#123;<br>  print a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>OK，那现在该澄清一些术语。有些人将 <strong>“argument”</strong> 和 <strong>“parameter”</strong> 混淆，甚至很多人认为这两个没啥区别。实际上这两个词在语义上是有细微差别的，所以让我们精确定义一下：</p><ul><li><strong>“argument”</strong> 是在调用函数时传递给函数的实际值，函数在调用时，是有一个 argument 列表的。所以其也被称为”actual parameter”，即<strong>实参</strong>。</li><li><strong>“parameter”</strong> 是保存函数体内参数值的变量。因此，函数声明有一个 parameter 列表。也可以成为 “formal parameter” 或者就简单地叫 “formals”，即<strong>形参</strong>。</li></ul><p>函数的主体总是一个块。在其中，可以使用return语句返回值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">returnSum</span><span class="hljs-params">(a, b)</span></span> &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Lox中，如果执行到块的末尾而没有返回，则隐式返回nil。</p><h3 id="3-8-1闭包（-Closures）"><a href="#3-8-1闭包（-Closures）" class="headerlink" title="3.8.1闭包（ Closures）"></a>3.8.1闭包（ Closures）</h3><p>函数是Lox中的 “first class”，这意味着它是你可以获得引用的、存储在变量中的、传递的以及等等的真实值，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addPair</span><span class="hljs-params">(a, b)</span></span> &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">identity</span><span class="hljs-params">(a)</span></span> &#123;<br>  <span class="hljs-keyword">return</span> a;<br>&#125;<br><br>print identity(addPair)(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// Prints &quot;3&quot;.</span><br></code></pre></td></tr></table></figure><p>由于函数声明是语句，所以可以在另一个函数中声明局部函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">outerFunction</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">localFunction</span><span class="hljs-params">()</span></span> &#123;<br>    print <span class="hljs-string">&quot;I&#x27;m local!&quot;</span>;<br>  &#125;<br><br>  localFunction();<br>&#125;<br></code></pre></td></tr></table></figure><p>如果结合使用本地函数、一级函数和块作用域，就会遇到这种有趣的情况：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">returnFunction</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">var</span> outside = <span class="hljs-string">&quot;outside&quot;</span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">inner</span><span class="hljs-params">()</span></span> &#123;<br>    print outside;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">inner</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> fn = returnFunction();<br>fn();<br></code></pre></td></tr></table></figure><blockquote><p>该语法和Java实际上是大相径庭的，Lox反而更像js</p></blockquote><p>在上面代码中，inner()访问在周围函数中其主体之外声明的局部变量。这是真的可以吗（来自Java程序员疑惑的眼光）？现在很多语言都从Lisp借用了这个特性，所以答案是肯定的。</p><p>为了实现这一点，inner()必须保留对它所使用的任何周围变量的引用，这样即使在外部函数返回之后，这些变量仍然存在。我们将执行此操作的函数称为闭包（Closures）。这个术语经常用于很多一级函数，尽管如果函数没有关闭任何变量，它就有点用词不当。</p><p>读到这里，你的想法没错，实现这些会增加一些（serious ?）复杂性，因为我们不能再假设变量作用域严格地像堆栈一样工作，即局部变量在函数返回时就蒸发掉了。后面我们会具体陈述这方面的实现。</p><h2 id="3-9-类"><a href="#3-9-类" class="headerlink" title="3.9 类"></a>3.9 类</h2><p>由于Lox具有动态类型、词法(简单来说就是块)作用域和闭包，它距离成为函数式语言仍然还有一半的距离。不过你也看到了，它差不多已经有面向对象语言的内味（那种味道）了。这两种范式都有很多优点，所以我认为有必要介绍其中的一些。</p><p>类是面向对象语言中不可获取的东西，但是它的表现并没有像宣传的那样那么耀眼，不过还是让我先解释一下为什么我仍把它放在Lox和本书中。这里有两个问题：</p><h3 id="3-9-1-为什么无论任何一种语言，都想成为一种面向对象的语言？"><a href="#3-9-1-为什么无论任何一种语言，都想成为一种面向对象的语言？" class="headerlink" title="3.9.1 为什么无论任何一种语言，都想成为一种面向对象的语言？"></a>3.9.1 为什么无论任何一种语言，都想成为一种面向对象的语言？</h3><p>现在，像Java这样的面向对象语言已经火过了，并在很多场合有应用，人们对其可能有点审美疲劳了，不再那么喜欢它们了。那么为什么会有人用对象创造一种新语言呢？这不就像发行8音轨的音乐吗？（译者不太懂这个梗）</p><p>不过的确，90年代的“无论何时无论何物全都有继承”的热潮产生了一些可怕的类层次结构，但面向对象编程仍然相当出色。今天，很可能大多数工作的程序员都在使用面向对象的语言，总不能是这些经验老到的程序员们都错了吧。</p><p>特别是，对于动态类型语言，对象非常方便。我们需要一些方法来定义复合数据类型，以便将大量的东西捆绑在一起。</p><p>如果我们也可以挂起这些方法，那么就可以避免在所有函数前面加上它们操作的数据类型的名称，以避免与针对不同类型的类似函数发生冲突。比如，在Racket软件中，你不得不给函数命名为hash-copy(复制哈希表)和vector-copy(复制矢量)，这样它们就不会相互踩到。方法的作用域被限定在对象上，这样问题就消失了。</p><h3 id="3-9-2-那为什么Lox也要是面向对象呢？"><a href="#3-9-2-那为什么Lox也要是面向对象呢？" class="headerlink" title="3.9.2 那为什么Lox也要是面向对象呢？"></a>3.9.2 那为什么Lox也要是面向对象呢？</h3><p>我可以声明对象是groovy，但仍然超出了本书的范围。大多数编程语言书籍，尤其是那些试图实现一门完整语言的书籍，都忽略了对象。对我来说，这意味着这个话题没有被很好地涵盖。在如此广泛的范式下，这种遗漏让我感到悲哀。</p><p>考虑到我们中有多少人整天都在使用OOP语言，我们似乎可以使用一些文档来说明如何创建OOP。如你所见，这很有趣。不像你担心的那么难，但也不像你想象的那么简单。</p><h3 id="3-9-3-类还是原型？"><a href="#3-9-3-类还是原型？" class="headerlink" title="3.9.3 类还是原型？"></a>3.9.3 类还是原型？</h3><p>对于对象，实际上有两种方法，类和原型。首先出现的是类，由于c++、Java、c#和朋友的帮助，类更加常见。原型实际上是一个被遗忘的分支，直到JavaScript意外地接管了世界。（指js在web端的称霸）</p><p>在基于类的语言中，有两个核心概念:实例和类。实例存储每个对象的状态，并引用实例的类。类包含方法和继承链。要在实例上调用方法，总是存在间接级别。查找实例类，然后在那里找到方法：</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200718221214.png" alt="类与实例"></p><p>基于原型的语言合并了这两个概念。只有对象，没有类，每个单独的对象可以包含状态和方法。对象可以直接相互继承(或者用原型术语表示委托)</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200718221406.png" alt="原型"></p><p>这意味着原型语言在某种程度上比类更基础。它们实现起来非常好，因为它们非常简单。此外，它们还可以表示许多不寻常的模式，这些模式是类引导您避开的。</p><p>但是我看过很多用原型语言编写的代码，包括一些我自己设计的。你知道人们通常用原型的强大和灵活性做什么吗？他们用它来重新创建类。（哈哈哈，本末倒置）</p><p>我不知道为什么，但是人们似乎很自然地更喜欢基于类的(经典？优雅的？)的风格。在语言中，原型更简单，但它们似乎只能通过将复杂性推给用户来实现。因此，对于Lox，我们将为用户省去麻烦并直接编写类。</p><h3 id="3-9-4-Lox中的类"><a href="#3-9-4-Lox中的类" class="headerlink" title="3.9.4 Lox中的类"></a>3.9.4 Lox中的类</h3><p>有足够的理论基础，我们了解到：类包含了大多数语言中的一系列特性。对于Lox，我选择了我认为最合适的东西，比如像这样声明一个类及其方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Breakfast</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">cook</span>(<span class="hljs-params"></span>)</span> &#123;<br>    print <span class="hljs-string">&quot;Eggs a-fryin&#x27;!&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">serve</span>(<span class="hljs-params">who</span>)</span> &#123;<br>    print <span class="hljs-string">&quot;Enjoy your breakfast, &quot;</span> + who + <span class="hljs-string">&quot;.&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类的主体包含它的方法，它们看起来像函数声明，但是没有fun关键字。当执行类声明时，它创建一个类对象并将其存储在以类命名的变量中。与函数一样，类是Lox中的第一类（first class）:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> Store it <span class="hljs-keyword">in</span> variables.<br>var someVariable = Breakfast;<br><br><span class="hljs-regexp">//</span> Pass it to functions.<br>someFunction(Breakfast);<br></code></pre></td></tr></table></figure><p>接下来，我们需要一种创建实例的方法。我们可以添加一些new关键字，但为了保持简单，在Lox中，类本身是实例的工厂函数。像调用函数一样调用一个类，它就会为自己生成一个新的实例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">var breakfast = Breakfast();<br>print breakfast; <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Breakfast instance&quot;</span>.<br></code></pre></td></tr></table></figure><h3 id="3-9-5-实例化和初始化"><a href="#3-9-5-实例化和初始化" class="headerlink" title="3.9.5 实例化和初始化"></a>3.9.5 实例化和初始化</h3><p>只有行为的类并不是特别有用。面向对象编程背后的思想是将行为和状态封装在一起。为此，Lox的类中需要字段。与其他动态类型语言一样，Lox允许开发者自由地向对象添加属性：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">breakfast.meat</span> = <span class="hljs-string">&quot;sausage&quot;</span><span class="hljs-comment">;</span><br><span class="hljs-attr">breakfast.bread</span> = <span class="hljs-string">&quot;sourdough&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>如果该变量，或者说叫属性，不存在的话，那么对其赋值则会创建它。</p><p>如果你想在一个方法里访问当前对象实例中的一个变量或者方法，你需要用到那个老牌，且有用的 <strong>this</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Breakfast</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-title">serve</span>(<span class="hljs-params">who</span>)</span> &#123;<br>print <span class="hljs-string">&quot;Enjoy your &quot;</span> + <span class="hljs-built_in">this</span>.meat + <span class="hljs-string">&quot; and &quot;</span> +<br><span class="hljs-built_in">this</span>.bread + <span class="hljs-string">&quot;, &quot;</span> + who + <span class="hljs-string">&quot;.&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在对象中封装数据的一部分是为了确保对象在创建时处于有效状态。为此，可以定义初始化器。如果类有一个名为init()的方法，则在构造对象时自动调用该方法，传递给类的任何参数都被转发给它的初始化器：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Breakfast</span> </span>&#123;<br>  <span class="hljs-keyword">init</span>(meat, bread) &#123;<br>    <span class="hljs-keyword">this</span>.meat = meat;<br>    <span class="hljs-keyword">this</span>.bread = bread;<br>  &#125;<br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">var</span> baconAndToast = Breakfast(<span class="hljs-string">&quot;bacon&quot;</span>, <span class="hljs-string">&quot;toast&quot;</span>);<br>baconAndToast.serve(<span class="hljs-string">&quot;Dear Reader&quot;</span>);<br><span class="hljs-comment">// &quot;Enjoy your bacon and toast, Dear Reader.&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-9-6-继承"><a href="#3-9-6-继承" class="headerlink" title="3.9.6 继承"></a>3.9.6 继承</h3><p>每种面向对象语言都允许您不仅定义方法，而且跨多个类或对象重用它们。为此，Lox支持单继承。在声明类时，可以使用 <strong>&lt;</strong> 指定它继承的类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Brunch</span> &lt; <span class="hljs-title">Breakfast</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">drink</span>(<span class="hljs-params"></span>)</span> &#123;<br>    print <span class="hljs-string">&quot;How about a Bloody Mary?&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，Brunch是派生类或子类，而Breakfast是基类或超类。超类中定义的每个方法对它的子类也是可用的：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> benedict = Brunch(<span class="hljs-string">&quot;ham&quot;</span>, <span class="hljs-string">&quot;English muffin&quot;</span>);<br>benedict.serve(<span class="hljs-string">&quot;Noble Reader&quot;</span>);<br></code></pre></td></tr></table></figure><p>甚至init()方法也会被继承。实际上，子类通常也希望定义自己的init()方法。但是也需要调用原始类，以便超类能够维护其状态。我们需要一些方法在我们自己的实例上调用一个方法而不触及我们自己的方法。</p><p>正如Java中的一样，我们是可以使用super关键字：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Brunch</span> &lt; <span class="hljs-title">Breakfast</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">init</span>(meat, bread, drink)</span> &#123;<br>    <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(meat, bread);<br>    this.drink <span class="hljs-operator">=</span> drink;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>OK all right，我们的Lox就是这些了。我尽量把它所包含的内容降到最低。这本书的结构确实迫使我们做出妥协。Lox不是一种纯粹的面向对象语言。在真正的OOP语言中，每个对象都是类的实例，即使是像数字和布尔值这样的原始对象。</p><p>因为我们直到开始使用内置类型后才实现类，所以实现类会很困难。因此，从类的实例的意义上说，基本类型的值不是真正的对象。它们没有方法或属性。如果我试图让Lox成为针对实际用户的一种真正的语言，我就会解决这个问题。</p><h2 id="3-10-标准库"><a href="#3-10-标准库" class="headerlink" title="3.10 标准库"></a>3.10 标准库</h2><p>我们要做的基本快到头了。这就是整个语言，剩下的就是核心或标准库，这是解释器中直接实现的一组功能，所有用户定义的行为都是在其上构建的。</p><p>但我们的Lox则没那么理想了。它的标准库超越了极简主义，接近于彻底的虚无主义。对于书中的示例代码，我们只需要演示代码正在运行并执行它应该执行的操作。为此，我们已经有了内置的print语句。</p><p>之后，在开始优化时，我们将编写一些基准测试，看看执行代码需要多长时间。这意味着我们需要跟踪时间，因此我们将定义一个内置函数clock()，它返回自应用程序启动以来的秒数。</p><p>所有的库就是这样。emmmm，我知道，就这么点标准库，确实是有点尬。</p><p>如果你想将Lox变成一种实际有用的语言，则首先要做的就是充实它。 字符串操作，三角函数，文件I / O，联网，扩展，甚至从用户读取输入都将有所帮助。 但是我们在本书中不需要任何内容，添加它也不会教给您任何有趣的东西，因此我将其省略。</p><p>别担心，语言本身会有很多令人兴奋的东西让我们忙个不停。</p><blockquote><p>原文链接：<a href="https://www.craftinginterpreters.com/introduction.html">Introduction</a></p><p>阅读并翻译者：Javen Liu</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Crafting Interpreters</category>
      
    </categories>
    
    
    <tags>
      
      <tag>解释器</tag>
      
      <tag>外文书籍</tag>
      
      <tag>Crafting Interpreters</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 笔记 - 3 运行时数据区概述及线程</title>
    <link href="/2020/07/14/JVM%20-%203.%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2020/07/14/JVM%20-%203.%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200718152857.png" alt="概述"></p><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库和桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高校稳定运行。<strong>不同的JVM对于内部才能的划分方式和管理机制存在着部分差异。</strong></p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200718155420.png" alt="内存空间"></p><hr><ul><li>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁</li><li>另外一些则是与线程一一对应，这些与线程对应的区域会随着线程开始和结束而创建和销毁</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200718154857.png" alt="运行时数据区"></p><p>灰色的为单独线程私有的，红色为多个线程共享的，即：</p><ul><li><p>每个线程：独立包括程序计数器（PC）、虚拟机栈（VMS）、本地方法栈（NMS）</p></li><li><p>线程间共享：堆（Heap）、堆外内存（永久代或元空间、代码缓存）</p></li></ul><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><ul><li>线程是一个程序里的运行单元，JVM允许一个应用有多个线程并行的执行。</li><li>在HotSpot JVM里，每个线程都与操作系统的本地线程直接映射。</li><li>操作系统负责所有线程的安排调度到任何一个可用的CPU上，一旦本地线程初始化成功，它就会调用Java线程中的 run() 方法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 笔记 - 2 类加载子系统</title>
    <link href="/2020/07/12/JVM%20-%202.%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/07/12/JVM%20-%202.%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="类加载器与类的加载过程"><a href="#类加载器与类的加载过程" class="headerlink" title="类加载器与类的加载过程"></a>类加载器与类的加载过程</h1><h2 id="类加载的阶段"><a href="#类加载的阶段" class="headerlink" title="类加载的阶段"></a>类加载的阶段</h2><p>类加载阶段包括<strong>加载（Loading）阶段</strong>、<strong>链接（Linking）阶段 <strong>和 <strong>初始化（Initialization）阶段</strong>，其中链接阶段包含了</strong>验证（Verification）、准备（Preparation）、解析（Resolution）</strong></p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200716101934.png" alt="类加载阶段"></p><ul><li>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识</li><li>ClassLoader只负责class文件的加载，至于是否可以运行，则由Execution Engine决定</li><li>加载的类信息存放在一块称为 <strong>方法区</strong> 的内存空间。除了类的信息外，方法区中还会有存放运行时常量池信息，还可能包括字符串字面量和数字常量</li></ul><p>类加载器ClassLoader角色</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200716101702.png" alt="类加载器的角色"></p><h2 id="加载（Loading）阶段"><a href="#加载（Loading）阶段" class="headerlink" title="加载（Loading）阶段"></a>加载（Loading）阶段</h2><p>加载阶段包括：</p><ol><li>通过一个类的全限定名获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li><strong>在内存中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</li></ol><p>加载 .class 文件的方式：</p><ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，称为日后jar、war格式的基础</li><li><strong>运行时计算产生，使用最多的是：动态代理技术</strong></li><li>从其他文件生成，典型场景：JSP</li><li>从专有数据库中提取 .class 文件，较为少见</li><li>从加密文件中获取，典型的防 Class 文件被反编译的保护措施</li></ul><h2 id="链接（Linking）阶段"><a href="#链接（Linking）阶段" class="headerlink" title="链接（Linking）阶段"></a>链接（Linking）阶段</h2><h3 id="验证（Verify）"><a href="#验证（Verify）" class="headerlink" title="验证（Verify）"></a>验证（Verify）</h3><ul><li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机的要求，保证被加载类的正确性，不会危害虚拟机自身安全</li><li>主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号应用验证</li></ul><h3 id="准备（Prepare）"><a href="#准备（Prepare）" class="headerlink" title="准备（Prepare）"></a>准备（Prepare）</h3><ul><li>为类变量分配内存并且设置该类变量的默认初始值，即零值</li><li><strong>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备（preparation）阶段会显式初始化</strong></li><li><strong>这里不会为实例变量分配初始化</strong>，类变量会分配在方法区，而实例变量是会随着对象一起分配到Java堆中</li></ul><h3 id="解析（Resolve）"><a href="#解析（Resolve）" class="headerlink" title="解析（Resolve）"></a>解析（Resolve）</h3><ul><li>将常量池内的符号应用转化为直接应用的过程</li><li>符号引用就是一组符号来描述所引用的目标；直接引用就是直接指向目标的指针</li><li><strong>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行</strong></li></ul><h2 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a>初始化（Initialization）</h2><ul><li><strong>初始化阶段就是执行类构造器方法 <clinit>( ) 的过程</strong></li><li>此方法不需定义，是javac编译器自动收集类中的<strong>所有类变量的赋值动作</strong>和<strong>静态代码块中的语句</strong>合并而来的（<strong>也就是说，如果一个类中，所有类变量都没有赋值，而是在构造器中赋值，那么该类在初始化时，字节码中是没有<clinit>( ) 方法的</strong>）</li><li>构造器方法中指令按语句在源文件中出现的顺序执行</li><li><strong><clinit>( ) 不同于类的构造器</strong>，区别于<init>( )</li><li>若该类具有父类，JVM会保证子类的<clinit>( ) 执行前，父类的<clinit>( )已经执行完毕</li><li>虚拟机必须保证一个类的<clinit>( ) 方法在多线程下被同步加锁</li></ul><h1 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h1><ul><li>JVM支持两种类型的类加载器，分别为<strong>引导式加载器</strong>（Bootstrap ClassLoader）和<strong>自定义类加载器</strong>（User-Defined ClassLoader）</li><li>从概念上讲，自定义类加载器一般指的是程序中有开发人员自定义的一类类加载器，但是Java虚拟机规范并没这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong>。</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200717155939.png" alt="类加载器"></p><blockquote><p>这里的四者之间的关系是包含关系，不是上层下层，也不是子父类的继承关系</p></blockquote><h2 id="启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><a href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（引导类加载器，Bootstrap ClassLoader）"></a>启动类加载器（引导类加载器，Bootstrap ClassLoader）</h2><ul><li>该类是通过C/C++语言实现的，嵌套在JVM内部</li><li>它用来加载Java的核心类库（JAVA_HOME/jre/lib/rt.jar、resources.jar 或 sum.boot.class.path 路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自java.lang.ClassLoader，没有父加载器</li><li>启动类加载器也<strong>加载</strong>扩展类和应用程序类加载器，并指定为他们的父类加载器</li><li>处于安全考虑，Bootstrap启动类加载器只会加载包名为java、javax、sun等开头的类</li></ul><h2 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h2><ul><li>Java语言编写</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从 java.ext.dirs 系统属性所指定的目录中加载类库，或从JDK的安装目录的 jre/lib/ext 子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li></ul><h2 id="应用程序加载器（系统类加载器）"><a href="#应用程序加载器（系统类加载器）" class="headerlink" title="应用程序加载器（系统类加载器）"></a>应用程序加载器（系统类加载器）</h2><ul><li>java语言编写</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>负责加载环境变量classpath或系统属性 java.class.path 指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过ClassLoader # getSystemClassLoader()方法可以获取到该类加载器</li></ul><h2 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h2><p>在Java的日常开发中，类的加载几乎是由上述3中类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方法。</p><h3 id="为什么要自定义类加载器？"><a href="#为什么要自定义类加载器？" class="headerlink" title="为什么要自定义类加载器？"></a>为什么要自定义类加载器？</h3><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>放置源码泄露</li></ul><h3 id="用户自定义类加载器实现步骤："><a href="#用户自定义类加载器实现步骤：" class="headerlink" title="用户自定义类加载器实现步骤："></a>用户自定义类加载器实现步骤：</h3><ol><li>开发人员可以通过集成抽象类 <strong>java.lang.ClassLoader</strong> 类的方式，实现自己的类加载器，以满足一些特殊的需求。</li><li>在JDK1.2之前，在自定义类加载器时，总会去集成 ClassLoader 类并重写 loadClass() 方法，从而实现自定义的类加载类，但在JDK1.2之后，官方已经不建议用户去覆盖 loadClass() 方法，而是建议把自定义的类加载逻辑写在 findClass() 方法中。</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就避免自己去编写 findClass() 方法以及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ol><h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ol><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，一次递归，请求最终将达到顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派机制。</li></ol><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200717182509.png" alt="双亲委派机制"></p><h2 id="为什么用双亲委派？"><a href="#为什么用双亲委派？" class="headerlink" title="为什么用双亲委派？"></a>为什么用双亲委派？</h2><ul><li>避免类被重复加载</li><li>保护程序安全，防止核心API被恶意篡改</li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li>在JVM中表示两个class对象是否为同一个类存在两个必要条件：<ol><li>类的完整类名必须一致，包括包名</li><li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</li></ol></li><li>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载他们的CLassLoader实例对象不同，那么这两个类对象也不是相等的</li></ul><h2 id="对类的加载器的引用"><a href="#对类的加载器的引用" class="headerlink" title="对类的加载器的引用"></a>对类的加载器的引用</h2><p>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区内。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p><h2 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h2><ul><li>主动使用，分为七种情况：<ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量幅值</li><li>调用类的静态方法</li><li>反射，例如：Class.forName(“com.matrix.xxxx”)</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被表明为启动类的类</li><li>JDK 7 开始提供的动态语言支持</li></ul></li><li>除了以上七种情况，其他使用Java类的方式都被看做是对类的<strong>被动使用</strong>，都<strong>不会导致类的初始化</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 笔记 - 1 JVM与Java体系结构</title>
    <link href="/2020/07/10/JVM%20-%201.JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/2020/07/10/JVM%20-%201.JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM与Java体系结构"><a href="#JVM与Java体系结构" class="headerlink" title="JVM与Java体系结构"></a>JVM与Java体系结构</h1><h2 id="JVM的整体结构"><a href="#JVM的整体结构" class="headerlink" title="JVM的整体结构"></a>JVM的整体结构</h2><p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。</p><p>它采用解释器与解释编译期并存的架构。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200714161757.png" alt="JVM结构"></p><h2 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h2><p>Java编译器输入的指令流基本上是一种基于 <strong>栈的指令集架构</strong>，另外一种指令集架构则是基于 <strong>寄存器的指令集架构</strong>。</p><p>两者之间的区别：</p><p>基于栈式架构的特点：</p><ul><li>设计和实现更简单，适用于资源受限的系统；</li><li>避开了寄存器的分配难题：使用零地址指令方式分配；</li><li>指令流中的执行大部分是零地址指令，其执行过程中依赖于操作栈。指令集更小，编译器容易实现；</li><li>不需要硬件支持，可移植性更好，更好实现跨平台。</li></ul><p>基于寄存器架构的特点：</p><ul><li>典型的应用是x89=6的二进制指令集：比如传统的pc；</li><li><strong>指令集架构则完全依赖于硬件，可移植性差；</strong></li><li><strong>性能优秀和执行更高效；</strong></li><li>花费更少的指令去完成一项操作；</li><li>在大部分情况下，基于寄存器架构的指令往往都是以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。</li></ul><p>总结：由于跨平台的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的架构。其优点是跨平台，指令集小，编译器容易实现；缺点则是性能下降，实现同样的功能需要更多的指令。</p><h1 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h1><h2 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h2><p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）穿件一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><h2 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h2><ul><li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序；</li><li>程序开始执行时它运行，程序结束时它就停止；</li><li>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。</li></ul><h2 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h2><p>有如下几种情况：</p><ul><li>程序正常执行结束；</li><li>程序在执行过程中遇到了异常或错误而异常终止；</li><li>由于操作系统出现错误而导致Java虚拟机进程终止；</li><li>某线程调用 Runtime 类或 System 类的 exit 方法，或 Runtime 类的 halt 方法，并且Java安全管理器也允许这次 exit 或 halt 操作；</li><li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况。</li></ul><h1 id="JVM发展历程"><a href="#JVM发展历程" class="headerlink" title="JVM发展历程"></a>JVM发展历程</h1><h2 id="SUN-Classic-VM"><a href="#SUN-Classic-VM" class="headerlink" title="SUN Classic VM"></a>SUN Classic VM</h2><ul><li>第一款商用Java虚拟机</li><li>内部只提供解释器，如果要使用JIT编译器则需要外挂</li><li>解释器和编译器不能配合工作。</li></ul><h2 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h2><ul><li>Exact Memory Management：准确式内存管理</li><li>具备现代高性能虚拟机的雏形：热点探测，编译器和解释器混合工作</li><li>只在Solaris平台短暂使用，终被HotSpot替代</li></ul><h2 id="HotSpot"><a href="#HotSpot" class="headerlink" title="HotSpot *"></a>HotSpot *</h2><ul><li>JDK6与JDK8默认的虚拟机都是HotSpot</li><li>HotSpot指的是它的热点代码探测技术<ol><li>通过计数器找到最具有编译价值代码，出发即时编译或栈上替换</li><li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li></ol></li></ul><h2 id="JRockit"><a href="#JRockit" class="headerlink" title="JRockit *"></a>JRockit *</h2><ul><li>该虚拟机不太关注启动速度，其全部代码都是靠即时编译器编译执行，不包含解释器</li><li>JRockit提供了全面的Java运行时解决方案组合：<ol><li>其JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥等需要</li><li>MissionControl服务套件，是一组以极低开销来监控、管理和分析生产环境中的应用程序的工具</li></ol></li><li>目前HotSpot整合了JRockit，移植了JRockit的优秀特性</li></ul><h2 id="J9"><a href="#J9" class="headerlink" title="J9 *"></a>J9 *</h2><ul><li>全称：IBM Technology for Java Virtual Machine，内部代号为J9</li><li>市场定位与HotSpot接近</li></ul><h2 id="KVM-和-CDC-CLDC-HotSpot"><a href="#KVM-和-CDC-CLDC-HotSpot" class="headerlink" title="KVM 和 CDC/CLDC HotSpot"></a>KVM 和 CDC/CLDC HotSpot</h2><ul><li>针对Java ME产品的虚拟机</li><li>KVM简单、轻量、高度可移植性，面向更低端的设备上还维持着自己的一片市场</li></ul><h2 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h2><ul><li>前面三大“高性能Java虚拟机”使用在通用硬件平台上</li><li>Azul VM 和 BEA Liquid VM 与特定的硬件平台绑定、软硬件配合的专有虚拟机</li><li>每个 Azul VM 实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾回收器、专有硬件优化的线程调度等优秀特性</li><li>2010年，Azul Systems公司发布了自己的 Zing JVM，可以再通用x86平台上提供接近于Vega系统的特性</li></ul><h2 id="Liquid-VM"><a href="#Liquid-VM" class="headerlink" title="Liquid VM"></a>Liquid VM</h2><ul><li>高性能Java虚拟机中的战斗机</li><li>BEA公司开发的，直接运行在自己Hypervisor系统上</li><li>Liquid VM 即是现在的 JRockit VE（Virtual Edition），Liquid VM 无需操作系统的支持，或者说它自己本身实现了一个专有操作系统的必要功能，如线程调度、文件系统、网络支持等</li></ul><h2 id="Apache-Harmony"><a href="#Apache-Harmony" class="headerlink" title="Apache Harmony"></a>Apache Harmony</h2><ul><li>它是IBM和Intel联合开发的开源JVM</li><li>虽然目前没有Apache Harmony被大规模商用的案例，但是它的Java类库代码被吸纳进了Android SDK</li></ul><h2 id="Microsoft-JVM"><a href="#Microsoft-JVM" class="headerlink" title="Microsoft JVM"></a>Microsoft JVM</h2><ul><li>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM</li><li>只能在windows平台运行，但确实是windows下性能最好的Java VM</li></ul><h2 id="TaobaoJVM"><a href="#TaobaoJVM" class="headerlink" title="TaobaoJVM"></a>TaobaoJVM</h2><ul><li>基于 openJDK 开发了自己定制版本的 AlibabaJDK</li></ul><h2 id="Graal-VM"><a href="#Graal-VM" class="headerlink" title="Graal VM"></a>Graal VM</h2><ul><li>2018年4月，oracle Labs公开了Graal VM，号称”Run Programs Faster Anywhere”</li><li>Graal VM在HotSpot VM基础上增强而成的<strong>跨语言全栈虚拟机</strong>，<strong>可以作为“任何语言”的运行平台使用</strong>，包括：Java、Scala、Groovy、Kotlin、C、C++、JS、Python等</li><li>如果说HotSpot有一天真的被取代，Graal VM希望最大</li></ul><blockquote><p>名称后带*的即为当前三大Java虚拟机</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Crafting Interpreters -  A Map of the Territory</title>
    <link href="/2020/06/04/Crafting%20Interpreters-%5B2%5D/"/>
    <url>/2020/06/04/Crafting%20Interpreters-%5B2%5D/</url>
    
    <content type="html"><![CDATA[<h1 id="Crafting-Interpreters-1-2-A-Map-of-the-Territory"><a href="#Crafting-Interpreters-1-2-A-Map-of-the-Territory" class="headerlink" title="Crafting Interpreters - [1-2] A Map of the Territory"></a>Crafting Interpreters - [1-2] A Map of the Territory</h1><blockquote><p>你一定要有一副地图，否则在这个世界里你只能像无头苍蝇般。在《指环王》中，我从未让任何人在某一天走得超过他的极限。</p><p>​    - J.R.R.Tolkien</p></blockquote><p>我们不想像无头苍蝇一般，所以在我们动身之前，一起来看看语言实现人员所描绘的领域。它将帮助我们了解我们要去哪里</p><p>首先，让我来速记一下。这本书的大部分内容是关于一种语言的实现，它以某种柏拉图式的理想形式不同于语言本身。像堆栈、字节码和递归下行这样的东西，是一个特定实现可能会用到的具体细节。从用户的角度来看，只要产生的新语言遵循语言的规范，其就是所有的实现细节。</p><p>我们将在这些细节上花费大量时间，因此，如果我每次提到它们时都要写“语言实现”，那对我来说太痛苦了，手都会敲疼。 取而代之的是，除非区别不明显，否则我将使用“语言”来指代一种语言或一种语言的实现，或同时使用这两种语言。</p><h2 id="2-1-语言的组成部分"><a href="#2-1-语言的组成部分" class="headerlink" title="2.1 语言的组成部分"></a>2.1 语言的组成部分</h2><p>自从计算机的黑暗时代以来，工程师们就一直在构建编程语言。我发现很有趣的一点是，尽管今天的机器确实比现在快了一百万倍，存储空间也比现在大了一个数量级，但我们构建编程语言的方式几乎没有改变。</p><p> 并非每种语言都采用完全相同的路径（有些采用一种或两种捷径），但是令人难以置信的是，它们与从后海军上将Grace Hopper的第一个COBOL编译器一直到某些新的流行的JavaScript转换语言都很相似（其“文档”在某个Git存储库中完全由一个未经编辑的README文件组）。</p><p>我将实现可以选择的路径网络可视化为爬山。你从程序作为原始源文本的底部开始（其实就是一串字符）。每个阶段都分析程序，并将其转换为更高层次的表示，这样作者想要计算机做的语义就变得更加明显。</p><p>最终我们到达了顶峰。我们对用户的程序有一个鸟瞰，可以看到他们（语言开发人员）代码的意思。接下来，我们下到山的另一边。我们从这个最高级别的表示转换到一个接一个的低级别的形式，以便越来越接近我们知道如何让CPU实际执行的东西。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200604175305.png"></p><p>让我们跟踪每一个轨迹和感兴趣的点。我们的旅程将会从下面一句简单的用户源码文本开始。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200604175440.png"></p><h3 id="2-1-1-扫描"><a href="#2-1-1-扫描" class="headerlink" title="2.1.1 扫描"></a>2.1.1 扫描</h3><p>第一步是扫描，也称为lexing（语法分析），或者(如果你想给某人留下深刻印象)lexical analysis（同语法分析，但是换了种表达方式）。它们的意思都差不多。我喜欢用lexing，因为它听起来像一个邪恶的超级恶棍会做的事情，但我将使用扫描，因为它似乎更贴近平常一些。</p><p>扫描器(或lexer)接受线性的字符流，并将它们块成一系列更类似于单词的东西。在编程语言中，这些词中的每一个都称为标记。有些标记是单个字符，如 <strong>(</strong> 和 <strong>，)</strong> 。其他可能是几个字符长，比如数字 <strong>(123)</strong> 、字符串常量 <strong>(“hi!”)</strong> 和标识符 <strong>(min)</strong> 。</p><p>源文件中的一些字符实际上并没有释义。空格通常是无关紧要的，而注释则被语言所忽略。扫描器通常会丢弃这些标记，只留下一系列有意义的标记。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200604180106.png"></p><h3 id="2-1-2-解析"><a href="#2-1-2-解析" class="headerlink" title="2.1.2 解析"></a>2.1.2 解析</h3><p>下一步是解析。这就是我们的语法能够从较小的部分组成较大的表达式和语句的地方。你在英语课上解释过句子吗？如果是这样，那么你做的和解析器所做的工作一样，只不过英语有成千上万的关键字和大量的歧义。编程语言要简单得多。</p><p>解析器接受标记的平面序列，并构建反映语法嵌套性质的树结构。这些树有两个不同的名称，解析树或抽象语法树，取决于它们与源语言的纯语法结构有多接近。在实践中，语言研究者通常称它们为语法树、ast，或者通常只是树。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200604180344.png"></p><p>解析在计算机科学中有着悠久而丰富的历史，它与人工智能社区有着密切的联系。今天用于解析编程语言的许多技术最初都是由试图让计算机与我们对话的人工智能研究人员设想用来解析人类语言的。</p><p>事实证明，对于那些解析器能够处理的严格语法来说，人类语言太过混乱，但它们非常适合编程语言的更简单的人工语法。我们这些有缺陷的人仍然不能正确地使用这些简单的语法，因此解析器的工作还包括通过报告语法错误来告诉我们。</p><h3 id="2-1-3-静态分析"><a href="#2-1-3-静态分析" class="headerlink" title="2.1.3 静态分析"></a>2.1.3 静态分析</h3><p>前两个阶段在所有实现中都非常相似。现在，每种语言的各自特点开始发挥作用。现在，我们知道了代码的句法结构，比如运算符优先级和表达式嵌套，但除此之外，我们所了解的就不多了。</p><p>在a + b这样的表达式中，我们知道我们是在加上a和b，但我们不知道这些名字指的是什么。它们是局部变量吗？或全局变量？它们在哪里定义的？</p><p>大多数语言做的第一个分析称为绑定或解析。对于每个标识符，我们找出该名称的定义位置，并将两者连接在一起。这就是作用域发挥作用的地方——源代码的区域，在这里可以使用某个名称来引用某个声明。</p><p>如果语言是静态类型的，这就是我们进行类型检查的时候。一旦我们知道a和b在哪里声明，我们还可以找出它们的类型。然后，如果这些类型不支持相互添加，我们报告一个类型错误。</p><p>深呼吸一下。我们已经快到顶了，对用户程序有了全面的了解。所有这些通过分析可见的语义分析都需要存储在某个地方。有几个地方我们可以把它储存起来：</p><ul><li>通常，它作为语法树本身的属性被存储回节点中的额外字段，这些字段在解析期间没有初始化，但稍后会填充。</li><li>其他时候，我们可能将数据存储在一个查找表的一边。通常，这个表的键是变量的标识符、名称和声明。在这种情况下，我们称之为符号表，它与每个键关联的值告诉我们标识符指的是什么。</li><li>更加厉害的方法是将树转换为一个全新的数据结构，更直接地表达代码的语义。这是下一部分。</li></ul><p>到此为止的所有内容都被认为是实现的前端。你可能会猜这之后的一切都是后端，但不是。在以前，当前端和后端都被创造出来的时候，编译器要简单得多。后来，研究人员发明了新的阶段，在两半之间填充。William Wulf和他的同事并没有抛弃旧的术语，而是将它们集中到一个迷人但空间上自相矛盾的名称“中端”。</p><h3 id="2-1-4-代码的中间表示"><a href="#2-1-4-代码的中间表示" class="headerlink" title="2.1.4 代码的中间表示"></a>2.1.4 代码的中间表示</h3><p>你可以将编译器看作是一个管道，其中每个阶段的工作是组织代码，使下一个阶段更容易实现。管道的前端与用户正在编程的源语言有关。后端与代码将运行的最终架构有关。</p><p>在前后端中间，代码可以存储在一些中间表示(或IR)中，这些表示与源代码或目标码(因此是中间表示形式)没有紧密联系。相反，IR充当这两种语言之间的接口。</p><p>这使你可以更轻松地支持多种源语言和目标平台。假设你想实现Pascal, C和Fortran编译器，使其针对x86, ARM，还有SPARC等运行。通常，完成这些你要注册编写9个完整的编译器:Pascal –&gt; x86、C —&gt; ARM和每一个其他的组合。</p><p>共享的中间表示专门用来解决这种问题。你为每一种源语言编写一个前端，使其转化为中间表示。然后每个目标架构都有一个后端，用来将中间表示再进行编译和运行。于是你只需要针对前端与后端分别编写代码转换器，前端代码转换为中间表示形式，然后中间表示再通过后端编译器转化为后端可以运行的代码。</p><h3 id="2-1-5-优化"><a href="#2-1-5-优化" class="headerlink" title="2.1.5 优化"></a>2.1.5 优化</h3><p>一旦我们理解了用户程序的所要做的事情，我们就可以用一个表达方式来替换它，这个表达方式有相同的语义，但是实现起来更高效，我们可以优化它。一个简单的例子是常数折叠:如果某个表达式总是计算出完全相同的值，我们可以在编译时执行计算，并用表达式的结果替换表达式的代码。如果用户输入</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pennyArea</span> = <span class="hljs-number">3</span>.<span class="hljs-number">14</span> * (<span class="hljs-number">0</span>.<span class="hljs-number">75</span> / <span class="hljs-number">2</span>) * (<span class="hljs-number">0</span>.<span class="hljs-number">75</span> / <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>我们可以将其转换为另一种表达方式：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">pennyArea</span> = <span class="hljs-number">0.4417860938</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>上面两个语句虽然意思相同，但是明显第二种表达方式的效率更高，避免了重复的计算来消耗计算机资源。</p><p>优化是编程语言业务的重要组成部分。许多语言研究者在这里度过了整个职业生涯，他们尽其所能地从编译器中压缩性能，以使他们的基准测试速度提高几分之一。</p><p>在这本书里，我们多半要跳过这个部分。许多成功的语言很少有编译时优化。例如，Lua和CPython生成的代码相对没有优化，它们的性能工作主要集中在”运行时“上。</p><h3 id="2-1-6-代码生成"><a href="#2-1-6-代码生成" class="headerlink" title="2.1.6 代码生成"></a>2.1.6 代码生成</h3><p>我们已经将我们能想到的所有优化应用到用户的程序中。最后一步是将其转换为机器可以实际运行的形式。换句话说，生成的代码指的是CPU运行的类原始汇编指令，而不是人类能直观阅读的源代码。</p><p>最后，我们到了后端，从山的另一边往下走。从现在开始，我们对代码的表示变得越来越原始，就像反向进化一样，因为我们越来越接近头脑简单的机器能够理解的东西。</p><p>我们要做一个决定。我们是为真实的CPU生成指令还是为虚拟的CPU生成指令?如果我们生成真正的机器码，我们得到一个操作系统可以直接加载到芯片上的可执行文件。Native代码非常快，但是其生成过程需要大量的工作。今天的架构有成堆的指令，复杂的管道，和足够装满一架747的历史包袱。</p><p>使用用于芯片的语言也意味着你的编译器被绑定到一个特定的架构上。如果编译器的目标是x86机器码，它就不会在ARM设备上运行。回溯到60年代，在计算机架构的寒武纪大爆发期间，缺乏可移植性是一个真正的障碍。</p><p>为了解决这个问题，像马丁•理查兹(Martin Richards)和尼克劳斯•沃斯(Niklaus Wirth)这样的极客，分别以BCPL和Pascal而闻名，他们让自己的编译器生成虚拟机代码。他们不是为真正的芯片编写指令，而是为一台假想的、理想化的机器编写代码。Wirth称其为p-code，表示可移植，但今天，我们通常称其为<strong>字节码</strong>，因为每条指令通常是一个字节长。</p><h3 id="2-1-7-虚拟机"><a href="#2-1-7-虚拟机" class="headerlink" title="2.1.7 虚拟机"></a>2.1.7 虚拟机</h3><p>如果编译器生成字节码，那么工作还没有结束。由于没有芯片直接运行这种字节码，将其翻译为机械码也是我们需要做的。这种情况下，有两条路。你可以为每个目标体系结构编写一个小型的微型编译器，将字节码转换为本机代码。</p><p>或者你可以自己写一个虚拟机，一个可以在运行时，模拟支持虚拟体系结构的程序。在VM中运行字节码比提前将其转换为本机代码要慢，因为每次执行指令时都必须在运行时进行模拟。当然，你的语言就获得了简单性和可移植性。比如说，用C实现你的VM，你就可以在任何有C编译器的平台上运行你的语言。这就是我们的第二个解释器所做的。</p><h3 id="2-1-8-运行时"><a href="#2-1-8-运行时" class="headerlink" title="2.1.8 运行时"></a>2.1.8 运行时</h3><p>我们终于将用户程序转换到了我们可以运行的形式。最后一步那就是运行。如果我们将其编译成机器码，我们只需告诉操作系统加载可执行文件，然后运行。如果我们将它编译成字节码，我们需要启动VM并将程序加载到其中。</p><p>在这两种情况下，除了最基本的低级语言之外，我们通常需要在程序运行时需要一些语言支持的服务。例如，如果语言自动管理内存，我们需要一个垃圾收集器来回收未使用的内存。如果我们的语言支持测试实例，那么我们需要一些数据来跟踪每个对象在执行期间的类型。</p><p>所有这些都是在运行时进行的，所以它叫做运行时。在完全编译的语言中，实现运行时的代码将直接插入到结果可执行文件中。例如，在Go中，每个编译后的应用程序都有自己的Go运行时副本直接嵌入其中。这就是Java、Python和JavaScript等语言的大多数实现的工作方式。</p><h2 id="2-2-捷径与替换的线路"><a href="#2-2-捷径与替换的线路" class="headerlink" title="2.2 捷径与替换的线路"></a>2.2 捷径与替换的线路</h2><p>这是一条涵盖你可能实现的每一个阶段的漫长道路。许多语言都有对应完整的实现，但也有一些捷径和替代路径。</p><h3 id="2-2-1-单遍编译器"><a href="#2-2-1-单遍编译器" class="headerlink" title="2.2.1 单遍编译器"></a>2.2.1 单遍编译器</h3><p>一些简单的编译器将解析、分析和代码生成交织在一起，因此它们直接在解析器中生成输出代码，而不分配任何语法树或其他IRs。这些单遍编译器限制了语言的设计。这些语言没有中间数据结构来存储关于程序的全局信息，而且也不会重新访问代码中以前解析过的任何部分。这意味着只要对于一个表达式，在编译的时候，必须要有足够的信息，而只用将其编译一次就通过。</p><p>Pascal和C就是遵循该规定的语言。当时，内存是如此珍贵，以至于编译器甚至不能在内存中保存整个源文件，更不用说整个程序了。这就是为什么Pascal类语法要求类型声明首先出现在块中。这同时也是为什么在C语言中，你不能在定义函数的代码之上调用函数，除非你有一个显式的前向声明，告诉编译器它需要知道什么来生成调用后一个函数的代码。</p><h3 id="2-2-2-树遍历解释器"><a href="#2-2-2-树遍历解释器" class="headerlink" title="2.2.2 树遍历解释器"></a>2.2.2 树遍历解释器</h3><p>一些编程语言在将代码解释为AST后，便开始执行代码（可能也会附带一些静态分析）。这些语言遍历了语法树的每一个分支和叶子，评估每一个遍历走过的节点，以使程序运行起来。</p><p>这种解释器风格在学生项目和小众语言中很常见，但在通用语言中并不广泛使用，因为它往往比较慢。一个值得注意的例外是Ruby的原始实现，在版本1.9之前它是一个树漫步器。</p><p>有些人使用“解释器”来表示这些类型的实现，但其他人对这个词的定义更为普遍，因此我将使用无可争议的显式树遍历解释器来指代这些实现。我们的第一个解释器是采用的就是这种树遍历解释器。</p><h3 id="2-2-3-Transpiler-转编器"><a href="#2-2-3-Transpiler-转编器" class="headerlink" title="2.2.3 Transpiler 转编器"></a>2.2.3 Transpiler 转编器</h3><p>为一种语言编写完整的后端可能需要大量的工作。如果你有一些现有的通用IR目标，你可以把你的前端绑在它上面。否则，接下来的进展就不好继续下去。但是，如果将其他源语言视为中间表示会怎样呢？</p><p>我们为我们的语言编写一个前端。然后，在后端，我们无需做将该中间表示转化为机械码的工作，而是转化为和我们语言同样高级的语言的代码。然后，我们使用该语言现有的编译工具，作为我们从山顶吓到山脚的路。</p><p>他们过去称其为源到源编译器或转编译器。在编译成JavaScript以便在浏览器中运行的语言兴起之后，便出现了新词“transpiler”。</p><p>第一个转编译器将一种汇编语言翻译成另一种汇编语言，而今天，几乎所有的转编译器都在高级语言上工作。在UNIX流行于各种各样的机器后，开始了产生C作为输出语言的编译器的长期传统。只要有UNIX，就可以使用C编译器并生成高效的代码，因此以C为目标是让语言在许多体系结构上运行的好方法。</p><p>Web浏览器可以说是当今人们用的最多的软件，若将其比喻成操作系统，那它的机器代码就是JavaScript，所以现在几乎所有的语言都有一个针对JS的编译器，显而易见是为了是让代码在浏览器中运行。</p><p>转编器的前端扫描器和解析器看起来像其他语言的编译器。如果我们的语言只是目标语言上的一个简单的语法外壳，那么它可以完全跳过分析，直接输出目标语言中的类似语法。</p><p>如果这两种语言在语义上不是很相同，那么我们将看到完整编译器更多典型的阶段，包括分析甚至优化。然后在代码生成方面，我们的语言不是输出一些二进制语言(如机器代码)，而是生成目标语言的代码。</p><p>无论采用哪种方式，我们都可以通过输出语言的现有编译器运行结果代码，这样就算打到我们的目的了。</p><h3 id="2-2-4-即时编译"><a href="#2-2-4-即时编译" class="headerlink" title="2.2.4 即时编译"></a>2.2.4 即时编译</h3><p>最后一条不是我们所想像的捷径，相反，其很具有挑战性。执行代码的最快方法是将其编译为机器码，但是我们可能不知道最终用户的机器支持什么体系结构。那么我们该怎么做呢？</p><p>我们可以学习一下HotSpot JVM、Microsoft s CLR和大多数JavaScript解释器的做法。在最终用户的机器上，当程序以JS的形式从源代码加载时，或者以JVM和CLR的独立于平台的字节码加载时，其可以将其编译为本机架构支持的代码形式，以满足不同系统都可以运行的需求（Java曾经的宣传口号就是“write once，run anywhere”，即一次性开发完后，在不同系统上都可以直接运行）。这就是即时编译。大家基本都用JIT来简称Just-in-time。</p><p>最复杂的jit会插入分析挂钩到生成的代码中，以查看哪些区域对性能最关键，以及哪些数据流经这些区域。然后，随着时间的推移，它们将通过更高级的优化自动重新编译那些热点。</p><h2 id="2-3-Compilers-and-Interpreters-编译器与解释器"><a href="#2-3-Compilers-and-Interpreters-编译器与解释器" class="headerlink" title="2.3 Compilers and Interpreters 编译器与解释器"></a>2.3 Compilers and Interpreters 编译器与解释器</h2><p>到目前为止，我们已经解除了大量编程语言术语，且面临了一个自古以来一直困扰程序员的问题：编译器和解释器之间有什么区别?</p><p>这就像问水果和蔬菜的区别一样。这似乎是一个非此即彼的选择，但实际上水果也是一个植物，而蔬菜也能生吃。一个并不意味着否定另一个。有非蔬菜的水果(苹果)和非水果的蔬菜(胡萝卜)，但也有可食用的植物，既是水果又是蔬菜，就像我们常吃的西红柿。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200611211822.png"></p><p>我们回到语言上：</p><ul><li><p>编译是一种实现技术，涉及到将源语言转换为其他一些通常较低级别的形式。当我们的语言生成字节码或机器码时，就是在进行编译。当转换到另一种高级语言时，还是在编译。</p></li><li><p>当我们说语言实现是一个编译器时，我们的意思是它将源代码翻译成其他形式，但不执行它。用户必须获得结果输出并自己运行它。</p></li><li><p>相反，当我们说实现是解释器时，我们的意思是它接受源代码并立即执行它。它从源代码开始，直接运行程序。</p></li></ul><p>就像苹果和橘子一样，有些实现显然是编译器而不是解释器。GCC和Clang将C代码编译成机器码。最终直接运行该可执行文件，用户可能不会甚至不用不知道使用了哪个工具来编译它。C语言的编译器就是这样的。</p><p>在较老版本的Matz规范Ruby实现中，用户从源代码运行Ruby。该实现不仅解析源代码，害通过遍历语法树直接运行它。源代码在语言内部或者以任何用户可见的形式，没有被编译、解释。所以这绝对是Ruby的一个解释器。</p><p>但是CPython呢？当使用它运行Python程序时，代码将被解析并转换为内部字节码格式，然后在VM中执行。从用户的角度来看，这显然是一个从源代码运行程序的解释器。但是你会发现CPython也有编译的过程。那CPython到底算什么呢？</p><p>答案是它两者都有，两者都算。CPython是一个解释器，但它也有一个编译器。在实践中大多数脚本语言都是这样工作的，下图可见：</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200611213227.png" alt="A Venn diagram of compilers and interpreters"></p><p>我们的第二个解释器就术语中心的重叠区域的范围，因为它在内部编译成字节码。因此，虽然这本书名义上是关于解释器的，但我们也将涉及一些汇编。</p><h2 id="2-4-我们的愉（shou）快（ku）之旅"><a href="#2-4-我们的愉（shou）快（ku）之旅" class="headerlink" title="2.4 我们的愉（shou）快（ku）之旅"></a>2.4 我们的愉（shou）快（ku）之旅</h2><p>一次要消化的东西太多了。但不用担心，这一章不期望你理解所有这些部分和内容。我只是想让你们知道它们是存在的以及了解一下它们是如何结合在一起的。</p><p>当我们想探索超越这本书中范围内的道路和领域时，这份地图也对我们很有帮助。我想让你渴望着自己去闯一闯，漫游这座技术大山中的每个地方。</p><p>但是，现在是时候开始我们自己的旅程了。系紧你的鞋带，收起你的背包，一起走吧。从现在开始，你所需要关注的就是你面前的路。</p><blockquote><p>原文链接：<a href="https://www.craftinginterpreters.com/introduction.html">Introduction</a></p><p>阅读并翻译者：Javen Liu</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Crafting Interpreters</category>
      
    </categories>
    
    
    <tags>
      
      <tag>解释器</tag>
      
      <tag>外文书籍</tag>
      
      <tag>Crafting Interpreters</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Crafting Interpreters -  Introduction</title>
    <link href="/2020/06/03/Crafting%20Interpreters-%5B1%5D/"/>
    <url>/2020/06/03/Crafting%20Interpreters-%5B1%5D/</url>
    
    <content type="html"><![CDATA[<h1 id="Crafting-Interpreters-1-1-Introduction"><a href="#Crafting-Interpreters-1-1-Introduction" class="headerlink" title="Crafting Interpreters - [1-1] Introduction"></a>Crafting Interpreters - [1-1] Introduction</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>童话故事比事实更有用，不是因为故事告诉我们龙存在，而是因为这些故事让我们明白，龙是可以被打败的</p><p>​                                                                                                                                    - Neil Gaiman, Coraline</p></blockquote><p>我非常高兴我们可以一起走进这一段旅程。这是一本关于实现编程语言解释器的数；同时是一本关于设计一门值得实现的语言的书；也是一本我希望我在第一次接触到编程语言时就有的书；更是一本在将近十年里写在我脑子中的一本书。</p><p>在这本书中，我们将要一步步地走进两个功能齐全的语言解释器。我假设这是你第一次涉足语言，所以我会介绍构建完整、可用、快速语言实现所需的每个概念和代码行。</p><p>为了将两个语言解释器放入到一本书中，并不使其成为《XXX从入门到放弃》（笑），这些语言词汇在概念上会比其他的书要更加浅显一些。在我们构建这个系统的每一块时，我都会介绍其背后的历史和概念。我会尝试带你熟悉这些词汇术语，这样，当你参加全是编程语言研究人员的party时，你会很自然地混入其中，当（至少装作）大佬。</p><p>但我们很大概率会绞尽脑汁地理解这些，以让我们的语言活起来，跑起来。这并不是说理论不重要，当学习一门语言时，能够准确且正式地推理语法和语义是一项很重要的技能。但是我个人还是在实践中学的最快（me too），对我来说理解充满了抽象概念的书本并吸收它实在太hard了。但是当我码了些东西，让它运行起来，并debug它，慢慢地我就开始理解并get到点了。</p><p>对于读者们，这就是我的目标。我希望你在阶数这段旅程时，可以带着明白一个真正的语言如何生存和呼吸（就是如何构成，运作）离开。我的愿望也是当你去阅读其他更加理论、专业的书籍时，那里的概念将牢牢地粘在你的脑海里，粘在这个有形的基础上。</p><h2 id="1-1-为什么学习这些东西？"><a href="#1-1-为什么学习这些东西？" class="headerlink" title="1.1 为什么学习这些东西？"></a>1.1 为什么学习这些东西？</h2><p>似乎每一本关于编程语言书的简介都有这部分，我不知道是什么编程语言导致了这种存在性的怀疑。同样我也不认为关于鸟类学的书担心证明其存在的合理性。他们假设读者喜欢鸟儿并且开始行动。</p><p>但是编程语言则有点不一样。我想，我们创造出一种广泛成功的通用编程语言的可能性是很小的。世界上广泛使用的语言的设计者们可以在一辆大众汽车上安装这些语言，甚至不需要把蓬顶帐篷竖起来。如果加入精英团体是学习一门编程语言的唯一理由，那就很难说了。但幸运的是，并不是这样的。</p><h3 id="1-1-1-“Little-Language”到处都是"><a href="#1-1-1-“Little-Language”到处都是" class="headerlink" title="1.1.1 “Little Language”到处都是"></a>1.1.1 “Little Language”到处都是</h3><p>每一种成功的通用语言背后，都有上千种成功的小众语言。我们习惯称他们是“Little Language”（小众语言？），但是，术语经济中的通货膨胀导致了今天的名称领域特定的语言。这些是为特定任务定制的pidgins。比如应用程序脚本语言、模板引擎、标记格式和配置文件。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200603214600.png"></p><p>几乎每个大型软件工程都需要很多这些小语言。当你有选择时，使用已经存在的语言比你自己造一个语言要更容易些。一旦你将文档、调试器、编辑器支持、语法高亮和所以的其他问题考虑进来时，自己造一个语言轮子简直是难得有些离谱。</p><p>但是自己造轮子还是有些好处的，尤其是当你发现你需要一个解析器或者满足你需求的东西不存在时，甚至就算有可以重用的，你也不可避免的要去调试和维护，并对其进行深入的研究。</p><h3 id="1-1-2-语言是很好的实践"><a href="#1-1-2-语言是很好的实践" class="headerlink" title="1.1.2 语言是很好的实践"></a>1.1.2 语言是很好的实践</h3><p>长跑选手们有时在膝盖上添加负重来进行负重训练或者到海拔高度很高、大气层稀薄的地方进行训练。当他们不再有这些限制他们的条条框框时，在轻装上阵并且氧气充足的地方时，他们能跑的比以前更快。</p><p>实现一个语言是对编程能力的一大考验，代码很复杂，表现性能也很关键。你必须掌握递归、动态数组、树、图、哈希表这些知识。你可能每天都至少会用到一次哈希表，但你真的理解哈希表以及其内部的原理吗？不过，当我们从头开始制作这些之后，我保证你能懂的。</p><p>虽然我试图想表达编程语言并不像你想象的那样困难，但它对于每个人来说仍然是个挑战。面对它，你会成为一个更加强大的程序员，并能更加聪明地在日常生活中使用数据结构和算法。</p><h3 id="1-1-3-最后一个理由"><a href="#1-1-3-最后一个理由" class="headerlink" title="1.1.3 最后一个理由"></a>1.1.3 最后一个理由</h3><p>最后一个理由虽然我不想承认，但是它确实是我所想的。当我还是一个孩子的时候，我认为编程语言非常的神奇。当我第一次按一个键打开BASIC程序时，我无法想象BASIC本身是如何形成的。</p><p>后来，我的大学朋友们在提到他们的编译器课程时，既敬畏又恐惧，这足以让我相信语言黑客（或者说研究这些计算机编程语言的人）是另一种人类（不做人）。某些巫师被授予接触神秘艺术的特权！</p><p>这是一个迷人的形象，但也有黑暗的一面。我觉得自己不像个巫师，所以我觉得自己缺乏加入阴谋集团所必需的与生俱来的品质。虽然从我在笔记本上乱涂乱画关键词开始，我就对语言着迷了，但我还是花了几十年的时间才鼓起勇气去真正地学习它们。那种不可思议的特质，那种排他感，把我拒之门外。</p><p>当我最终开始拼凑我自己的小解释器时，我很快就明白了，根本没有什么魔法。它只是代码，而破解语言的人只是人。</p><p>有一些技术是你在语言之外不常遇到的，而且有些部分有些困难。但并不比你所克服的其他障碍更难。我希望，如果你对语言感到恐惧，这本书可以帮助你克服这种恐惧，也许我会让你比以前更勇敢一点。</p><p>谁知道呢，或许你就可以创造出下一个伟大的语言！一定会有人做到的</p><h2 id="1-2-这本书的构成"><a href="#1-2-这本书的构成" class="headerlink" title="1.2 这本书的构成"></a>1.2 这本书的构成</h2><p>这本书分为了三个部分，而你正在读的就是第一部分。我用了几章来引导你，教你一些黑客（神仙）使用的行话，并向您介绍Lox，我们将实现的语言。</p><p>其他两个部分分别构建了一个完整的LOX解释器。在这些部分中，每个章节的结构都是一样的。每一个都完成了一个单一的功能，告诉你其中的概念，并带你走过其实现的每一步。在我这方面，我花了不少时间反复试验，但我还是成功地将两个解释器分割成章节大小的块，这样每个解释器都可以在前面的解释器的基础上进行构建。从第一章开始，你就会有一个可以运行和玩的程序。随着每一个章节的结束，它的功能会越来越丰富，直到你最终完成了一门完整的语言。</p><p>除了丰富的，闪烁的英语散文，章节有其他一些愉快的方面：</p><h3 id="1-2-1-The-code（代码）"><a href="#1-2-1-The-code（代码）" class="headerlink" title="1.2.1 The code（代码）"></a>1.2.1 The code（代码）</h3><p>我们是关于制作解释器的，所以这本书包含了真正的代码。需要的每一行代码都包括在内，并且每个代码片段都告诉你在不断增长的实现中插入代码的位置。</p><p>许多其他的语言书籍和语言实现都使用Lex和Yacc这样的工具，编译器-编译器自动地从一些更高级的描述生成一些实现的源文件。这类工具有利有弊，有些人可能会说双方都有强烈的宗教信仰。</p><p>我们将拒绝使用这些工具。我希望的是确保没有魔法和困惑所藏匿的黑暗角落存在，所以我们将完全靠自己手把手地写出所有东西。如你所见，似乎并听起来没有那么糟糕，并且意味着你将明白代码中每一行的意思，理解每个解释器如何工作的。</p><p>一本书有不同于现实世界的约束，因此这里的编码风格可能并不总是反映编写可维护的生产软件的最佳方式。如果我对省略private或声明全局变量显得有些漫不经心，请理解我这样做是为了让你更容易地理解代码。这里的页面没有IDE那么宽，每个字符都很重要。</p><p>另外，该代码没有太多注释。 那是因为每一行都由几段诚实到上帝的散文来解释。 当你编写一本书以伴随您的程序时，也欢迎你省略评论。 否则，你应该比我多使用//（注释）。</p><p>本书没有包含编译和运行代码所需的机制。我假设你可以在您选择的IDE中拼凑一个makefile或一个项目，以便让代码运行。</p><h3 id="1-2-2-小片段"><a href="#1-2-2-小片段" class="headerlink" title="1.2.2 小片段"></a>1.2.2 小片段</h3><p>由于该书包含了实现所需的每一行代码，所以代码片段非常精确。此外，即使解释器已经实现了一半，但我为了试图保持程序处于可运行状态，所以添加临时代码，这些代码将在以后的代码片段中替换。</p><p>包含所有附加功能的代码片段是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">if</span> (isDigit(c)) &#123;<br>        number();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Lox.error(line, <span class="hljs-string">&quot;Unexpected character.&quot;</span>);<br>    &#125;<br><span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>在中间，你可以在这个代码片段中添加新代码。它可能会在上面或下面有一些淡出的行，向你显示在现有代码中插入它的位置。还有一个小的简介告诉你文件的位置。如果它说的是替换行，那么在褪色的行之间有一些先前的代码，你需要用这个代码片段来删除和替换。</p><h3 id="1-2-3-此外"><a href="#1-2-3-此外" class="headerlink" title="1.2.3 此外"></a>1.2.3 此外</h3><p>除此之外，还包括生平简介，历史背景，相关主题的参考文献，以及其他领域的探索建议。书中没有什么内容是你需要知道这些生平简介之类的才能理解的，所以你可以跳过它们。我不会多说别的，但是跳过这些我可能会有点难过和失望的。</p><h3 id="1-2-4-挑战"><a href="#1-2-4-挑战" class="headerlink" title="1.2.4 挑战"></a>1.2.4 挑战</h3><p>每一章节结尾都会有少许练习。不像教科书上的习题集，它倾向于重述你已经学过的内容那样，这些练习是为了帮助你学到比这一章更多的东西。它们迫使你离开规划好的线路，让你自己去探索，会让你研究其他语言，弄清楚如何实现特性，或者让你自己去创造。</p><p>战胜他们，你会对他们有更广泛的了解，可能还会遇到一些磕磕碰碰。如果你想待在旅游巴士舒适的范围内，也可以跳过它们。这是你的书，所以你来决定。</p><h3 id="1-2-5-设计笔记"><a href="#1-2-5-设计笔记" class="headerlink" title="1.2.5 设计笔记"></a>1.2.5 设计笔记</h3><p>大多数编程语言书籍都是严格意义上的编程语言实现书籍。他们很少讨论如何设计正在实现的语言。实现非常有趣，因为它的定义非常精确。我们程序员似乎对黑与白、1与0有一种亲和感（同感）。</p><p>就我个人而言，我认为世界只需要这么多fortran77的实现。有时候，你会发现自己在设计一种新的语言。一旦你开始玩这个有趣的游戏，那么等式中更温和、更人性化的一面就变得至关重要。比如什么功能容易学习，如何平衡创新和熟悉度，什么语法更容易读，对谁更容易。</p><p>所有这些都深刻地影响着你的新语言的成功。我希望你们的语言能够成功，所以在一些章节中，我以一个设计笔记，一篇关于编程语言的人性方面的小短文作为结尾。我不是这方面的专家，我不知道是否有人真的是这样的，所以要对这些持保留态度。这应该会让它们成为更美味的精神食粮，这是我的主要目标。</p><h2 id="1-3-第一个解释器"><a href="#1-3-第一个解释器" class="headerlink" title="1.3 第一个解释器"></a>1.3 第一个解释器</h2><p>我们将用Java编写第一个解释器jlox。 重点是概念。 我们将编写最简单，最简洁的代码，以正确实现该语言的语义。 这将使我们熟悉基本技术，并磨练对语言的确切理解。</p><p>Java是一种很棒的语言。 因为其是高级语言，为我们屏蔽了底层原理，所以我们不会被繁琐的实施细节所淹没。 与脚本语言不同的是，它的底层没有那么神奇，你可以使用静态类型来查看正在处理的数据结构</p><p>我还特意选择了它，因为它是一种面向对象的语言。这种模式在90年代席卷了编程界，现在是数百万程序员的主要思维方式。很有可能你已经习惯了把东西组织成类和方法，所以我们会让你保持舒适区。</p><p>尽管学术语言人员有时会鄙视面向对象的语言，但事实是，它们甚至被广泛用于语言工作。 与大多数JavaScript虚拟机一样，GCC和LLVM用C ++编写。 面向对象的语言无处不在，并且针对该语言的工具和编译器通常使用相同的语言编写。</p><p>最后，Java非常流行。这意味着很有可能你已经知道了，所以在书中你需要学习的东西就少了。如果你对Java不是很熟悉，不要惊慌。我尽量保持它的最小子集。我使用Java 7中的diamond操作符使事情更简洁一些，但这就是高级特性的全部内容。如果你了解另一种面向对象的语言，如c#或c++，你可能会应付得很好。</p><p>在第2部分结束时，我们将有一个简单的、可读的实现。我们还没有实现的只是其运行更快的版本。它也依赖于Java虚拟机的运行时功能，但是我们想了解Java本身是如何实现这些功能的。</p><h2 id="1-4-第二个解释器"><a href="#1-4-第二个解释器" class="headerlink" title="1.4 第二个解释器"></a>1.4 第二个解释器</h2><p>所以在下一部分中，我们将重新开始，但这次是用C语言，C语言是理解实现如何真正工作的最佳语言，一直到内存中的字节和流经CPU的代码。</p><p>我们使用C的一个重要原因是这样我可以向你展示C特别擅长的东西，但这确实意味着你需要非常熟练地使用它。你不必成为丹尼斯·里奇的转世，但你也不应该被指针吓到。</p><blockquote><p>ps：丹尼斯·里奇，Dennis Ritchie，c语言之父，UNIX之父，其与布莱恩·科尔尼干（Brian W. Kernighan）一起出版了名著《C程序设计语言（The C Programming Language）》，被誉为C语言的圣经。</p></blockquote><p>如果你还没到那一步，拿起一本关于C语言的入门书，细细咀嚼，读完后再回到这里。作为回报，你会通过这本书中变成一个更强的C程序员。考虑到Lua、CPython和Ruby s MRI等很多语言实现是用C语言编写的，所以学习这是很有用。</p><p>在我们的C解释器clox中，我们被迫自己实现Java免费提供给我们的所有东西。我们将编写自己的动态数组和哈希表。我们将决定对象在内存中是如何表示的，并构建一个垃圾收集器来回收它。</p><p>我们的Java实现关注的是正确，即跑起来即可。现在我们已经完成了那一步，我们将转向实现更快速的版本。我们的C解释器将包含一个编译器，编译器将代码转换为高效的字节码表示(不用担心，我们很快就会进入了解是什么意思)，然后执行。Lua、Python、Ruby、PHP和许多其他成功语言的实现都使用了相同的技术。</p><p>我们甚至会尝试基准测试和优化。到最后，我们将拥有一个健壮、准确、快速的语言解释器，能够跟上其他专业水准的实现。对于一本书和几千行代码来说，这已经很不错了。</p><h2 id="DESIGN-NOTE"><a href="#DESIGN-NOTE" class="headerlink" title="DESIGN NOTE"></a>DESIGN NOTE</h2><p>语言命名中有什么注意的地方？</p><p>编写本书时，最困难的挑战之一是为它所实现的语言起一个名字。我看了好几页的候选人名单才找到一个合适的。在开始构建自己的语言的第一天，你就会发现，命名非常困难。好名字满足下面几个条件：</p><ol><li>它没有被使用过。如果你不小心踩到别人的名字，你可能会遇到各种各样的麻烦，包括法律上的和社会上的。</li><li>它很容易发音。如果一切顺利，很多开发者都会使用并谈论你的语言名字。任何超过几个音节或几个字母的单词都会让他们烦恼不已。</li><li>它很特别，以至于可以很有区分度地让人们搜索到。人们会通过你的语言名称来找到相应的文档，所以你需要一个足够罕见的词，让搜索中大多数结果都会指向你的文档。不过，鉴于如今大多数搜索引擎都充斥着大量人工智能，这倒不是什么大问题。尽管如此，如果你给自己的语言命名为 for，那恐怕用户找一年都找不到你的文档。</li><li>它在很多文化中并没有负面的含义。这很难避免啊，但值得考虑。“Nimrod”的设计者最终将他的语言重新命名为“Nim”，因为太多的人只记得“兔八哥”用“Nimrod”作为一种侮辱。</li></ol><p>如果你的名字符合上面的条件，那就选用吧。不过不要纠结于寻找一个能够抓住你语言精髓的称谓。如果说世界上其他成功的语言教会了我们什么的话，那就是它们的名字并不重要。你所需要的只是一个合理的惟一标记。</p><blockquote><p>原文链接：<a href="https://www.craftinginterpreters.com/introduction.html">Introduction</a></p><p>阅读并翻译者：Javen Liu</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Crafting Interpreters</category>
      
    </categories>
    
    
    <tags>
      
      <tag>解释器</tag>
      
      <tag>外文书籍</tag>
      
      <tag>Crafting Interpreters</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-31 next permutation</title>
    <link href="/2020/05/12/%5Bleetcode%5D-31%20next%20permutation/"/>
    <url>/2020/05/12/%5Bleetcode%5D-31%20next%20permutation/</url>
    
    <content type="html"><![CDATA[<h1 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h1><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200602153734.png" alt="image-20200602153521952"></p><p>题目很简单，对于给定的一个数，例如125，程序需要的输出需要满足下面两点：</p><ul><li>仍然由1、2、5组成</li><li>在由1、2、5组成的数中，恰好比125大一点的数，即152</li></ul><p>其潜在的意思是将1、2、5三个数字组成的三位数，进行从小到大排列，然后获得在125后面的一个数，即152</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>如果按照最直接的想法，那就是使用回溯法，将组成输入的每一位进行拆分，然后排列组合，把所有组合的可能全部列出来。</p><p>然后对于所有的组合进行排序，放入数组或者list中，再找到原来的输入值，取其后面的数，即为输出。</p><p>同时我们可以看到，题目给的example中，特别列出了 321 -&gt; 123。意味着如果输入的数，是所有组合中最大的那个，那么输出就取所有组合中最小的值。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200602155132.png" alt="image-20200602155117882"></p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：*O(n!)*，可能的排列一共有n!个</p><p>空间复杂度：*O(n)*，需要用数组将数据储存</p><h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><p>我们观察一下数据，如果一个数，从左到右每一位上的数字都是递减的，那么该数为其组合中最大的数。毕竟数的位越高，其对于整个数大小的影响更大，就比如42和24，我们只用从最高位，就可以判断出42更大。因此一个数从左到右每一位上的数字都是递减的，其必定是最大的。</p><p>那么我们就可以得出一个结论，从最低位开始，一直向右寻找，直到找到保证从右往左一直递增的最后一位。</p><p>例如下图中 7 所在的位，即第5位，此时，我们可以保证第5位到最后第9位的数是这5个数组成的排列中，最大的数，无法找到比其更大的数（仅针对这5位）</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200602160402.png"></p><p>此时7前面的4，破坏了从右往左的递增规律。而对于 476531 来说，其后5位已经是最大的了，要想比它大，只能在最高位，也就是4所在的位进行进位。</p><p>于是我们从7开始向右开始寻找，找到了仅仅比4大一点的5，我们让5和4进行交换，然后在对后5位进行排序，使其按照从右往左递增的规则进行排列，此时产生的 <strong>576431</strong> 是 “5” 开头的数中最小的，而 <strong>476531</strong> 是以 “4” 开头的数里最大的，所以 <strong>576431</strong> 就是我们的答案，在补全前面三位，就是答案 <strong>158576431</strong></p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200602160857.png"></p><p>整个流程的动图如下，转自LeetCode</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/1df4ae7eb275ba4ab944521f99c84d782d17df804d5c15e249881bafcf106173-file_1555696082944.gif" alt="Next Permutation"></p><h3 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><p>时间复杂度：*O(n)*，在最坏的情况下，也只需要遍历数组2遍</p><p>空间复杂度：*O(1)*，无需额外空间，全部都是原地替换</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = nums.length-<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i+<span class="hljs-number">1</span>])&#123;<br>            i--;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">int</span> j = nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[j] &lt;= nums[i]) &#123;<br>                j--;<br>            &#125;<br>            swap(nums,i,j);<br>        &#125;<br>        reverse(nums,i+<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> temp = nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = temp;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> s)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> l = s, r = nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt;= r)&#123;<br>            swap(nums,l++,r--);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>会话技术</title>
    <link href="/2019/12/20/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/"/>
    <url>/2019/12/20/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h1><ol><li>会话：一次会话中包含多次请求和响应<ul><li>一次会话：浏览器第一次给服务器资源发送请求，会话建立。直到有一方断开为止</li></ul></li><li>功能：在一次会话的范围内，共享数据</li><li>方式：<ol><li>客户端会话技术：Cookie</li><li>服务器会话技术：Session</li></ol></li></ol><h2 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="1. Cookie"></a>1. Cookie</h2><h3 id="1-概念：客户端会话技术，将数据保存在客户端的技术"><a href="#1-概念：客户端会话技术，将数据保存在客户端的技术" class="headerlink" title="1.概念：客户端会话技术，将数据保存在客户端的技术"></a>1.概念：客户端会话技术，将数据保存在客户端的技术</h3><h3 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h3><ul><li>使用步骤：<ol><li>创建Cookie对象，绑定数据<ul><li>new Cookie(String name,String value)</li></ul></li><li>发送Cookie对象<ul><li>response.addCookie(Cookie cookie)</li></ul></li><li>获取Cookie对象，拿到数据<ul><li>Cookie[ ]  request.getCookie( )</li></ul></li></ol></li></ul><h3 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3.实现原理"></a>3.实现原理</h3><ul><li>基于响应头的set-cookie和请求头cookie实现</li></ul><h3 id="4-cookie的细节"><a href="#4-cookie的细节" class="headerlink" title="4.cookie的细节"></a>4.cookie的细节</h3><ol><li><p>一次可不可以发送多个cookie？</p><ul><li><strong>可以</strong> </li><li>可以创建多个Cookie对象，使用response调用多次addcookie方法发送cookie即可</li></ul></li><li><p>cookie在浏览器中保存多长时间？</p><ol><li><p>默认情况下，当浏览器关闭时，Cookie数据被销毁</p></li><li><p>持久化储存</p><ul><li>setMaxAge(int seconds)：<ol><li>正数：将Cookie数据写到硬盘的文件中。持久化存储，cookie存活时间可设置</li><li>负数：默认值，存储在内存中，浏览器关闭cookie就销毁</li><li>零：删除cookie信息</li></ol></li></ul></li></ol></li><li><p>cookie能不能存中文？</p><ul><li>在tomcat 8 之前不能（需要将中文数据转码）</li><li>在tomcat 8 之后可以</li></ul></li><li><p>cookie获取范围多大？</p><ol><li>假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？<ul><li>默认情况下cookie不能共享</li><li>setPath(String path)：设置cookie的获取范围。一般设置当前的虚拟目录</li></ul></li><li>不用的tomcat服务器间cookie共享问题？<ul><li>setDomain(String path) ：如果设置一级域名相同，那么多个服务器之间的cookie可以共享</li></ul></li></ol></li></ol><h3 id="5-cookie的特点"><a href="#5-cookie的特点" class="headerlink" title="5.cookie的特点"></a>5.cookie的特点</h3><ol><li>cookie存储数据在客户端浏览器</li><li>浏览器对于单个cookie的大小又限制，以及对同一个域名下的总cookie数量也有限制</li><li><strong>作用</strong>：<ul><li>cookie一般用于存储少量的不太敏感的数据</li><li>在不登陆的情况下保存一定的用户设置偏好</li></ul></li></ol><hr><h2 id="2-Session"><a href="#2-Session" class="headerlink" title="2. Session"></a>2. Session</h2><h3 id="1-概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession"><a href="#1-概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession" class="headerlink" title="1.概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession"></a>1.概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession</h3><h3 id="2-快速入门-1"><a href="#2-快速入门-1" class="headerlink" title="2.快速入门"></a>2.快速入门</h3><ul><li>获取HttpSession对象<ul><li>HttpSession session = request.getSession( )</li></ul></li><li>使用HttpSession对象<pre><code>* void setAttribute(String name,String value)</code></pre><ul><li>String getAttribute(String name)</li><li>void removeAttribute(String name)</li></ul></li></ul><h3 id="3-原理"><a href="#3-原理" class="headerlink" title="3.原理"></a>3.原理</h3><ul><li>Session的实现是依赖于cookie的</li></ul><h3 id="4-细节"><a href="#4-细节" class="headerlink" title="4.细节"></a>4.细节</h3><pre><code> 1. 当客户端关闭后，服务器不关闭，两次获取的Session是否为同一个？ * 默认情况下不是 * 如果需要相同，那么可以设置响应头中的cookie地址未固定值2. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？</code></pre><ul><li>不是同一个，但要确保数据不丢失<ul><li>session的钝化：<ul><li>在服务器正常关闭之前，将session对象序列化到硬盘中</li></ul></li><li>session的活化：<ul><li>在服务器启动后，将session文件转化为内存中的session对象即可</li></ul></li><li><strong>tomcat将session的钝化和活化都自动做了，虽然对象不同，但是数据还是相同的</strong></li></ul></li></ul><ol start="3"><li>session什么时候被销毁<ol><li>服务器关闭</li><li>session对象调用invalidate( )</li><li>session默认失效时间为30分钟</li></ol></li><li>session特点<ol><li>session用于存储一次会话的多次请求数据，存在服务器端</li><li>session可以存储任意类型，任意大小的数据</li></ol></li></ol><hr><h2 id="3-Sessions和Cookie的区别"><a href="#3-Sessions和Cookie的区别" class="headerlink" title="3.Sessions和Cookie的区别"></a>3.Sessions和Cookie的区别</h2><pre><code> 1. session存储数据在服务器端，cookie在客户端 2. session没有数据大小限制，cookie有 3. session数据安全，cookie相对于不安全</code></pre>]]></content>
    
    
    <categories>
      
      <category>web技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>cookie与session</tag>
      
      <tag>web技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA热部署</title>
    <link href="/2019/12/20/idea%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
    <url>/2019/12/20/idea%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="1-引入spring-devtools"><a href="#1-引入spring-devtools" class="headerlink" title="1. 引入spring-devtools"></a>1. 引入spring-devtools</h1><p>在项目的pom.xml文件中，添加spring-devtools的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>同时在其中的<build>标签的<plugins>内添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">fork</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">fork</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="2-设置idea"><a href="#2-设置idea" class="headerlink" title="2. 设置idea"></a>2. 设置idea</h1><ul><li>在File =&gt; Settings =&gt; Build, Execution, Deployment =&gt; Compiler 中勾选Build Project automatically</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200602111804.png" alt="x"></p><ul><li>快捷键 ctrl + alt + shift + /，选择Registry，勾上Compiler autoMake allow when app running</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200602111848.png"></p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200602111912.png"></p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>IDEA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java实现TCP / IP协议下的聊天室</title>
    <link href="/2019/12/20/TCP%20%20IP%E5%8D%8F%E8%AE%AE%E4%B8%8B%E7%9A%84%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    <url>/2019/12/20/TCP%20%20IP%E5%8D%8F%E8%AE%AE%E4%B8%8B%E7%9A%84%E8%81%8A%E5%A4%A9%E5%AE%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Java实现TCP-IP协议下的聊天室（运用多线程）"><a href="#Java实现TCP-IP协议下的聊天室（运用多线程）" class="headerlink" title="Java实现TCP / IP协议下的聊天室（运用多线程）"></a>Java实现TCP / IP协议下的聊天室（运用多线程）</h1><p>分为了6个文件，总共分为两个大块：其中一个为Client客户端，另一个是Server服务器端，每一个大块里分别有主运行块以及发送和接受模块，然后用多线程来实现实时的收和发</p><span id="more"></span><h1 id="Client类"><a href="#Client类" class="headerlink" title="Client类"></a>Client类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> chatApps;<br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.io.PrintStream;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.net.SocketTimeoutException;<br><span class="hljs-keyword">import</span> java.net.UnknownHostException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String IP;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> host;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Client client = <span class="hljs-keyword">new</span> Client(<span class="hljs-string">&quot;10.120.203.132&quot;</span>,<span class="hljs-number">12345</span>);<br>        client.go();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Client</span><span class="hljs-params">(String IP,<span class="hljs-keyword">int</span> host)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.IP = IP;<br>        <span class="hljs-keyword">this</span>.host = host;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">go</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Socket client = <span class="hljs-keyword">new</span> Socket(IP,host);<br><span class="hljs-comment">//            client.setSoTimeout(4000);</span><br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> CReceive(client)).start();<br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> CSend(client)).start();<br>        &#125; <span class="hljs-keyword">catch</span> (UnknownHostException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="CReceive类"><a href="#CReceive类" class="headerlink" title="CReceive类"></a>CReceive类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> chatApps;<br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.io.PrintStream;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.net.SocketTimeoutException;<br><span class="hljs-keyword">import</span> java.net.UnknownHostException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CReceive</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Socket client = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CReceive</span><span class="hljs-params">(Socket client)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.client = client;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            BufferedReader buffer = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(client.getInputStream()));<br>            String str;<br>            <span class="hljs-keyword">while</span>((str = buffer.readLine())!=<span class="hljs-keyword">null</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;The server:&quot;</span>+str);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="CSend类"><a href="#CSend类" class="headerlink" title="CSend类"></a>CSend类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">在这里插入代码片<span class="hljs-keyword">package</span> chatApps;<br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.io.PrintStream;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.net.SocketTimeoutException;<br><span class="hljs-keyword">import</span> java.net.UnknownHostException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CSend</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Socket client = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CSend</span><span class="hljs-params">(Socket client)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.client = client;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        BufferedReader input = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));<br>        <span class="hljs-keyword">try</span> &#123;<br>            PrintStream output = <span class="hljs-keyword">new</span> PrintStream(client.getOutputStream());<br>            String str;<br>            <span class="hljs-keyword">while</span>((str = input.readLine())!=<span class="hljs-keyword">null</span>)&#123;<br>                output.println(str);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Server类"><a href="#Server类" class="headerlink" title="Server类"></a>Server类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> chatApps;<br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.io.PrintStream;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.net.SocketTimeoutException;<br><span class="hljs-keyword">import</span> java.net.UnknownHostException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> host;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Server server1 = <span class="hljs-keyword">new</span> Server(<span class="hljs-number">12345</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            server1.go();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Server</span><span class="hljs-params">(<span class="hljs-keyword">int</span> host)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.host = host;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">go</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        Socket client = <span class="hljs-keyword">null</span>;<br>        ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">12345</span>);<br>        System.out.println(<span class="hljs-string">&quot;Waiting for connection...&quot;</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            client = server.accept();<br>            System.out.println(<span class="hljs-string">&quot;The connection has been established.&quot;</span>);<br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> SReceive(client)).start();<br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> SSend(client)).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="SReceive类"><a href="#SReceive类" class="headerlink" title="SReceive类"></a>SReceive类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> chatApps;<br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.io.PrintStream;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.net.SocketTimeoutException;<br><span class="hljs-keyword">import</span> java.net.UnknownHostException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SReceive</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Socket client = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SReceive</span><span class="hljs-params">(Socket client)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.client = client;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            BufferedReader buffer = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(client.getInputStream()));<br>            String str;<br>            <span class="hljs-keyword">while</span>((str = buffer.readLine())!=<span class="hljs-keyword">null</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;The client:&quot;</span>+str);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="SSend类"><a href="#SSend类" class="headerlink" title="SSend类"></a>SSend类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> chatApps;<br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.io.PrintStream;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.net.SocketTimeoutException;<br><span class="hljs-keyword">import</span> java.net.UnknownHostException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SSend</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Socket client;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SSend</span><span class="hljs-params">(Socket client)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.client = client;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        BufferedReader intput = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));<br>        <span class="hljs-keyword">try</span> &#123;<br>            PrintStream output = <span class="hljs-keyword">new</span> PrintStream(client.getOutputStream());<br>            output.println(<span class="hljs-string">&quot;The connection has been established.&quot;</span>);<br>            String str;<br>            <span class="hljs-keyword">while</span>((str = intput.readLine())!=<span class="hljs-keyword">null</span>)&#123;<br>                output.println(str);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>最终所能实现的效果就是可以服务器端与客户端之间相互交流，当然客户端所选的IP地址一定要是服务器所在的IP地址，并且服务器与客户端所选的端口必须相同</strong></p>]]></content>
    
    
    <categories>
      
      <category>实践项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>TCP/IP</tag>
      
      <tag>Demo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java设计模式】4.单件模式</title>
    <link href="/2019/12/20/%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/12/20/%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="【Java设计模式】4-单件模式"><a href="#【Java设计模式】4-单件模式" class="headerlink" title="【Java设计模式】4.单件模式"></a>【Java设计模式】4.单件模式</h1><h1 id="关于单件模式"><a href="#关于单件模式" class="headerlink" title="关于单件模式"></a>关于单件模式</h1><p>本片文章是关于单件模式的具体实现以及用法。由于该模式较为简单，在特定的场合下能起到一定的作用。并且它不像前面的几个模式，是需要在设计前思考好的一个框架，但是单件模式我个人更觉得像是一种解决方法，来解决一个潜在的问题。</p><span id="more"></span><h2 id="问题的引出"><a href="#问题的引出" class="headerlink" title="问题的引出"></a>问题的引出</h2><p>我们都知道，在软件系统比如我们正在用的Windows系统，总有那么一些变量比如注册表，它们一直存在，并且唯一，对它们之中的数据一旦进行更改，那么这个数据变化后，会一直保存该数据，直到某种特殊的场景下才会丢失。可能你会第一时间想到静态变量，没错，的确是它。</p><p>但是有一个问题，那就是静态变量经过我们编写代码后，一旦运行，静态变量会一直存在，假如这个系统过于庞大，而且你的这个设备储存又不是很大，那么后果…</p><p>没错，储存可能会不够用，虽然Java有回收机制，但是静态变量不依附于对象存在，而是依附于类，也就是说他会一直存在，即使你没有用到它。</p><p>那么有没有什么方法来让这个静态变量只在我想要它出现的时候它才出现并且起作用，而不是一开始就存在并占用内存，并且保证它只能被创建一次呢？没错，这就是单件模式所解决的问题。</p><h1 id="单件模式"><a href="#单件模式" class="headerlink" title="单件模式"></a>单件模式</h1><p>下面是一个运用了单件模式的demo，我们来看看这个”<strong>单件模式</strong>“是如何解决的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> singleton;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(uniqueInstance == <span class="hljs-keyword">null</span>)<br>            uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，既然我们不让它被反复创建，那么最好的方法就是把他的构造函数给设置成”<strong>private</strong>“类型，这样别的类就无法调用该构造函数，所以我们写了这个语句</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">Singleton</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们把构造方法给”隐藏”了，那怎样才能创建这个变量呢？我们可以使用方法来实现啊！</p><p><strong>等等！？</strong></p><p>既然我们都无法实例化这个类了，怎么调用方法?<br> 普通的类需要实例化，但是静态类里的方法是不需要实例化才能用的，可以直接依附于类使用，比如这个类写好之后，在其他的类中可以直接用</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Singleton</span>.</span></span>get<span class="hljs-constructor">Instance()</span><br></code></pre></td></tr></table></figure><p>当调用该方法时，会检测uniqueInstance变量是否为null，如果不是，就当即实例化一个对象并且赋给uniqueInstance变量，如果已经创建了，那么就跳过这一步，最后再return这个变量。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>单件模式给予我们一种处理静态变量的方法，让我们有序地管理静态变量，在我们用到静态变量时再创建，而不是在程序的一开始就创建出来。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java设计模式】1.策略模式</title>
    <link href="/2019/12/20/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/12/20/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="【Java设计模式】1-策略模式"><a href="#【Java设计模式】1-策略模式" class="headerlink" title="【Java设计模式】1.策略模式"></a>【Java设计模式】1.策略模式</h1><h1 id="写在文章的最前面"><a href="#写在文章的最前面" class="headerlink" title="写在文章的最前面"></a>写在文章的最前面</h1><p>本人是java小白，自学没多久，在之前学校的课程中学习了java，并对java产生了一定的兴趣，不过只学习了一些最基本的语法。</p><span id="more"></span><p>课上老师给我们提了一个题目，让我们自己去写，当时是写售货机的系统，参考了很多才勉强写出来。后来经同学推荐，开始看设计模式的书，所以想以写博客的方式来激励自己学习，并作一些记录。</p><p>本人典型理工科 <strong>小白</strong>，所以文笔不好，也借此机会锻炼锻炼自己的文笔，有写的语言不通和错误的地方，请大佬勿喷，同为初学者的大家一起交流交流，私信我，再次感激不尽！！</p><h1 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h1><p>设计模式即为java项目设计中的一种设计方法，通过这些前辈总结的方法以及设计思想，可以让我们在实际java项目开发的时候有规律可循，通过对于具体项目的解剖以及思考，使我们可以对应使用相应的<strong>设计模式</strong>，大大简化了设计难度，使用科学有效的设计模式，能少走一些不必要的弯路。</p><h1 id="问题的引出"><a href="#问题的引出" class="headerlink" title="问题的引出"></a>问题的引出</h1><p>现在，我们想要做出一个 “<strong>鸭子</strong>“ 产品，这个鸭子产品拥有下面几个 <strong>属性</strong> 或 <strong>功能</strong> ：</p><ol><li>这个 “<strong>鸭子</strong>“ 它会叫，并且不同的鸭子叫声是不一样的；</li><li>这个 “<strong>鸭子</strong>“ 它会飞，而且有的鸭子会飞，有的鸭子飞不起来，飞不起来的原因有很多，比如翅膀坏了，又或是这个 “<strong>鸭子</strong>“ 根本没有翅膀，最简单的例子：洗澡的橡皮鸭，对吧！它确实是没有翅膀；</li><li>这个 “<strong>鸭子</strong>“ 它会呈现给我们一个信息，就像一个按钮，当你按下去的时候，它会告诉你一些东西，可以是关于它是什么鸭子，或者它是否能飞，当然这取决于你，对，就是程序员或者…你的老板（<del>微笑中透露出了些许无奈，毕竟要恰饭的</del> ）   。</li></ol><h2 id="第一步，也即最开始的想法"><a href="#第一步，也即最开始的想法" class="headerlink" title="第一步，也即最开始的想法"></a>第一步，也即最开始的想法</h2><p>首先创建一个Duck类，这个Duck类包含了一些属性，比如重量、品种、毛皮颜色等，这里可以设置几个以protected为访问控制符的成员变量，变量名称用对应英文即可，例如Weight、Variety、FurColor。</p><p>然后就是为Duck这个类创建方法，方法包含了叫、飞以及”自我介绍”的动作。</p><p>但是，迎面而来的问题就是，不同的 “<strong>鸭子</strong>“ 拥有不同的属性、行为（即方法），这样当你想创建多个不同鸭子的时候，则要创建对应数量的类。</p><p>这样就完全没有运用到代码的复用，不仅复杂而且低效。所以对于代码复用，像我一样的初学者一般想到的就是继承。</p><p>个人认为 <strong>继承</strong> 这个机制有利也有弊，当继承过于复杂时，继承的缺点就暴露出来了，最大的问题就是一个类无法继承两个即两个以上的父类，这就限制了继承的使用。</p><p>那么我们先来使用继承父类来试试，首先写一个Duck类，把各种属性以及方法写好，而子类继承父类后，如果子类未进行重写，则方法以及属性仍然默认 “运用” 父类的方法以及属性。</p><p>但是我们要编写的是好几个属性以及方法可能不同的 “鸭子” 类。也就意味着代码仍然无法很好的服用，假如多个类之间几乎没有相同的属性以及方法，那继承的属性以及方法基本都是无用的，都要重写，这样代码复用仍然没有很好的实现。</p><p>同时，如果这时候，你的老板或者策划突然萌生了一个别的想法，给这些 “<strong>鸭子</strong>“ 加一个动作，比如下蛋，或者迁徙。</p><p>这个时候如果要加这样一个方法，那么Duck父类以及下面所有的子类几乎都要手动添加这样一个方法，明显很难实现，在具体工程项目的实践过程中，这样低效率的代码在面临反复多次的修改时会显得很无力，几乎每次修改添加都是重写，而且要重写很多次。</p><h2 id="策略模式的引出"><a href="#策略模式的引出" class="headerlink" title="策略模式的引出"></a>策略模式的引出</h2><p>因此要解决这样一个问题，即我们要编写一群类，这些类都有一些共通的属性或者方法，这些属性或方法在大的方面属于一类，但每一类都或多或少有些区别，就比如鸭子的叫声有正常鸭子的”呱呱呱”的叫也有橡皮鸭的”叽叽叽”的叫，这都属于发出叫声这样一个行为，但又有所不同，在这种情况下，引用比较专业的说法，就是将这样一种模式细分为下面三种组成：</p><ol><li>抽象策略角色这个是一个抽象的角色，通常情况下使用接口或者抽象类去实现。对比来说，就是我们的下面代码例子中的FlyBehavior以及QuackBehavior接口。</li><li>具体策略角色包装了具体的算法和行为。对比来说，就是实现了FlyBehavior以及QuackBehavior接口的实现一组实现类。</li><li>环境角色内部会持有一个抽象角色的引用，给客户端调用。对比来说，就是我们的具体 “<strong>鸭子</strong>“ 类别。说明：具体的Duck类内部一定会有一个策略类的一个成员变量，这样做的目的在于可以当我们在去创建具体的Duck对象如NormalDuck的时候，可以接收我们向NormalDuck类中传递的具体的策略类。</li></ol><h1 id="具体实现代码以及分析"><a href="#具体实现代码以及分析" class="headerlink" title="具体实现代码以及分析"></a>具体实现代码以及分析</h1><h2 id="1-Duck抽象类"><a href="#1-Duck抽象类" class="headerlink" title="1.Duck抽象类"></a>1.Duck抽象类</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Duck</span> </span>&#123;<br>    FlyBehavior flybehavior;<br>    QuackBehavior quackbehavior;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">void</span> display();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">performFly</span>(<span class="hljs-params"></span>)</span>&#123;<br>        flybehavior.fly();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">performQuack</span>(<span class="hljs-params"></span>)</span>&#123;<br>        quackbehavior.quack();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Duck</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setFly</span>(<span class="hljs-params">FlyBehavior fb</span>)</span>&#123;<br>        flybehavior = fb;<br>    &#125;<br><br><span class="hljs-comment">//    public void setDuckWithWings()&#123;</span><br><span class="hljs-comment">//        flybehavior = new FlyWithWings();</span><br><span class="hljs-comment">//    &#125;</span><br><br><span class="hljs-comment">//    public void setDuckWithoutWings()&#123;</span><br><span class="hljs-comment">//        flybehavior = new FlyWithoutWings();</span><br><span class="hljs-comment">//    &#125;</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setQuack</span>(<span class="hljs-params">QuackBehavior qk</span>)</span>&#123;<br>        quackbehavior = qk;<br>    &#125;<br><br><span class="hljs-comment">//    public void setDuckCanQuack()&#123;</span><br><span class="hljs-comment">//        quackbehavior = new Quack();</span><br><span class="hljs-comment">//    &#125;</span><br><br><span class="hljs-comment">//    public void setDuckCantQuack()&#123;</span><br><span class="hljs-comment">//        quackbehavior = new CantQuack();</span><br><span class="hljs-comment">//    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Duck抽象类中包含了一个抽象的方法display()，用来让鸭子 “<strong>声明</strong>“ 自己的一些信息，或者其他功能，而所有继承Duck抽象类的具体duck类都必须要重写此抽象方法。同时申明了两个抽象策略角色，即flybehavior以及quackbehavior，在后续实例化时，再对这两个变量进行具体的实例化。具体下面代码会解释。</p><h2 id="2-FlyBehavior以及QuackBehavior接口"><a href="#2-FlyBehavior以及QuackBehavior接口" class="headerlink" title="2.FlyBehavior以及QuackBehavior接口"></a>2.FlyBehavior以及QuackBehavior接口</h2><h3 id="FlyBehavior"><a href="#FlyBehavior" class="headerlink" title="FlyBehavior"></a>FlyBehavior</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FlyBehavior</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="QuackBehavior"><a href="#QuackBehavior" class="headerlink" title="QuackBehavior"></a>QuackBehavior</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">QuackBehavior</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quack</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-FlyWithWings以及FlyWithoutWings"><a href="#3-FlyWithWings以及FlyWithoutWings" class="headerlink" title="3.FlyWithWings以及FlyWithoutWings"></a>3.FlyWithWings以及FlyWithoutWings</h2><h3 id="FlyWithWings"><a href="#FlyWithWings" class="headerlink" title="FlyWithWings"></a>FlyWithWings</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">FlyWithWings</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">FlyBehavior</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> fly()&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;I am flying!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FlyWithoutWings"><a href="#FlyWithoutWings" class="headerlink" title="FlyWithoutWings"></a>FlyWithoutWings</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">FlyWithoutWings</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">FlyBehavior</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> fly()&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;I can&#x27;t fly!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-Quack以及CantQuack"><a href="#4-Quack以及CantQuack" class="headerlink" title="4.Quack以及CantQuack"></a>4.Quack以及CantQuack</h2><h3 id="Quack"><a href="#Quack" class="headerlink" title="Quack"></a>Quack</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Quack</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">QuackBehavior</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> quack()&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Gua Gua&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CantQuack"><a href="#CantQuack" class="headerlink" title="CantQuack"></a>CantQuack</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">CantQuack</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">QuackBehavior</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> quack()&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;&lt;&lt;Slience&gt;&gt;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-normalduck以及modelduck（环境角色）"><a href="#5-normalduck以及modelduck（环境角色）" class="headerlink" title="5.normalduck以及modelduck（环境角色）"></a>5.normalduck以及modelduck（环境角色）</h2><h3 id="normalduck"><a href="#normalduck" class="headerlink" title="normalduck"></a>normalduck</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">normalduck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Duck</span> </span>&#123;<br>    public normalduck()&#123;<br>        flybehavior = <span class="hljs-keyword">new</span> <span class="hljs-type">FlyWithWings</span>();<br>        quackbehavior = <span class="hljs-keyword">new</span> <span class="hljs-type">Quack</span>();<br>    &#125;   <br><br>    public void display()&#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;I am a normal duck&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="modelduck"><a href="#modelduck" class="headerlink" title="modelduck"></a>modelduck</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">modelduck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Duck</span> </span>&#123;<br>    public modelduck()&#123;<br>        flybehavior = <span class="hljs-keyword">new</span> <span class="hljs-type">FlyWithoutWings</span>();<br>        quackbehavior = <span class="hljs-keyword">new</span> <span class="hljs-type">Quack</span>();<br>    &#125;<br><br>    public void display() &#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;I am a model duck&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上两个就是环境角色，一个是普通鸭子，另一个是模型鸭子。</p><h1 id="总结及分析"><a href="#总结及分析" class="headerlink" title="总结及分析"></a>总结及分析</h1><ol><li>可以看到，每种不同的鸭子类都可以直接使用已有的一些方法，我们需要做的就是选择当前鸭子类所包含的方法（即行为），当我们想改变这个鸭子类的一种方法，我们只需要将其改为我们提前设定好的一种方法，而不是将代码返工重写，提高了复用率。</li><li>如果我们想增加一种另一类的方法，比如给鸭子类增加一个 “<strong>迁徙</strong>“ 行为（方法），则我们可以再写接口，即 “<strong>迁徙</strong>“ 接口，然后再对迁徙这个行为具体的实现方式进行实现，比如向南迁徙或向北迁徙，这些”行为类”实现了 “<strong>迁徙</strong>“ 接口。这样我们就可以很方便的给当前已经写好的环境角色类添加行为（方法）</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典生产者与消费者问题</title>
    <link href="/2019/12/20/%E7%BB%8F%E5%85%B8%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/"/>
    <url>/2019/12/20/%E7%BB%8F%E5%85%B8%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="经典生产者与消费者问题"><a href="#经典生产者与消费者问题" class="headerlink" title="经典生产者与消费者问题"></a>经典生产者与消费者问题</h1><h2 id="1-问题的引入"><a href="#1-问题的引入" class="headerlink" title="1. 问题的引入"></a>1. 问题的引入</h2><p>​    如同日常生活中一样，我们每天所消费的东西，都是生产部门进行生产，我们才有商品来进行消费。</p><p>​    那么就有一个很现实的问题，生产部门如果没有生产，我们是没有任何商品来消费的。</p><span id="more"></span><p>​    同时商品过多又会导致相对商品过剩，造成经济危机。</p><p>​    所以生产合适数量的商品来供我们消费，才可以维持动态平衡。</p><h2 id="2-简单的例子实现"><a href="#2-简单的例子实现" class="headerlink" title="2.简单的例子实现"></a>2.简单的例子实现</h2><p>​    要模拟同时进行生产和消费，就必须至少有一个生产者与消费者来同时运作。</p><p>​    我们知道程序一般是顺序执行的，所以必须用到Java技术中的多线程。</p><p>​    也就是开两个线程分别来进行生产以及消费。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livescript">Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br><br>Thread producerThread = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;</span></span><br><span class="hljs-function"><span class="hljs-params">        producer.produce(stack);</span></span><br><span class="hljs-function"><span class="hljs-params">    &#125;</span></span><br><span class="hljs-function"><span class="hljs-params">&#125;)</span>;</span><br><span class="hljs-function"><span class="hljs-title">producerThread</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">Thread</span> <span class="hljs-title">consumerThread</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;</span></span><br><span class="hljs-function"><span class="hljs-params">        consumer.consume(stack);</span></span><br><span class="hljs-function"><span class="hljs-params">    &#125;</span></span><br><span class="hljs-function"><span class="hljs-params">&#125;)</span>;</span><br><span class="hljs-function"><span class="hljs-title">consumerThread</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br></code></pre></td></tr></table></figure><p>​    这里我们用stack作为容器的载体，通过stack的push( )与pop( )方法来实现随机字符（即Character）的产生以及消耗。</p><p>​    我们来运行这个程序（当然producer以及consumer我只是用了简单的描述来代替，下面会有两个类的具体实现）。</p><p>​    我们会发现一个非常严重的问题。</p><p>​    众所周知，Java多线程中，每个线程运行时，都在争夺CPU的资源，而且一个线程不可能长时间占用。</p><p>​    那么就会产生一种很糟糕的情况，即生产者一段时间内没有争夺到CPU的资源，而消费者一直消费，但是我们的容器    stack里面已经空了，stack无法pop，就会产生异常。</p><h2 id="3-简单修改生产者以及消费者"><a href="#3-简单修改生产者以及消费者" class="headerlink" title="3.简单修改生产者以及消费者"></a>3.简单修改生产者以及消费者</h2><p>​    那么设置边际条件，使当stack容器中的内容为0时，消费者停止消费，而等生产者生产后在开始消费。</p><p>​    运用多线程中的wait( )与notify( )方法，当stack容器中的内容为0时，让消费者wait( )，等待生产者生产之后再消费。</p><p>​    修改完的例子运行之后，发现一切正常，消费者消费，生产者生产，一切祥和稳定。</p><p>​    但真的是这样吗？</p><h2 id="4-再次深入"><a href="#4-再次深入" class="headerlink" title="4.再次深入"></a>4.再次深入</h2><p>​    如果我们不只有一个生产者与消费者，那么我们刚刚的程序会发生什么？</p><p>​    我们会发现，会产生多个消费者之间会发生一种复杂的现象，我用下面的图来解释这种现象：</p><p><img src="" alt="1577242149195"></p><p>​    可以看到，由于每个线程之间在争夺CPU的资源，所以会出现 <strong>consumer1</strong> 在对<strong>数据1</strong> 进行操作的时候，<strong>consumer2</strong> 也争夺到了CPU资源，而 <strong>consumer1</strong> 的操作还未完成，<strong>数据1</strong> 还未被改动，导致 <strong>consumer2</strong> 读取到的还时数据1，那么数据1 就会被操作两次，出现错误。</p><p>​    怎么解决呢，Java技术中，为了解决这种问题，为大家提供了关键字 <strong>synchronized</strong> 来解决，该关键字保证了当进行被 <strong>synchronized</strong> 关键字修饰的操作时，保证只有当前对象可以访问数据，其他的线程只能等待。</p><p>​    下面放上经过修改后的 <strong>Consumer</strong> 和 <strong>Producer</strong> 类：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> &#123;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.count = count;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">(Stack&lt;Character&gt; stack)</span> throws InterruptedException</span>&#123;<br>        <span class="hljs-keyword">String</span> consumeChar;<br>        <span class="hljs-built_in">synchronized</span> (stack)&#123;<br>            <span class="hljs-keyword">if</span>(stack.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;<br>                stack.<span class="hljs-built_in">wait</span>();<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                consumeChar = <span class="hljs-keyword">String</span>.<span class="hljs-built_in">valueOf</span>(stack.<span class="hljs-built_in">pop</span>());<br>                assert consumeChar != null;<br>                System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;[ consumer&quot;</span>+count+<span class="hljs-string">&quot; ] : consume &quot;</span>+consumeChar+<span class="hljs-string">&quot;\n stack : &quot;</span>+stack.<span class="hljs-built_in">size</span>()+<span class="hljs-string">&quot;\n right now content : &quot;</span>+stack.<span class="hljs-built_in">toString</span>());<br>                stack.<span class="hljs-built_in">notify</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> &#123;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Producer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.count = count;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produceRandomChar</span><span class="hljs-params">(Stack&lt;Character&gt; stack)</span> throws InterruptedException </span>&#123;<br>        Random random = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Random</span>();<br>        <span class="hljs-keyword">char</span> randomChar = (<span class="hljs-keyword">char</span>)(random.<span class="hljs-built_in">nextInt</span>(<span class="hljs-number">25</span>)+<span class="hljs-number">65</span>);<br>        <span class="hljs-built_in">synchronized</span> (stack)&#123;<br>            <span class="hljs-keyword">int</span> MAX_SIZE = <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span>(stack.<span class="hljs-built_in">size</span>() == MAX_SIZE)&#123;<br>                stack.<span class="hljs-built_in">wait</span>();<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                stack.<span class="hljs-built_in">push</span>(randomChar);<br>                System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;[ producer&quot;</span>+count+<span class="hljs-string">&quot; ] : produce &quot;</span>+randomChar+<span class="hljs-string">&quot;\n  stack : &quot;</span>+stack.<span class="hljs-built_in">size</span>()+<span class="hljs-string">&quot;\n right now content : &quot;</span>+stack.<span class="hljs-built_in">toString</span>());<br>                stack.<span class="hljs-built_in">notify</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="5-生产者与消费者之间进行交互的Interaction类"><a href="#5-生产者与消费者之间进行交互的Interaction类" class="headerlink" title="5.生产者与消费者之间进行交互的Interaction类"></a>5.生产者与消费者之间进行交互的Interaction类</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Interaction</span> &#123;</span><br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) throws InterruptedException &#123;<br>        int count;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.<span class="hljs-keyword">in</span>);<br>        System.out.println(<span class="hljs-string">&quot;[ Please input the number of thread ]&quot;</span>);<br>        count = scanner.nextInt();<br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        Consumer[] consumers = <span class="hljs-keyword">new</span> Consumer[count];<br>        Producer[] producers = <span class="hljs-keyword">new</span> Producer[count];<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            consumers[i] = <span class="hljs-keyword">new</span> Consumer(i+<span class="hljs-number">1</span>);<br>            producers[i] = <span class="hljs-keyword">new</span> Producer(i+<span class="hljs-number">1</span>);<br>        &#125;<br>        Thread[] consumersThread = <span class="hljs-keyword">new</span> Thread[count];<br>        Thread[] producersThread = <span class="hljs-keyword">new</span> Thread[count];<br>        final boolean[] flag = &#123;<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>&#125;;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            int finalI = i;<br>            Thread produce = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">                <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">                    <span class="hljs-keyword">while</span>(flag[<span class="hljs-number">0</span>])&#123;</span></span><br><span class="hljs-function"><span class="hljs-params">                        producers[finalI].produceRandomChar(stack);</span></span><br><span class="hljs-function"><span class="hljs-params">                        Thread.sleep(<span class="hljs-number">500</span>);</span></span><br><span class="hljs-function"><span class="hljs-params">                        <span class="hljs-keyword">if</span>(stack.size() == <span class="hljs-number">10</span>)&#123;</span></span><br><span class="hljs-function"><span class="hljs-params">                            flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;</span></span><br><span class="hljs-function"><span class="hljs-params">                        &#125;</span></span><br><span class="hljs-function"><span class="hljs-params">                    &#125;</span></span><br><span class="hljs-function"><span class="hljs-params">                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">                    e.printStackTrace();</span></span><br><span class="hljs-function"><span class="hljs-params">                &#125;</span></span><br><span class="hljs-function"><span class="hljs-params">            &#125;)</span>;</span><br><span class="hljs-function">            <span class="hljs-title">produce</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            <span class="hljs-title">producersThread</span>[<span class="hljs-title">i</span>] = <span class="hljs-title">produce</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">            <span class="hljs-title">Thread</span> <span class="hljs-title">consume</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">                <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">                    <span class="hljs-keyword">while</span>(flag[<span class="hljs-number">1</span>])&#123;</span></span><br><span class="hljs-function"><span class="hljs-params">                        consumers[finalI].consume(stack);</span></span><br><span class="hljs-function"><span class="hljs-params">                        Thread.sleep(<span class="hljs-number">500</span>);</span></span><br><span class="hljs-function"><span class="hljs-params">                        <span class="hljs-keyword">if</span>(stack.size() == <span class="hljs-number">0</span> &amp;&amp; !flag[<span class="hljs-number">1</span>])&#123;</span></span><br><span class="hljs-function"><span class="hljs-params">                            flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;</span></span><br><span class="hljs-function"><span class="hljs-params">                        &#125;</span></span><br><span class="hljs-function"><span class="hljs-params">                    &#125;</span></span><br><span class="hljs-function"><span class="hljs-params">                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">                    e.printStackTrace();</span></span><br><span class="hljs-function"><span class="hljs-params">                &#125;</span></span><br><span class="hljs-function"><span class="hljs-params">            &#125;)</span>;</span><br><span class="hljs-function">            <span class="hljs-title">consume</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            <span class="hljs-title">consumersThread</span>[<span class="hljs-title">i</span>] = <span class="hljs-title">consume</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">for</span><span class="hljs-params">(Thread thread : consumersThread)</span>&#123;</span><br><span class="hljs-function">            <span class="hljs-title">thread</span>.<span class="hljs-title">join</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(Thread thread: producersThread)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">thread</span>.<span class="hljs-title">join</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>生产者与消费者</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java设计模式】2.装饰者模式</title>
    <link href="/2019/12/20/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/12/20/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="【Java设计模式】2-装饰者模式"><a href="#【Java设计模式】2-装饰者模式" class="headerlink" title="【Java设计模式】2.装饰者模式"></a>【Java设计模式】2.装饰者模式</h1><h1 id="问题的引入"><a href="#问题的引入" class="headerlink" title="问题的引入"></a>问题的引入</h1><p>在本市最繁华的一条街上，开了一家星巴菲（没错，不是星巴克<del>为了避嫌</del> ）。</p><span id="more"></span><p>这家星巴菲咖啡由于初来乍到，只能付费算账系统还未完善。不过，由于星巴菲的咖啡非常香醇、提神，并且价格优惠（简直就是教科书般的物美价廉），收到了广大上班族的推崇，甚至几个街区外的白领们宁愿上班多绕路来这里买咖啡，也不愿意去公司附近的开封菜去买 “<strong>咖啡</strong>“ 。</p><p>不久之后，每天早上店里都人满为患，也正是因为来的顾客太多，原来的人为计算最终咖啡加配料价格的方式显然不能满足快速的结账。</p><p>所以，星巴菲的经理找到了你，也就是这个街区最优秀的程序员来帮他们设计这样一个结账结算系统。</p><h2 id="首先进行系统框架的构思"><a href="#首先进行系统框架的构思" class="headerlink" title="首先进行系统框架的构思"></a>首先进行系统框架的构思</h2><p><img src="https://img-blog.csdnimg.cn/20190219220653859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzQ0MDI1,size_16,color_FFFFFF,t_70" alt="最初的简单构思"></p><p> 可以看到，我们设计了一个Beverage类，有description变量，为字符串，用来记录这杯咖啡的类型，例如拿铁之类的。接着milk、soy、mocha以及whip为布尔值类型变量，其值代表了是否加入这些调料。下面的方法有得到这杯饮料的信息、计算整杯饮料的价钱以及给这杯饮料增加或删减调料。</p><p>从目前来看，Beverage类里的成员变量以及所包含的方法可以满足最开始的要求，即根据一杯饮料以及其加的配料，可以得到最终这杯饮料的名称以及总价钱。</p><p><strong>但是</strong>！如果一位顾客想要一杯<strong>加了双倍摩卡</strong>的咖啡，该怎么办呢？并且，如果店里突然加了一种新的咖啡调料，那我们就要修改代码。</p><p>可以看到，如果要增加一种咖啡调料，那必须要增加一个对应布朗类型的成员变量，并且还要有对应加调料的方法，以及在cost()方法中写入对应新加调料的价格。</p><p>这么一看，那不就是把这个类进行大修改嘛！我们知道，编程序中，最忌讳的就是代码量太大，并且做出调整时，要把总代码进行修改，这样可能新代码还没实现，结果老代码也出现了问题。</p><p>所以有没有一种方法，让我们的程序代码  “<strong>对扩展开放，对修改关闭</strong>“ 呢？</p><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>对于本篇文章的星巴菲咖啡问题，我用装饰者模式来为其构思整个系统：</p><ol><li>拿一个深焙咖啡（也就是DarkRoast咖啡）对象<br> ps：此处的对象是指在堆上new出来的一个对象</li><li>用摩卡（Mocha）对象来装饰它</li><li>用奶泡（Whip）对象来装饰它</li><li>最终得到了摩卡奶泡深焙咖啡，并且用cost()方法计算了其最终价格 下面用一组图来表达这种关系： 在这幅关系图中，看得出来，DarkRoast是咖啡的品种，首先Mocha调料作为装饰者类将其包含在里面，同样Whip调料类再将Mocha类包含在里面。以此类推，想要添加什么，就添加什么调料。并且其解决了刚刚提出的问题，问题以及解决方法都如下：</li><li>一位顾客想要一杯加了双倍摩卡的咖啡<br> 解决方法：由于不用类里面的成员变量来表达是否添加调料，但是在这种方法下，顾客想加多少摩卡就加多少，甚至加一杯都可以。</li><li>添加一种新的调料并添加与调料相关的部分数据<br> 解决方法：既然我们添加调料都是将原来调好的咖啡类都包含在其中，那么也就是说，调料的添加无需在咖啡类中做出修改。我们只需要另外写一个调料类，然后将原咖啡或已经加了一些调料的咖啡类包含进来即可。</li></ol><h1 id="具体框架设计"><a href="#具体框架设计" class="headerlink" title="具体框架设计"></a>具体框架设计</h1><p><img src="https://img-blog.csdnimg.cn/20190221125416926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzQ0MDI1,size_16,color_FFFFFF,t_70" alt="框架"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="Beverage类"><a href="#Beverage类" class="headerlink" title="Beverage类"></a>Beverage类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Beverage</span> </span>&#123;<br>    String description = <span class="hljs-string">&quot;Unknown Beverage&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> description;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4种咖啡类"><a href="#4种咖啡类" class="headerlink" title="4种咖啡类"></a>4种咖啡类</h2><p>HouseBlend</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HouseBlend</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Beverage</span> </span>&#123;<br>    public <span class="hljs-type">HouseBlend</span>()&#123;<br>        description = <span class="hljs-string">&quot;HouseBlend&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    public double cost() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1.99</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>DarkRoast</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DarkRoast</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Beverage</span> </span>&#123;<br>    public <span class="hljs-type">DarkRoast</span>()&#123;<br>        description = <span class="hljs-string">&quot;DarkRoast&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    public double cost() &#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1.29</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Decaf</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decaf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Beverage</span> </span>&#123;<br>    public <span class="hljs-type">Decaf</span>()&#123;<br>        description = <span class="hljs-string">&quot;Decaf&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    public double cost() &#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1.36</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Espresso</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Espresso</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Beverage</span> </span>&#123;<br>    public <span class="hljs-type">Espresso</span>()&#123;<br>        description = <span class="hljs-string">&quot;Espresso&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    public double cost() &#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1.59</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="调料抽象类"><a href="#调料抽象类" class="headerlink" title="调料抽象类"></a>调料抽象类</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Condiment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Beverage</span> </span>&#123;<br>    public <span class="hljs-keyword">abstract</span> <span class="hljs-type">String</span> getDescription();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四种调料类"><a href="#四种调料类" class="headerlink" title="四种调料类"></a>四种调料类</h2><p>Milk</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Milk</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Condiment</span> </span>&#123;<br>    Beverage beverage;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Milk</span>(<span class="hljs-params">Beverage b</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.beverage = b;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getDescription</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> beverage.getDescription()+<span class="hljs-string">&quot;,Milk&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> double <span class="hljs-function"><span class="hljs-title">cost</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.85</span>+beverage.cost();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Mocha</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mocha</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Condiment</span> </span>&#123;<br>    Beverage beverage;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Mocha</span>(<span class="hljs-params">Beverage b</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.beverage = b;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getDescription</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> beverage.getDescription()+<span class="hljs-string">&quot;,Mocha&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> double <span class="hljs-function"><span class="hljs-title">cost</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.75</span>+beverage.cost();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Whip</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Whip</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Condiment</span> </span>&#123;<br>    Beverage beverage;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Whip</span>(<span class="hljs-params">Beverage b</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.beverage = b;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getDescription</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> beverage.getDescription()+<span class="hljs-string">&quot;,Whip&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> double <span class="hljs-function"><span class="hljs-title">cost</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.95</span>+beverage.cost();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Soy</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Soy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Condiment</span> </span>&#123;<br>    Beverage beverage;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Soy</span>(<span class="hljs-params">Beverage b</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.beverage = b;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getDescription</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> beverage.getDescription()+<span class="hljs-string">&quot;,Soy&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> double <span class="hljs-function"><span class="hljs-title">cost</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1.05</span>+beverage.cost();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> BeverageTest &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args)&#123;<br>        Beverage beverage1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Decaf()</span>;<br>        beverage1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Milk(<span class="hljs-params">beverage1</span>)</span>;<br>        beverage1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Milk(<span class="hljs-params">beverage1</span>)</span>;<br>        beverage1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Whip(<span class="hljs-params">beverage1</span>)</span>;<br>        beverage1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Mocha(<span class="hljs-params">beverage1</span>)</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(beverage1.get<span class="hljs-constructor">Description()</span>+<span class="hljs-string">&quot; $ &quot;</span>+beverage1.cost<span class="hljs-literal">()</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最终运行结果"><a href="#最终运行结果" class="headerlink" title="最终运行结果"></a>最终运行结果</h1><p><img src="https://img-blog.csdnimg.cn/20190221131019214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzQ0MDI1,size_16,color_FFFFFF,t_70" alt="运行结果"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>装饰者模式是一个较为典型的 “<strong>对扩展开放，对修改关闭</strong>“ 模式。<br> 装饰者可以在被装饰者的行为前面与后面加上自己的行为，甚至将被装饰者的行为整个替代掉，而达到特定的目的。<br> 但是装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂，所以设计时也要注意使用的次数。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java设计模式】3.观察者模式</title>
    <link href="/2019/12/20/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/12/20/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="【Java设计模式】3-观察者模式"><a href="#【Java设计模式】3-观察者模式" class="headerlink" title="【Java设计模式】3.观察者模式"></a>【Java设计模式】3.观察者模式</h1><h1 id="问题的引入"><a href="#问题的引入" class="headerlink" title="问题的引入"></a>问题的引入</h1><p>前几天我们刚完成了制造”鸭子”以及帮助星巴菲咖啡店解决了结账问题，我想是时候去度个小长假休息休息了。在我们正准备收拾衣服去度假的时候，电话突然响了。我们接通了电话。</p><span id="more"></span><p>电话的那头传来了焦急地声音：“嗨，我们听说你是这座城市里最厉害的程序员，请你帮帮我们解决一个技术上的难题！！”电话那头的人太过于紧张以至于连自己来自哪里，叫什么都还没有交代，就想请我们出山去为他们解除<strong>警报</strong>，“嗨老兄，我至少得知道你们是哪个公司，有什么方面的难题啊！我也不是神通广大，什么都会啊！”。</p><p>经过一番交谈后，原来这是气象站来找我们，他们现在的天气实时检测系统与第三方的公司之间出现了交换数据的问题。还好这在我们java可以解决的业务范围内，看来我们的度假是要泡汤了，不过没事，我们可以当作把休息时间用来加班赚外快，有了钱犒劳犒劳自己。</p><h2 id="还是老样子，先来思考框架"><a href="#还是老样子，先来思考框架" class="headerlink" title="还是老样子，先来思考框架"></a>还是老样子，先来思考框架</h2><p><img src="https://img-blog.csdnimg.cn/20190222131348848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzQ0MDI1,size_16,color_FFFFFF,t_70" alt="基础框架"></p><p> 气象站目前可以为我们提供一些基础的信息，而我们则需要根据这些信息设计一个布告板，为大家显示这些信息。（当然也可以用现在更为现代的说法叫手机app天气实时推送）</p><p>也就是说，图中左半边的部分无需我们来设计，气象站有他们自己的一套设备，我们只需要把WeatherData类以及布告板设计好就行。</p><p>那么让我们来设计一下这个WeatherData类以及布告板吧！</p><h2 id="初版WeatherData类"><a href="#初版WeatherData类" class="headerlink" title="初版WeatherData类"></a>初版WeatherData类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeatherData</span> </span>&#123;<br>    <span class="hljs-comment">//实例变量声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measurementsChanged</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">float</span> temp = getTemperature();<br>        <span class="hljs-keyword">float</span> humidity = getHumidity();<br>        <span class="hljs-keyword">float</span> pressure = getPressure();<br>        <span class="hljs-comment">//三个假设已经实现的获取信息的方法</span><br><br>        statisticsDisplay.update(temp,humidity,pressure);<br>        normalConditionsDisplay.update(temp,humidity,pressure);<br>        <span class="hljs-comment">//布告板更新显示信息</span><br>    &#125;<br>    <span class="hljs-comment">//WeatherData的其他方法</span><br>    <span class="hljs-comment">//目前这只是一个简化的类，很多都是简要的标出，具体实现在下面部分</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这就是初版的实现方法，确实可以实现将信息从气象站中取出并更新布告板中的信息。但是不要高兴的太早，这时候需要读者你来思考一下，这个实现中，存在以下哪些问题？</p><ul><li><input disabled="" type="checkbox"> 我们现在是针对具体实现编程，而非针对接口。</li><li><input disabled="" type="checkbox"> 对于每个新的布告板，我们都要改变代码。</li><li><input disabled="" type="checkbox"> 我们无法在运行时动态的增加或减少布告板。</li><li><input disabled="" type="checkbox"> 我们未封装改变的部分。</li><li><input disabled="" type="checkbox"> 每当气象站信息出现改变时，我们手动得去获取信息不能保证我们实时的更新我们的布告板。</li></ul><p>很遗憾的是，对于上面所说的几种问题，我们的第一个实现都存在。<br> 是的，我们的程序确实存在这么多的问题。那么有没有一种方法可以解决呢？</p><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p><img src="https://img-blog.csdnimg.cn/20190223225347925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzQ0MDI1,size_16,color_FFFFFF,t_70" alt="观察者模式"></p><p>其实，这样一种情况很多程序员前辈都注意到了这个问题，在Java中内置了这种模式，我们只需要了解如何使用即可。（具体的使用方法可以自行查看java.util包，里面包含了java.util.Observer以及java.util.Observable）下面用一个关系图来解释这种模式。</p><h1 id="最终版实现"><a href="#最终版实现" class="headerlink" title="最终版实现"></a>最终版实现</h1><p>那么我们就只弄一个最简单的，布告板只设置一个最简单的NormalConditionDisplay()类，由于Observable是Java中内置的类，所以我们直接拿来用就好。下面是具体代码</p><h2 id="DisplayElement（即上图中的Observer类）"><a href="#DisplayElement（即上图中的Observer类）" class="headerlink" title="DisplayElement（即上图中的Observer类）"></a>DisplayElement（即上图中的Observer类）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DisplayElement</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="WeatherData类"><a href="#WeatherData类" class="headerlink" title="WeatherData类"></a>WeatherData类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> weather;<br><span class="hljs-keyword">import</span> java.util.Observer;<br><span class="hljs-keyword">import</span> java.util.Observable;<br><br><span class="hljs-meta">@SuppressWarnings(&quot;unused&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeatherData</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Observable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> temperature;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> humidity;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> pressure;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeatherData</span><span class="hljs-params">()</span></span>&#123;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measurementsChanged</span><span class="hljs-params">()</span></span>&#123;<br>        setChanged();<br>        notifyObservers();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMeasurements</span><span class="hljs-params">(<span class="hljs-keyword">float</span> temperature,<span class="hljs-keyword">float</span> humidity,<span class="hljs-keyword">float</span> pressure)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.temperature = temperature;<br>        <span class="hljs-keyword">this</span>.humidity = humidity;<br>        <span class="hljs-keyword">this</span>.pressure = pressure;<br>        measurementsChanged();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getTemperature</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> temperature;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getHumidity</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> humidity;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getPressure</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> pressure;<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="NormalConditionDisplay-类"><a href="#NormalConditionDisplay-类" class="headerlink" title="NormalConditionDisplay()类"></a>NormalConditionDisplay()类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Observer;<br><span class="hljs-keyword">import</span> java.util.Observable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NormalConditionDisplay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span>,<span class="hljs-title">DisplayElement</span> </span>&#123;<br>    Observable observable;<br>    <span class="hljs-keyword">float</span> temperature;<br>    <span class="hljs-keyword">float</span> humidity;<br>    <span class="hljs-keyword">float</span> pressure;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NormalConditionDisplay</span><span class="hljs-params">(Observable a)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>        <span class="hljs-keyword">this</span>.observable = a;<br>        a.addObserver(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Observable o, Object arg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(o <span class="hljs-keyword">instanceof</span> WeatherData)&#123;<br>            <span class="hljs-keyword">this</span>.temperature = ((WeatherData) o).getTemperature();<br>            <span class="hljs-keyword">this</span>.humidity = ((WeatherData) o).getHumidity();<br>            <span class="hljs-keyword">this</span>.pressure = ((WeatherData) o).getPressure();<br>            display();<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        System.out.println(<span class="hljs-string">&quot;Current conditions:\ntemperature:&quot;</span>+temperature+<span class="hljs-string">&quot;\nhumidity:&quot;</span>+humidity<br>                +<span class="hljs-string">&quot;\npressure&quot;</span>+pressure);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="WeatherSystem类（即测试类）"><a href="#WeatherSystem类（即测试类）" class="headerlink" title="WeatherSystem类（即测试类）"></a>WeatherSystem类（即测试类）</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeatherSystem</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args)&#123;<br>        WeatherData w = <span class="hljs-keyword">new</span> <span class="hljs-type">WeatherData</span>();<br>        NormalConditionDisplay n = <span class="hljs-keyword">new</span> <span class="hljs-type">NormalConditionDisplay</span>(w);<br>        w.setMeasurements(<span class="hljs-number">27</span>, <span class="hljs-number">11</span>, <span class="hljs-number">30</span>);<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最终运行结果"><a href="#最终运行结果" class="headerlink" title="最终运行结果"></a>最终运行结果</h2><p><img src="https://img-blog.csdnimg.cn/20190223233437864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzQ0MDI1,size_16,color_FFFFFF,t_70" alt="运行结果"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>观察者模式可以让我们实现这样一种关系：即主题与观察者一对多，观察者依赖于此主题，只要主题状态一有变化，观察者就会被通知，而无须观察者手动地去接收信息。</p><p>并且我们可以随时增加我们想要添加的Observer类，在例子中也就是”布告板”，并且对于不对已经编好的代码进行修改。</p><p> 但是，需要注意的是，Java内置的Observable类是一个”类”，而非接口，它是一个类导致它的实现只能对其进行  <strong>继承</strong>  ,目前为止，我们已经有三篇文章讲解了关于设计模式，大家应该都明白，在一个设计的系统中，最好少用继承，继承制约了代码的使用和复用。</p><p> 并且在设计模式中有一个很重要的概念，那就是不要对 <strong>具体的类</strong> 进行编程，要对 <strong>接口</strong> 进行编程，在学习过程中，慢慢的有些理解这句话的含义，虽然理解得不够透彻。</p><p>之前听Java课的时候，老师曾给我们输入了一个概念，那就是一个Java项目由很多人来进行负责、编代码，每个人都完成自己的任务，如果对于具体的类进行编程，那么就意味着别人写的代码里的一个类你借用了，那么别人一旦修改了代码，你也要进行修改，而一个大的项目必然是很多类之间进行数据交换，那么如果都针对具体的类编程，那么一旦修改一个地方，必然会牵一发而动全身地修改。所以针对 <strong>接口</strong> 编程，可以让每个程序员之间拥有一定的独立性，而中间的联系就让专门的人写好接口，我们用即可，我们在自己类中进行编程只需要使用接口中定义了的属性以及方法即可，至于最终使用的是那个类的方法，则是在程序运行时，由编译器自己进行决定，这也就是Java基础中所讲到的 <strong>多态</strong>。</p><p> 以上是本人结合目前学习的模式知识以及Java基础知识所总结出来的，可能有些由错误，不过随着深入的学习，慢慢的思考，很多东西也就能慢慢地理解。总之，共勉吧！</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运用线程池来查找含有指定字符的文件</title>
    <link href="/2019/12/20/%E8%BF%90%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9D%A5%E6%9F%A5%E6%89%BE%E5%90%AB%E6%9C%89%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6%E7%9A%84%E6%96%87%E4%BB%B6/"/>
    <url>/2019/12/20/%E8%BF%90%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9D%A5%E6%9F%A5%E6%89%BE%E5%90%AB%E6%9C%89%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6%E7%9A%84%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="运用线程池来查找含有指定字符的文件"><a href="#运用线程池来查找含有指定字符的文件" class="headerlink" title="运用线程池来查找含有指定字符的文件"></a>运用线程池来查找含有指定字符的文件</h1><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> threadPool;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">import</span> java.util.concurrent.LinkedBlockingQueue;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 刘建雯</span><br><span class="hljs-comment">   */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSearching</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        System.out.println(<span class="hljs-string">&quot;[ Please input path ]&quot;</span>);<br>        String path = scanner.nextLine();<br>        System.out.println(<span class="hljs-string">&quot;[ Please input end words ]&quot;</span>);<br>        String endWords = scanner.nextLine();<br>        System.out.println(<span class="hljs-string">&quot;[ Please input the special words you wanna find ]&quot;</span>);<br>        String specialWords = scanner.nextLine();<br>        FileSearching fileSearching = <span class="hljs-keyword">new</span> FileSearching();<br>        fileSearching.fileSearch(path,endWords,specialWords);<br>&#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">private</span> ThreadPoolExecutor threadPool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;());<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fileSearch</span><span class="hljs-params">(String path, String endStr, String specialStr)</span></span>&#123;<br>            File filePath = <span class="hljs-keyword">new</span> File(path);<br>            <span class="hljs-keyword">if</span>(!filePath.exists())&#123;<br>                System.out.println(<span class="hljs-string">&quot;[warning] file not exist&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!filePath.isDirectory())&#123;<br>                <span class="hljs-keyword">if</span>(filePath.getName().endsWith(endStr))&#123;<br>                    threadPool.execute(() -&gt; &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-keyword">char</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[(<span class="hljs-keyword">int</span>)filePath.length()];<br>                            FileReader fileReader = <span class="hljs-keyword">new</span> FileReader(filePath);<br>                            fileReader.read(content);<br>                            <span class="hljs-keyword">if</span>(String.valueOf(content).contains(specialStr))&#123;<br>                                System.out.println(<span class="hljs-string">&quot;[file found] &quot;</span>+filePath.getAbsolutePath());<br>                                FileSearching.countUp();<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                File[] files = filePath.listFiles();<br>                <span class="hljs-keyword">assert</span> files != <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">for</span>(File file:files)&#123;<br>                    fileSearch(file.getAbsolutePath(),endStr,specialStr);<br>                &#125;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;find &quot;</span>+count+<span class="hljs-string">&quot; files end with &quot;</span>+endStr+<span class="hljs-string">&quot; and contain \&quot;&quot;</span>+specialStr+<span class="hljs-string">&quot;\&quot;&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countUp</span><span class="hljs-params">()</span></span>&#123;<br>            count++;<br>        &#125;<br>    <br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Demo</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
