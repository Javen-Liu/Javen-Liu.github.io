<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Into the Matrix</title>
  
  <subtitle>Javen 的个人博客</subtitle>
  <link href="https://blog.matrix-world.top/atom.xml" rel="self"/>
  
  <link href="https://blog.matrix-world.top/"/>
  <updated>2021-03-21T11:39:59.698Z</updated>
  <id>https://blog.matrix-world.top/</id>
  
  <author>
    <name>Javen-Liu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程是怎样切换的？</title>
    <link href="https://blog.matrix-world.top/2021/02/03/%E7%BA%BF%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E5%88%87%E6%8D%A2%E7%9A%84%EF%BC%9F/"/>
    <id>https://blog.matrix-world.top/2021/02/03/%E7%BA%BF%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E5%88%87%E6%8D%A2%E7%9A%84%EF%BC%9F/</id>
    <published>2021-02-03T09:18:13.000Z</published>
    <updated>2021-03-21T11:39:59.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="寒假期间的安排"><a href="#寒假期间的安排" class="headerlink" title="寒假期间的安排"></a>寒假期间的安排</h2><p>很久没有更新文章了，其实寒假的时候写了2020年下半年的总结，但是因为换了个电脑，以前hexo的配置也没同步过来，所以也就没有把文章上传上去。</p><p>寒假一直在看《操作系统真象还原》，看书名应该就能知道，是关于操作系统的书。</p><p>在看这本书之前，我也看了一本入门的书，书名大概叫《30天自制操作系统》，给我当时入了个门。</p><p>但是看完之后，仍然对于整个操作系统，还是没有一个较为系统的概念。</p><p>比如进程的切换啊，内存管理啊，写的都不是很详细。</p><p>寒假我看网上推荐的《操作系统真象还原》，就在放假前，去图书馆借了一本，带回家看。</p><p>虽然对于基础比较好的人来说，这本书写的有点啰嗦，也就是有些概念作者使用较为白话的方式，来解释。</p><p>但是对于我这样一个小白来说，还是有助于理解的。</p><p>与此同时还配合了哈工大李志军老师的《操作系统》公开课，非常受益！非常建议看过入门书籍后的同学，去听听课，做一做配套的实验课，对于理解整个系统是有帮助的。</p><h2 id="关于《crafting-interpreters》"><a href="#关于《crafting-interpreters》" class="headerlink" title="关于《crafting interpreters》"></a>关于《crafting interpreters》</h2><p>寒假同时还一直在看一个外国老哥写的《crafting interpreters》，一本带着你写解释器的书。</p><p>从去年就一直在看，从最开始用Java写，到第二步，使用c语言实现一个解释器，这本书真的就像作者自己说的那样，带你实现一个简单的解释器，破除对于编程语言的蜜汁害怕，让你发现，语言原来没那么高深。（至少语言的本质是能有所了解的）</p><p>去年的博客里，就有我自己翻译这本书的文章，不过一共就只有3篇，后面也没翻译了，因为涉及到的名词还是很多的，同时本人有比较懒。</p><p>当然最最重要的一点，也是为什么我专门写了一个小标题，就是这本书的质量真的非常好，写的也是很通俗易懂，直接看英文，比看我这种二流程序员翻译了一遍，要好很多。</p><p>我的翻译水平也不是很行，真的直接看原文，反而能够理解作者的意思，同时还能get到很多有梗，开玩笑的地方。而且这本书中的所有插图，全是作者自己画的！非常厉害，画的很精美，且很好地帮助读者理解一些概念。</p><p>所以我还是推荐大家直接去这本书的网站去看。目前这本书是作者公开在网络上的，完全免费的，想要了解一些关于编程语言的同学，试着去读一下这本书，还可以锻炼自己的英文阅读能力，以后毕业写论文也绝对是用得上的。</p><h1 id="引出问题"><a href="#引出问题" class="headerlink" title="引出问题"></a>引出问题</h1><p>最开始学习软件方面的时候，是在大三的时候学习了Java课程，OOP给当时的我，带来了很大的影响。</p><p>因为大一的时候，学习了c语言，但也只是学了最简单的数据类型，控制流，再深入的老师也没教，所以我一直又个疑问，那就是学了编程语言，到底怎么做出那些看着很厉害的软件的，就靠这些if else吗？</p><p>后来学了OOP，动手写了一个自动售货机的实验，当时还分成了展示层、服务层和数据层，慢慢地让我了解了怎么写出一个看上去还行的“东西”，起码它可以交互了。</p><p>后来慢慢开始深入地学习Java，学习了框架，开始了解多线程，了解到了JVM。</p><p>但是，仍然有一个问题让我感到很疑惑：多线程里，线程是怎么切换的？</p><p><strong>ps：本文有点硬核，并且作者水平有限，但也尽量做到能够用白话讲这个过程讲清楚。</strong></p><h1 id="C语言文件到底是怎么运行的？"><a href="#C语言文件到底是怎么运行的？" class="headerlink" title="C语言文件到底是怎么运行的？"></a>C语言文件到底是怎么运行的？</h1><p>在讲解线程切换的原理之前，我们先弄清楚C语言文件到底是如何跑起来的。在理解这个问题之后，线程切换就好理解多了</p><p>CPU其实就很像一个流水线上的工人，只不过这个工人的效率实在是太高了。</p><p>CPU只识别的了机械码，也就是那一堆一堆的“0010100101010101……”。</p><p>对于CPU来说，执行这些机械码，效率是很高的。但是缺点嘛，显而易见，那就是人太难看懂了。</p><p>难道我们只能背下来所有的机械码，然后一个一个地输入0和1吗？</p><p>前人们显然也觉得这样写程序效率非常低，而且专业性太高了。</p><p>所以他们在想，我们能不能发明一种东西，我们人类按照规定好的方式写，用这个“东西”帮我们翻译成机械码？对，这就是后来的汇编语言以及对应的编译器。</p><p>后来人们发现汇编语言还是有点晦涩难懂，而且不断地操作那些寄存器，太麻烦了，就不能更方便一些吗？对，这就是后来的C语言。</p><p>总结，也就是说，我们写出来的C语言文件，都是通过gcc（GNU C Complier）来进行编译，转成CPU能直接理解的机械码，让CPU来运行。</p><p>实际上CPU是不认识C语言是什么的，它只会不厌其烦，或者说应该叫，锲而不舍地运行CS：IP指向的下一条机械码（CS：IP本文就不展开介绍了，这又涉及到计算机的基础知识，不清楚的读者建议去搜索，或者看看计算机相关的基础书籍），我们先用我们好理解的C语言写出程序，然后通过gcc这样一个工具，把它变成机械码，让CPU执行。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/image-20210314202800431.png" alt="image-20210314202800431"></p><p>总结：我们平常用的高级语言，例如C语言，实质上是使用编译器将其转化为了机械指令，然后CPU运行的就是编译后的机械指令。</p><h1 id="那么Java中的线程，和上面说的C语言有什么联系呢？"><a href="#那么Java中的线程，和上面说的C语言有什么联系呢？" class="headerlink" title="那么Java中的线程，和上面说的C语言有什么联系呢？"></a>那么Java中的线程，和上面说的C语言有什么联系呢？</h1><p>是这样的，用《操作系统真象还原》书中所说的，我们平时使用高级语言（C、Java、python等等）写出来的程序，都是“半成品”。</p><p>为什么说是半成品呢，因为我们的程序在运行时，是属于“用户态”的，是无法使用包括但不限于：读写硬盘（也就是IO操作）、读写内存等操作的。这些操作是由“内核态”的程序来提供的，这些操作是实打实会影响计算机的行为，所以“内核态”的程序（也就是操作系统）不放心用户，害怕用户乱操作会把电脑弄坏，因此操作系统会把这些操作封装起来，只提供一定的接口，让我们“用户态”的程序来调用。</p><p>所以我们写出来的程序只能完成一部分的逻辑操作，涉及到上面说的那些重要操作，就不得不与操作系统进行交互。我们准备好数据，交给操作系统，操作系统做完后，把结果返回给我们，我们的用户程序实际上不知道操作系统怎么完成这些操作的。并且如果用户程序想要搞破坏，操作系统也是有权利拒绝这些违规操作。（甚至可以说一些能很容易破坏计算机正常运行的操作，操作系统都是有责任向用户屏蔽，不提供给用户的）</p><p>而作为高级语言之一的Java，其中的线程，恰好就是操作系统封装好，防止我们乱用，给我们提供的功能。</p><p>所以实质上，Java的线程，底层上来说就是操作系统帮我们做好的线程操作，Java对其进行了一定的封装，只提供一些较为安全且易用的操作。比如HotSpot VM，其每个线程都对应了一个内核级线程。（虚拟机的线程模型有1:1（内核线程）、N:1（用户态线程）、M:N（混合）三种，虚拟机规范中没有规定一定要用哪种，所以三种模型都有被使用，HotSpot VM就是1:1模型，即Java语言中的一个线程与内核级线程是1:1）</p><p>而很多操作系统，都是使用C语言开发后，编译成了机械指令，运行起来的，所以想要知道线程是怎么切换的，还是要看操作系统对于线程切换的实现。</p><h1 id="操作系统的线程"><a href="#操作系统的线程" class="headerlink" title="操作系统的线程"></a>操作系统的线程</h1><p>本文所写的线程实现，出自《操作系统真象还原》这本书中，虽然和linux的实现方式可能有些小的出入，但思路是参考了linux，因此大同小异。</p><h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><p>首先我们要明白，线程切换本质是并发。</p><p>以下举例是在单核CPU运行的情况下，多核我们暂时不讨论，毕竟饭一口一口吃，先弄懂基础的。</p><p>什么是并发？就是在一段时间内，例如1000ms内，我以极快的速度在程序A与程序B之间切换，保证了每运行程序A 2ms之后，就换到程序B运行2ms，再切换回程序A，反反复复。</p><p>那么相比于2ms，1000ms看起来就很长，也就是说，1000ms内，程序A与B每个都平均地运行了500ms。而且由于切换的非常快，在我们人类的宏观来看，就像这1000ms内，程序A与B都在同时运行一样。</p><p>所以<strong>并发</strong>在微观上，<strong>同一时刻</strong> 只有一个程序在运行，只不过由于不停地在切换，所以从宏观上来看，像是两个或多个程序在同时运行。</p><p>而<strong>并行</strong>就是实打实的多个程序在同一时刻同时运行，一个核心的CPU理论上是无法做到这个操作的，只有多个核心可以。</p><h2 id="线程是由谁切换的？"><a href="#线程是由谁切换的？" class="headerlink" title="线程是由谁切换的？"></a>线程是由谁切换的？</h2><p>既然是并发，要涉及到切换来切换去。</p><p>那么是谁来进行的切换呢？总不能用户程序自己切换吧，那不就乱了套嘛！我作为一个开发者，我肯定希望我的程序能一直运行下去啊。</p><p>这也是人之常情，毕竟大家都想争夺资源嘛。但如果满足每个人，或者说程序的要求，让他们自己切换程序，给予它们绝对的自由，那必定乱套。所以这个工作，必须由一个有权威、德高望重的“人”来做，才能保证每个用户程序相对来说的公平。毕竟绝对自由意味着混乱，有一定约束的自由才是合理且可能的自由。</p><p>好吧，我摊牌了，上面说的德高望重的“人”，其实就是操作系统。</p><p>这也是为什么，线程是操作系统管理的一项功能，只给用户程序提供一定的接口，剩下的很多操作用户程序是接触不到的。</p><p>那么读者此时暂停一下阅读，简单思考一下，以什么样的规律来切换呢？</p><p>其实我上面暗示的已经很明显了，对，就是每个程序都固定运行相同的时间。</p><p>实际上操作系统用的也是这种思路，不过操作系统还加了一个优先级，来控制这个运行时间的长短。这段运行的时间叫<strong>时间片</strong>。</p><p>操作系统的优先级决定了时间片的大小，优先级高，自然时间片长，在该程序上运行的时间就越高，从宏观上来说，运行的就越快。</p><h2 id="那么怎么实现每隔一段时间进行切换呢？"><a href="#那么怎么实现每隔一段时间进行切换呢？" class="headerlink" title="那么怎么实现每隔一段时间进行切换呢？"></a>那么怎么实现每隔一段时间进行切换呢？</h2><p>上面说到，切换必须由操作系统来做，保证用户程序不会乱来。</p><p>那么，这个间隔的产生，也一定要经过操作系统之手，由操作系统来协调。</p><p>在计算机系统中，有定时器这样一种芯片，专门用来处理定时操作，为CPU减负。</p><p>计算机系统中有两种定时，一种是CPU硬件内部的定时，这个定时是给CPU提供时序，为CPU提供一个处理指令的节奏。因此这个定时非常重要，不允许软件进行修改（ps：虽然操作系统已经很底层，但其实质还是个软件），硬件厂商也没有提供能够修改该定时的操作。</p><p>而另外一种就是外置定时，提供给”用户”（此处指写操作系统的人）使用，来作为一种节奏，控制程序运行。</p><p>操作系统正是使用该定时器，来定时的。本文不涉及定时器芯片的知识，如果有兴趣，读者可以自己去网上搜索定时器的手册。</p><p>设定一个频率，比如每2ms，定时器就向终端芯片发送中断，告诉CPU，定的时间已经到了。</p><p>此时CPU进入到了中断处理程序，检查当前线程的时间片是否还有，如果还有，就推出中断处理，线程继续运行。如果没有时间片了，则重置其时间片，并把该线程放入到”准备队列”中，以便以后还可以再次调度过来。</p><p>放入队列后，下一步就要切换到别的线程去了。</p><h2 id="终于到线程切换了"><a href="#终于到线程切换了" class="headerlink" title="终于到线程切换了"></a>终于到线程切换了</h2><p>上面所有的内容，都可以总结为一句话：</p><p>CPU通过定时器计时，一旦定时器到了定的时间，就通知CPU，CPU就运行中断处理程序，去检查是否要进行切换。</p><p>那么，到重点了，到底是怎么切换的呢？</p><p>其实很简单，既然CPU只会执行CS：IP指向的指令。那我们直接把CS：IP改成另一个线程的程序中，不就可以了嘛。</p><p>是的，线程切换实质就是修改CS：IP，但是我们切换线程切出去了，总要还得切换回来吧！</p><h2 id="上下文保存"><a href="#上下文保存" class="headerlink" title="上下文保存"></a>上下文保存</h2><p>CPU在运行时，会把数据存到寄存器或者内存中。</p><p>寄存器由于其结构设计，其速度与CPU是同一个数量级的，而内存就慢了很多，因此CPU更倾向于使用寄存器。</p><p>所以CPU经常将内存中的数据加载到寄存器中，然后通过寄存器操作来实现各种功能。</p><p>线程在运行时，部分数据会保存在寄存器中，也就是说，每个线程运行程序时，其寄存器里的值都是不同的，跟当前运行的程序有关。</p><p>那么如果我们直接修改了CS：IP，跳到别的线程了，本来寄存器就少，当前线程全部使用了，切换后的线程要运行，就得把原来寄存器中的值被覆盖了。</p><p>当我们试图切换回来时，原来线程运行时，寄存器的值找不到了，那程序再往下运行就可能出事了。</p><p>所以我们在修改CS：IP前，还要把各种寄存器保存起来，放到一个规定好的数据结构中保存。</p><h2 id="具体的切换代码"><a href="#具体的切换代码" class="headerlink" title="具体的切换代码"></a>具体的切换代码</h2><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/image-20210321192317260.png" alt="image-20210321192317260"></p><p>可以看到，在7到12行，是将切换前的线程的上下文进行保存。</p><p>接着从16行开始，加载下一个线程的环境。</p><p>在切换线程时，此时esp指向的栈中，数据的分布入上图所示。</p><h2 id="整个线程切换的流程图"><a href="#整个线程切换的流程图" class="headerlink" title="整个线程切换的流程图"></a>整个线程切换的流程图</h2><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/mac/image-20210321193225049.png" alt="image-20210321193225049"></p><ol><li>可以看到，每当定时器计时结束，会像①一样，进入中断处理程序</li><li>此时，在中断处理程序中，会判断当前线程（也就是线程A）的时间片是否用完，如果用完，意味着就要切换了</li><li>在图中，第一次进入中断处理程序时，假设线程A时间片未用完，所以CPU会按照②，继续执行线程A</li><li>第二次进入中断处理程序时，假设此时线程A的时间片用完了，就会按照③，切换到线程B，也就是上面所说的，保护上下文、加载下个线程的上下文的操作</li><li>后面的操作都是一样的，当线程B时间片用完了，会切换到别的线程</li><li>如果当前不只两个线程，就要涉及到线程切换的调度，后面文章会写到</li></ol><p><strong>从图中可以看出，虽然我们用线程切换，但实际上，每个时刻，只有一个程序在运行，所有的都是在一条时间线上，只不过我们通过多次且频繁地切换，让用户看起来，线程A与线程B都在运行。</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文由于跳过了中断的讲解，直接描述了线程切换，所以讲的可能不太好，有兴趣的读者，还是去找一本比较好的书去看看。</p><p>我也尽自己最大的努力去解释这个过程，毕竟学习掌握的最高境界就是能够给别人讲懂。</p><p>同时本文对于线程调度这一块没有具体展开。调度算法非常多，后面可能会更新关于调度算法的文章。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h2 id=&quot;寒假期间的安排&quot;&gt;&lt;a href=&quot;#寒假期间的安排&quot; class=&quot;headerlink&quot; title=&quot;寒假期间的安排&quot;&gt;&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>我的 2020 下半年 - 个人的一些感想与总结</title>
    <link href="https://blog.matrix-world.top/2021/01/11/%E6%88%91%E7%9A%842020%E4%B8%8B%E5%8D%8A%E5%B9%B4%20-%20%E4%B8%AA%E4%BA%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.matrix-world.top/2021/01/11/%E6%88%91%E7%9A%842020%E4%B8%8B%E5%8D%8A%E5%B9%B4%20-%20%E4%B8%AA%E4%BA%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3%E4%B8%8E%E6%80%BB%E7%BB%93/</id>
    <published>2021-01-11T06:30:00.000Z</published>
    <updated>2021-03-15T10:38:03.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我的2020下半年-个人的一些感想与总结"><a href="#我的2020下半年-个人的一些感想与总结" class="headerlink" title="我的2020下半年 - 个人的一些感想与总结"></a>我的2020下半年 - 个人的一些感想与总结</h1><h2 id="开学，成为一名烟酒生-｜-9月"><a href="#开学，成为一名烟酒生-｜-9月" class="headerlink" title="开学，成为一名烟酒生 ｜ 9月"></a>开学，成为一名烟酒生 ｜ 9月</h2><p>刚开学，一切都是崭新的，又都是熟悉的。</p><p>本来以为要抢宿舍，所以很早定了开学前一天的酒店。</p><p>结果谁知道，直接给统一分配了。说来也很有意思，一开始导员说因为扩招，房源可能不够，大家在群里义愤填膺，纷纷吐槽学校。</p><p>结果离开学没几天，导员突然通知房源够，并且自己组宿舍。并且让我们自己把宿舍名单填到腾讯的在线文档里。</p><p>我们宿舍的几个，基本都是认识的，一群卧龙凤雏（</p><p>宿舍关系还是很融洽的，一个个都是老带哥了，各种带节奏，停不下来。</p><p>而且宿舍分到了南湖新的越苑宿舍，新的宿舍虽然是赶工才装修好的，但是空间相比于鉴湖六人间来说，还是大了不少，尤其是每个人的柜子大小变大了，能放不少衣服，不像以前鉴湖六人间，衣服都没啥地方放，太难了。</p><p>最让我感觉惊喜的是，居然有个小阳台！太爽了，那种站在阳台上，面朝阳光迎接新的一天的感觉，太舒服了（除了第一个月，其余时间从来没有在太阳刚刚亮的时候醒过 :P ）</p><p>崭新的宿舍，崭新的实验室环境，崭新的同学（好像同学不能用崭新形容？）</p><p>然而转了几圈，还是回到了鉴湖，那熟悉而又陌生的鉴湖。熟悉的鉴湖，因为疫情，只有东门开着，每天进出还要打卡。</p><p>尤其是我们还要去西院上课，就得绕远路从东门出去，再从工大路的一头走到另一头，太累了。每天上课，至少40分钟花在路上，就算是强身健体吧。</p><p>虽然烟酒生和我想象的还是有点出入，但我对实验室的所有设施，我们的d9lab基本都有。比较宽敞的桌子，服务器，外接显示器，基本都有，椅子还挺舒服，哈哈。</p><h2 id="成长、变强-｜-10月"><a href="#成长、变强-｜-10月" class="headerlink" title="成长、变强 ｜ 10月"></a>成长、变强 ｜ 10月</h2><h3 id="课开始多了起来-｜-10月上旬"><a href="#课开始多了起来-｜-10月上旬" class="headerlink" title="课开始多了起来 ｜ 10月上旬"></a>课开始多了起来 ｜ 10月上旬</h3><p>慢慢地课全部都开了，每天基本上就是忙于上课，还好大部分课都是西院，也就走个40分钟。</p><p>有一节《机械学习》课，要去东院，走过去，起码要花费1个小时，简直离谱。</p><p>好在这课是早上第二节上课，也就是9点55上课，我可以8点半起来，然后走过去，顺带在路上吃个早饭。（众所周知，走着路吃饭是湖北人的特殊技能）</p><p>我早上的课，全部都是第二节上课，所以这个学期也没有因为早起而被折磨。倒是我的两个室友，他俩是专硕，和我们学硕的课时间排的不太一样，他们这学期有两门课是早上8点在西院上课，被折磨的不行。</p><p>这个月我们也逐渐脱离了杜哥那边，慢慢地没什么事情了，基本就是自己在学习。</p><p>9月到10月份，我也把《Java核心技术》、《Java并发编程》粗略地看了一遍，不过由于没有项目驱动，收获的知识并没有那么多。</p><h3 id="开始接触到linux-｜-10月中旬"><a href="#开始接触到linux-｜-10月中旬" class="headerlink" title="开始接触到linux ｜ 10月中旬"></a>开始接触到linux ｜ 10月中旬</h3><p>这个学期开学，我准备好好学习一些linux。之前刚考完研那会，自己整了个阿里云的服务器，第一次接触到centos，第一次知道服务器能干这么多事情。</p><p>最开始我搭建了一个个人博客，然后部署了一堆整活的东西，不过最后还是觉得索然无味。而且服务器总共才4G内存，部署不了太多东西。</p><p>那个时候用centos，只知道一些非常基础的指令，也都是听java课学到了一些，要让我自己对系统进行一定的操作和定制的话，仍然还是像个小白。</p><p>尤其是那个vim，最开始我连怎么输入，怎么退出都不知道。这可能也是所有刚接触服务器的同学，都会遇到的问题，实在是太头疼了。</p><p>由于老师给了我一个老项目，是关于皮肤算法的，为了把那个代码跑起来，我只能按照学长说的来配环境。</p><p>当时年少不知Ubuntu香，win10安装依赖把我折磨了3天，仍然还是有问题，尤其是opencv之类的库，需要自己下载源码，用mingw或者vs来编译，CMakeList也看不太懂，被折磨的是在快受不了之后，学长给我指了条明路，换成Ubuntu来安装依赖。</p><p>我立马换到实验室的服务器上进行我的“配环境之旅”。好家伙，按照网上的流程，几句命令行，刷刷刷，就安装好了，看着命令行里不断出现字符，而且大多都夹杂着“Success”之类的字符，那感觉不谈了，太爽了。</p><p>也正是这段时间，我开始接触使用Ubuntu，由于自己指令用的少，很多指令都不会，我就只能遇到问题，去查，或者看看我室友的一本《linux从入门到精通》，去学习。</p><p>果然，学习一个东西，技能，或者说知识，最快的方法，就是使用它。用的次数多了，自然就记得住了。</p><p>那几个星期我使用linux的熟练度慢慢高了起来，对于很多操作，渐渐只用命令行也可以完成了。用多了命令行，就慢慢觉得既然我能只用键盘，加上敲几个指令就能完成的事，我为什么还要用图形界面？</p><p>当时命令行用熟练起来之后，慢慢开始膨胀起来了。其实无论是图形界面还是命令行，都有其存在的意义，没有必要踩一捧一。</p><p>不过确实感觉Ubuntu的命令行，比起win10的cmd，好太多了，整体观感这方面，确实舒服一些。不过win10上也有powershell以及不少还不错的终端可以用，这里就不一一列举了。（不过win10下面有个wsl，即windows subsystem linux，很好用，读者们可以试试）</p><h2 id="linux的使用渐入佳境-｜-11月"><a href="#linux的使用渐入佳境-｜-11月" class="headerlink" title="linux的使用渐入佳境 ｜ 11月"></a>linux的使用渐入佳境 ｜ 11月</h2><h3 id="慢慢开始整活-｜-11月初"><a href="#慢慢开始整活-｜-11月初" class="headerlink" title="慢慢开始整活 ｜ 11月初"></a>慢慢开始整活 ｜ 11月初</h3><p>进入11月，linux的使用也更加熟练了。</p><p>但是有一个问题困扰了我，那就是，如何才能在远程连接我们实验室的服务器呢？毕竟我也是个懒人，在服务器和我自己位置之间来回跑，太累了。</p><p>所以说有些进步都是因为人的“懒”，而促使人来进行折腾、创新（不过我这不算创新，只能算用前人的留下的智慧）</p><p>于是我就分析，为什么我的电脑和服务器都在实验室内，但是我却连接不上服务器呢？</p><p>哦，源赖氏（原来是）因为服务器和我的电脑不在同一个内网。我在网上查阅了一些资料之后，发现内网穿透可以解决这些问题。</p><p>后面的内容就是前两篇博客了。</p><p>而后，我还把Ubuntu给美化了一下，shell也改成了zsh（好看就完事了）。</p><p>经过这段时间的使用以及折腾，我光荣地成为了一名服务器配置工具人（害）。</p><p>基本上关于服务器这那的问题，同级的同学以及学长们，都直接让我来弄，工具人罢了。</p><p>月底，我一个初中同学（准确来说，he’s my son）找到我，让我帮他完成个东西。</p><p>这个🐶东西原来也学过python，这个学期开学他们有一门课要用到python来进行爬虫，大作业就是用爬虫爬取数据信息之后，再进行分析。</p><p>好家伙，我一看，就是爬个taptap的网页。</p><p>好歹我也是学后端的，同时也浅尝辄止过一些前端方面的东西，直接打开chrome就是一个F12，一个刷新，一个查看网络请求。害，就是用了分页查询而已，只需要改变request里面的page属性，就能获取到原始的数据。</p><p>接着就是用正则表达式，来进行模版匹配，最后把数据给他爬出来。用了大概2个小时左右，完成了这个代码，然后把数据发给my son，他直接惊呆了，夸了我一波，顺带薅了他一波羊毛，让他给我点了个奶茶外卖。</p><p>没想到，我python没怎么正规学过，就给他解决了他们小组都无法解决的问题。</p><p>看来，我这一年来的学习，还是变强了一些。其实倒不是掌握了多少门语言，掌握的语言数量，并不与能力成正比。我发现计算机的基础知识，才是我变强的原因，只知其一，而不知其二，永远只能做一个代码搬运工。</p><h3 id="开始学习操作系统-｜-11月底"><a href="#开始学习操作系统-｜-11月底" class="headerlink" title="开始学习操作系统 ｜ 11月底"></a>开始学习操作系统 ｜ 11月底</h3><p>11月也过的很快，每天就在开开兴兴整活，学习自己想学的东西，转眼就到了11月底。</p><p>这段时间，我开始慢慢接触到操作系统方面的知识。</p><p>之前疫情在家，我把操作系统通过慕课上东南大学的《操作系统》课程，把基础知识过了一遍，但是还是感觉没有很好地消化掉。仍然还是一知半解的状态，当时想的是，了解一些皮毛知识就行。</p><p>但是之前看到一个公众号的一篇文章，名叫 <a href="https://mp.weixin.qq.com/s/uno-QuRu7wPwIZFhutBLhA" target="_blank" rel="noopener">《程序员都应该挑战的6个项目》</a>，里面都是一些看着好像没什么用（对于找工作），但是对于一个程序员的内功，是一个挑战。</p><p>我觉得读者们都可以看看，这些项目都会推荐相关的书，带领你走进这个方面的大门。</p><p>目前自己写一个编程语言的项目，我已经完成了大半，确实从里面收获了不少，尤其是破除了“编程语言“这层迷雾，有种拨云见日的感觉，对于语言的本质也有了一定的理解。</p><p>虽然仍然还是小白，但是这已经让我在遇到一些问题时，能够从语言本质、底层来思考一些问题。</p><p>把书读了大半，确实受益匪浅。</p><p>说来也是运气好，看了几本书都很不错，让我学到了不少东西，没有因为书选的不好走了弯路。</p><h2 id="开始复习，以及各种考试和大作业-｜-12月"><a href="#开始复习，以及各种考试和大作业-｜-12月" class="headerlink" title="开始复习，以及各种考试和大作业 ｜ 12月"></a>开始复习，以及各种考试和大作业 ｜ 12月</h2><p>这个月开始，考试逐渐多了起来，慢慢地开始复习每一门课。</p><p>操作系统的学习也搁置了起来，主要精力都花费在复习考试上。</p><p>这个月也没啥好说的，每天基本上都是在不想复习和不得不复习之间徘徊。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，这一年，我的成长还是很大的。</p><p>从19年刚开始接触java没多久的小白，慢慢成长为一个懂了一些东西的入门码农。</p><p>虽然还没有正式工作，仍然还是在读书，但是今年的学习状态总体来说符合我自己的预期。</p><p>学了不少东西，有用的，没用的，但是我所理解了的，基本上都装进我的脑子里了。</p><p>在杜哥组里，虽然也经常吐槽杜哥，最后也退出组了，但是这段经历，对于我来说也是一种成长。</p><p>我开始接触各种实际的应用，同时杜哥也给我一些自由来在项目上发挥自己的能力。</p><p>尤其是在写难度控制算法的时候，我很庆幸自己之前读了《算法》这本书，并且把它吸收进我的脑子里，我才能把这个算法写出来。</p><p>虽然这个算法不像目前流行的那些机械学习或者深度学习的算法那样深奥，但这也算是第一次把刚学的知识这么快地应用到实际上。</p><p>还有一件事，向大家推荐一个公众号：码农翻身。</p><p>公众号的作者“刘大”创作的内容，非常有意思。都是用漫画的形式给大家科普各种知识，尤其是关于计算机底层的，非常风趣幽默。</p><p>同时在这里对刘大献上我的敬意，之前在公众号里咨询刘大，刘大也回答了我一些问题，让我对于自己后面学习的路程更加坚定。</p><p>20已过，21继续加油，keep fighting！</p><p>最后送给大家我的一句座右铭：</p><ul><li>Better to run than curse the road</li><li>与其感慨路难行，不如马上出发</li></ul><p>​                                                                                                            —- Javen，2021年1月11日</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;我的2020下半年-个人的一些感想与总结&quot;&gt;&lt;a href=&quot;#我的2020下半年-个人的一些感想与总结&quot; class=&quot;headerlink&quot; title=&quot;我的2020下半年 - 个人的一些感想与总结&quot;&gt;&lt;/a&gt;我的2020下半年 - 个人的一些感想与总结&lt;/</summary>
      
    
    
    
    <category term="个人总结" scheme="https://blog.matrix-world.top/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="2020" scheme="https://blog.matrix-world.top/tags/2020/"/>
    
    <category term="个人总结" scheme="https://blog.matrix-world.top/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>折腾Linux - 2.Shell的进程</title>
    <link href="https://blog.matrix-world.top/2020/11/27/%E6%8A%98%E8%85%BELinux%20-%202.Shell%E7%9A%84%E8%BF%9B%E7%A8%8B/"/>
    <id>https://blog.matrix-world.top/2020/11/27/%E6%8A%98%E8%85%BELinux%20-%202.Shell%E7%9A%84%E8%BF%9B%E7%A8%8B/</id>
    <published>2020-11-27T09:01:00.000Z</published>
    <updated>2021-03-15T10:38:03.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="承接上文"><a href="#承接上文" class="headerlink" title="承接上文"></a>承接上文</h1><p>上一篇中，我们实现了内网穿透，这样我们就可以直接使用SSH连接到内网的服务器。</p><p>一旦可以用SSH连接进入设备，我们就可以掌控设备了（当然还需要root的密码）。</p><p>但是我们关闭了终端之后，连接似乎就断了。这是怎么回事呢？</p><p>本篇博客将深入到Linux，分析问题，最终解决这个问题。</p><h1 id="为什么关闭终端，frp也会自动关闭？"><a href="#为什么关闭终端，frp也会自动关闭？" class="headerlink" title="为什么关闭终端，frp也会自动关闭？"></a>为什么关闭终端，frp也会自动关闭？</h1><p>首先我们要先了解一下shell</p><h2 id="something-easy-about-shell"><a href="#something-easy-about-shell" class="headerlink" title="something easy about shell"></a>something easy about shell</h2><p>shell是什么？</p><p>shell可以理解为是一个夹在用户与操作系统之间的程序，我们在shell中输入指定的指令，点击回车后，shell会对我们输入的指令进行解释（interpret）执行，并与操作系统进行交互。</p><p>所以shell的行为可以拆解为三大部分：</p><ul><li>读取输入命令</li><li>解析命令</li><li>执行命令，并将结果输出</li></ul><p>同时shell中的指令分为了两大类：</p><ul><li>shell自身的 builtin 指令，即shell自身支持的指令，例如：cd、ls等</li><li>shell自身无法解析的指令，这一类多数都是用户自己编写的程序</li></ul><hr><p>我们知道，在操作系统中，运行一个程序，都是需要单独开启一个进程（Process），来供程序运行。</p><p>在Unix上只有两种启动进程的方法。 第一个（几乎用不到）是被初始化。 当Linux计算机启动时，将加载其内核。 加载并初始化后，内核仅启动一个进程，称为Init。 此过程将在计算机打开的整个时间范围内运行，并负责加载计算机需要使用的其余过程。</p><p>也就是说，shell再神奇，也是在process上运行的。</p><p>由于大多数程序不是Init，因此仅留下一种实用的方法来启动进程：fork（）系统调用。 调用此函数时，操作系统将复制该过程并启动它们的运行。 原始进程称为“父进程”，新进程称为“子进程”。 fork（）向子进程返回0，并将其子进程的ID（PID）返回给父进程。 从本质上讲，这意味着新流程的唯一方法就是开始现有流程的复制。</p><p>对于shell自身的 builtin 指令，shell 都会在其自身的主线程中，进行执行的操作。</p><p>而对于非shell本身自带的指令，在linux中，其会使用系统提供的 fork 接口，来创建一个子进程，然后在子进程中运行该指令。</p><p>并且在子进程中运行指令时，主线程，也就是shell所在的进程，会等待子进程的执行结果。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201127213109.png" alt=""></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="shell中的-“-amp-”-指令"><a href="#shell中的-“-amp-”-指令" class="headerlink" title="shell中的 “&amp;” 指令"></a>shell中的 “&amp;” 指令</h2><p>先做一个实验，在shell中，我们进入到之前frp的文件夹，输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c ./frps.ini</span><br></pre></td></tr></table></figure><p>按回车之后，程序开始运行，但此时我们发现，shell 中会输出 frps 程序的日志。</p><p>同时，此时我们的 shell 无法进行其他操作，无法输入下一条指令，只是等待这 frps 程序输出。</p><p>如果此时我们想要执行别的命令，要么就终止 frps 程序，要么就重开一个 shell 程序。</p><p>这就和我们上面说的，主线程会等待子线程执行完毕，但是 frps 程序简单来说，是一直在一个循环里等待连接，所以除非启动失败或者手动关闭，否则这个 shell 就只会一直输出 frps 程序执行的日志。</p><p>此时我们键盘输入 ctrl + c，将程序终止。</p><p>然后输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c ./frps.ini &amp;</span><br></pre></td></tr></table></figure><p>点击回车，运行。</p><p>此时我们发现，我们的 shell 竟然还可以继续输入命令并且运行。</p><p>这正好证实了我们的说法，程序运行在子进程中，同时 shell 的主进程并没有等待子进程程序运行完毕。</p><p>这样不就实现了让 frps 程序在后台运行的效果了嘛。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201128101914.png" alt=""></p><p>上图的终端里，下面开启了我们的程序（作为示范），上面使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep frps</span><br></pre></td></tr></table></figure><p>指令，可以看到后台（也就是子进程）是在运行着 frps 的，而且下面的终端主线程并没有等待该终端子线程程序运行结束。</p><h2 id="但是。。。"><a href="#但是。。。" class="headerlink" title="但是。。。"></a>但是。。。</h2><p>但是 &amp; 指令，只是将程序放在了shell的子进程中运行，那如果shell主进程关闭了，子进程会怎么样呢？</p><p>此时我们将下方的终端关闭。并在上面的终端里继续输入 ps -ef | grep frps 指令，会发现：</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201128102422.png" alt=""></p><p>程序被关闭了，也就是说子进程也关闭了。</p><p>难道想要内网穿透，还得必须打开一个终端？</p><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p>nohup（全称应该是 “no hangup”）这个指令，可以让运行的程序忽略 HUP 信号。</p><p>那么何为HUP信号呢？每当与当前程序运行所在的进程相关的shell关闭时，也就是shell的主进程关闭时，会向子进程发送该信号，使其正在运行的程序关闭。</p><p>如果使用了nohup指令，则会使当前的程序忽略掉 HUP 信号，也就是你的shell关闭后，其仍然可以继续运行，同时将输出信息，输出到当前目录下的 nohup.out。我们可以在nohup.out里查看程序运行的日志。</p><p>OK，那我们再来实验：</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201128103518.png" alt=""></p><p>这次我们使用了nohup指令。然后我们关闭掉下方的shell，也就是启动 frps 程序的主线程。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201128103615.png" alt=""></p><p>可以看到，我们将下方的shell关闭后，frps 程序仍然在运行中，我们可以通过 ps 指令与万能的 grep 指令找到他。</p><p>这样我们也就不用把终端一直挂着，而是随用随关闭。内网穿透就像暗地里的守护者一样，不在我们的视野范围内活动，但是没有他，我们就无法从自己的内网访问我们的服务器了。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>本文从进程的角度，以frps为例，说明了linux中关于shell进程的问题。</p><p>当然作者也是linux入门没多久的新人，如果文章中有什么错误，请联系作者，一起讨论。</p><p>另外作者还想多一句嘴，查询这些资料时，国内的论坛指令参差不齐，只有一篇linux中国的文字像个样子，而且还是完全翻译linux.com上的文章，有能力的同学，还是用谷歌，并且用英文搜索，尤其是可以避开某个C字开头的论坛，文章质量太差了。</p><p>linux本身就是因为开源免费而吸引了那么多技术人员、hacker们来维护、开发的，而某些博主<strong>偷窃、转载</strong>别人的linux技术文章，还设置需要钱才可以看。其中对比不免让人感到可笑而无奈。</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="https://linuxhint.com/how_to_use_nohup_linux/" target="_blank" rel="noopener">https://linuxhint.com/how_to_use_nohup_linux/</a></li><li><a href="https://superuser.com/questions/152688/why-run-a-linux-shell-command-with" target="_blank" rel="noopener">https://superuser.com/questions/152688/why-run-a-linux-shell-command-with</a></li><li><a href="https://brennan.io/2015/01/16/write-a-shell-in-c/（强烈推荐读者们看看，造造轮子，自然就会对轮子的内部结构有一定的认知）" target="_blank" rel="noopener">https://brennan.io/2015/01/16/write-a-shell-in-c/（强烈推荐读者们看看，造造轮子，自然就会对轮子的内部结构有一定的认知）</a></li><li><a href="https://www.jb51.net/article/186059.htm" target="_blank" rel="noopener">https://www.jb51.net/article/186059.htm</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;承接上文&quot;&gt;&lt;a href=&quot;#承接上文&quot; class=&quot;headerlink&quot; title=&quot;承接上文&quot;&gt;&lt;/a&gt;承接上文&lt;/h1&gt;&lt;p&gt;上一篇中，我们实现了内网穿透，这样我们就可以直接使用SSH连接到内网的服务器。&lt;/p&gt;
&lt;p&gt;一旦可以用SSH连接进入设备，</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.matrix-world.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.matrix-world.top/tags/Linux/"/>
    
    <category term="运维" scheme="https://blog.matrix-world.top/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="Ubuntu" scheme="https://blog.matrix-world.top/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>折腾Linux - 1.内网穿透</title>
    <link href="https://blog.matrix-world.top/2020/11/16/%E6%8A%98%E8%85%BELinux%20-%201.%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>https://blog.matrix-world.top/2020/11/16/%E6%8A%98%E8%85%BELinux%20-%201.%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</id>
    <published>2020-11-16T08:26:00.000Z</published>
    <updated>2021-03-15T10:38:03.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文只是记录自己在学习和做项目过程中，折腾的一些东西，并非专业，本人也是linux入门的小白，因为任务驱动，而产生了兴趣，遂开始整活。</p><p>而且将其记录下来，以后忘记怎么弄了，还可以找出来回顾温习一下。</p><p>如有错误或者我理解不深的地方，希望看管们指出来 ：D</p><p>本小白今年9月也开始了烟酒生（雾）的生活，确实烟酒生和自己想象中的有些出入，有好也有坏。但我们实验室里竟然让我发现了个宝贝，那就是实验室的服务器。不过这个服务器的初衷是用来给学长们跑深度学习的，不过除了要毕业的学长，一般也很少有人用。</p><p>这么好的资源竟然没人用？！那不行，那我得整点活。刚开始的时候，基本上完全不太懂linux，也在慢慢看“字典书”（就是那种指令大全类型的，并未涉及到linux内核原理这些的书）。</p><p>以前自己搞了个阿里云服务器，用xshell整过一些东西，比如最基础的搭建个博客啊，部属个项目啊啥的。然后我试图用xshell徒手连实验室的服务器。</p><p>结果那必然是失败啊，根本ping不通啊。拍查了半天，原来我的电脑是连接的校园网，而实验室的服务器（下面简称服务器）在另外一个网络内，这怎么可能访问嘛。</p><p>查了很多资料，发现有两种种解决方法，分别是路由器端口映射和内网穿透。这就是本篇博客的内容了。</p><h1 id="为什么两个内网下的设备无法连通？"><a href="#为什么两个内网下的设备无法连通？" class="headerlink" title="为什么两个内网下的设备无法连通？"></a>为什么两个内网下的设备无法连通？</h1><p>解答这个问题，需要了解网络模型、公网内网</p><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201116165352.png" alt=""></p><p>OSI 七层网络模型由国际标准化组织进行制定，它是正统意义上的国际标准。但其实现过于复杂，且制定周期过长，在其整套标准推出之前，TCP/IP 模型已经在全球范围内被广泛使用，所以 TCP/IP 模型才是事实上的国际标准。TCP/IP 模型定义了应用层、传输层、网际层、网络接口层这四层网络结构，但并没有给出网络接口层的具体内容，因此在学习和开发中，通常将网络接口层替换为 OSI 七层模型中的数据链路层和物理层来进行理解。</p><p><strong>网络接口层</strong>的知识就比较偏向底层硬件。我们平常的做的应用，基本上是在<strong>网际层IP</strong>以及<strong>传输层</strong>的基础上，进行连接，同时在应用层进行各种应用。</p><h2 id="公网与内网"><a href="#公网与内网" class="headerlink" title="公网与内网"></a>公网与内网</h2><ol><li>公有IP地址</li></ol><p>一般称公网中的<strong>IP地址</strong>为公有地址。公有地址由Inter NIC（因特网信息中心）负责，这些<strong>IP地址</strong>分配给<strong>注册</strong>并向Inter NIC提出申请的组织机构。公有地址是全球唯一的，公网中不可能存在两个相同的<strong>IP地址</strong>。</p><p><strong>范围</strong>：除了私有地址以外的地址，都属于公有地址</p><ol start="2"><li>私有IP地址</li></ol><p>一般称内网（即局域网）中的<strong>IP地址</strong>为私有地址。私有地址是<strong>非注册地址</strong>，用于组织机构内部使用。私有地址的范围如下：</p><ul><li>A类IP地址中：10.0.0.0–10.255.255.255</li><li>B类IP地址中：172.16.0.0–172.31.255.255</li><li>C类IP地址中：192.168.0.0–192.168.255.255</li></ul><p>私有地址与公有地址不同，并不是由<strong>Internet</strong>分配的，是不允许出现在<strong>Internet</strong>中的，我们在公网中是看不到<strong>私有IP地址</strong>的，并且公有地址也不会使用上述的三类地址。所以，私有地址是不能直接与<strong>Internet</strong>连接的。</p><p>而如果想用私有地址与Internet连接来访问公网，那该怎么做？这就需要将<strong>私有IP地址</strong>转换成<strong>公网IP地址</strong>，与外部连接。所以，我们平时使用的路由器中会装有一个叫做 <strong>NAT（网络地址转换）</strong> 的软件，我们的路由器中会至少会有一个有效的<strong>公网IP</strong>，<strong>NAT</strong>会将我们的<strong>私有地址</strong>转成路由器中的<strong>公网IP</strong>与外部Internet连接。而同样的，因为使用的是路由器中的<strong>公共的公网IP</strong>来连接Internet，所以这个内网中的PC在Internet中显示的都是路由器的<strong>公共IP</strong>，这样做不仅提供了一定程度的安全，也可以有效的减缓可用的IP地址空间的枯竭问题。</p><p>比较典型的例子就是，我们学校的校园网，就是一个很大的内网，我们在内网中连接wifi，并上网，实际上仍然通过的是 <strong>NAT（网络地址转换）</strong>转换为公网IP来建立连接。</p><h2 id="解决疑惑"><a href="#解决疑惑" class="headerlink" title="解决疑惑"></a>解决疑惑</h2><p>两个设备之间建立连接，相互传送数据，数据会被由多个协议进行封装，即 应用层 - 传输层 - 网络层 - 网络接口层。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201116172011.png" alt=""></p><p>我们的设备是连接了路由器的，路由器下的所有设备都连接在该路由器的子网下，简言之，我们的设备都躲在路由器后。</p><p>我们访问一个网站，或建立一个连接，最终都是以路由器的IP发送出去。</p><p>但因为我们的设备A是主动访问一个公网服务器，路由器在建立连接后，是可以根据我们主动的访问时，网络协议中的信息，而将公网服务器发回来的信息，正确地发送给我们的设备A。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201116184031.png" alt=""></p><p>可是如果另外一个设备B，想要主动地来访问我们的设备A，这个时候，设备B访问的是路由器的IP。而路由器其实也不明白，设备B到底是想和内网下哪一个设备进行连接，因为内网下的设备对外暴露出来的，都是路由器的IP。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/image-20201116184203613.png" alt=""></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="1-路由器端口映射"><a href="#1-路由器端口映射" class="headerlink" title="1.路由器端口映射"></a>1.路由器端口映射</h2><p>路由器端口映射，原理就是指定路由器的一个固定端口（比如6000），使所有访问路由器IP（121.40.XXX.XXX:6000）的数据或信息，都转发到指定设备A的指定端口（例如22端口，用于SSH）。</p><p>那么最终的效果就是我直接访问 121.40.XXX.XXX:6000，路由器知道是转发给设备A的22端口，那我就可以访问到内网中，设备A的22端口了。</p><p>但是设备A除了我设置好的22端口，其他端口仍然还是无法访问，如果想要访问另一个端口，需要在路由器的端口映射中加入响应的映射配置即可。</p><p>可惜的是，我们实验室服务器网络连接的路由器，我不知道管理密码 ：( 。这种方案只能舍弃</p><h2 id="2-内网穿透"><a href="#2-内网穿透" class="headerlink" title="2.内网穿透"></a>2.内网穿透</h2><p>搜索了一些关于内网穿透的工具，比如花生壳、frp以及很多专门做内网穿透的软件，最后发现，除了frp，其他基本上都是收费，就算有免费的，也基本上是半残废。</p><p>但是frp唯一一个要求就是你需要有个自己的云服务器，并且云服务器有公网IP。</p><p>这不，我正好有个阿里云学生机，虽然学生机啥都不行，但它便宜啊！而且还带公网IP，要什么自行车？！</p><p>frp的具体原理图如下：</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201117170928.png" alt=""></p><p>下面就开始我们的配置</p><h3 id="2-1-frp服务端安装配置"><a href="#2-1-frp服务端安装配置" class="headerlink" title="2.1 frp服务端安装配置"></a>2.1 frp服务端安装配置</h3><p>这里服务端，就是我们的阿里云服务器，使其作为frp的server端，接收client的连接</p><p>首先我们在终端依次输入下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取github上frp打包好的release包</span></span><br><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.22.0/frp_0.22.0_linux_amd64.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压下载的.tar.gz压缩文件</span></span><br><span class="line">tar -zxvf frp_0.22.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>这里注意一点，由于服务器使用的是centos，因此一定要选的linux，其次amd64代表了设备的架构，一般都是amd64。如果选择错误的平台类型，自然下载下来的文件是无法运行的。</p><p>解压之后的文件目录如下图</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201117172039.png" alt=""></p><p>其中 frpc_remote_ftp.ini 以及 nohup.out 是后续加进来的，如果解压后目录里没有是正常的。</p><p>此时，我们输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim frps.ini</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果提示没有权限，则在命令前加上 sudo ，并输入root的密码即可</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如：sudo vim frps.ini</span></span><br></pre></td></tr></table></figure><p>其初始化配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port &#x3D; 7000</span><br></pre></td></tr></table></figure><p>bind_port 代表了 frps 作为 server 监听的是 7000 端口，这个设置可以自定义。</p><p>然后我们在非插入模式下输入 :wq ，并点击回车退出vim。（具体vim的操作，自行百度。当然如果为了省事，可以使用 gedit 指令来打开文件）</p><p>此时，我们在当前 frp 文件的目录下输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c ./frps.ini</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201117172600.png" alt=""></p><p>如果命令行出现上述输出，则表示启动成功，接下来就是内网设备启动 frpc 连接到 frps</p><h3 id="2-2-frp客户端配置"><a href="#2-2-frp客户端配置" class="headerlink" title="2.2 frp客户端配置"></a>2.2 frp客户端配置</h3><p>在我们的内网设备中，仍然需要下载 frp。下载以及解压的方式同 [2.1frp服务器端配置](#2.1 frp服务端安装配置) 一样。</p><p>解压后，进入目录，因为内网设备是作为 client ，连接到 server，因此我们启动的是 frpc。</p><p>接下来我们配置 frpc.ini，命令行中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim frpc.ini</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果提示没有权限，则在命令前加上 sudo ，并输入root的密码即可</span></span><br></pre></td></tr></table></figure><p>其初始化配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line"># 此处需要修改为公网设备的IP</span><br><span class="line">server_addr &#x3D; 121.XXX.XXX.XXX</span><br><span class="line"># 注意此处的server_port需要与服务器端配置中的bind_port相同</span><br><span class="line">server_port &#x3D; 7000</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type &#x3D; tcp</span><br><span class="line">local_ip &#x3D; 127.0.0.1</span><br><span class="line">local_port &#x3D; 22</span><br><span class="line"># 此处配置的端口就是后续用ssh访问时，预设的端口</span><br><span class="line">remote_port &#x3D; 6000</span><br></pre></td></tr></table></figure><p>修改完毕并退出后，我们在命令行中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc -c ./frpc.ini</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201117173924.png" alt=""></p><p>如果没有黄色报错，那么久启动成功了</p><h3 id="2-3连接测试"><a href="#2-3连接测试" class="headerlink" title="2.3连接测试"></a>2.3连接测试</h3><p>此时我们打开自己电脑的 xshell，创建一个新的连接：</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20201118143303.png" alt=""></p><p>其中 “名称” 可以随便填，“主机” 填的就是我们公网IP设备的IP地址（例如 121.XXX.XXX.XXX），端口号一定要与frp客户端配置中的 remote_port 相同。</p><p>配置好之后，点击确定，然后连接即可。</p><p>当然这一步作者只简单描述了步骤，关于具体xshell的操作，可以自行谷歌。</p><p>至此，我们的frp内网穿透就完成了。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>我们完成了内网穿透，可以通过转发，来访问到内网服务器的22端口，以此建立起ssh连接。</p><p>但是仍然有些许问题：</p><ol><li>我们运行 frpc 或者 frps 程序后，此时终端会等待 frpc 与 frps 程序运行完毕，才可以运行其他指令。那为了保证连接，难道必须一直打开终端吗？</li><li>每次关机之后，frpc 与 frps 就会关闭。对于公网IP设备，本来就是云服务器，一直开着还没啥问题。但是内网设备有时是需要重启的，那怎么才能让 frp 程序随开机自启动呢？</li></ol><p>上面两个问题也是我之前的疑问，不过后来查询各种资料与博客，才解决掉，总的来说算是处理的比较不错，基本上只要内网设备开着机，我就能连上。</p><p>具体的做法，由于篇幅限制，就不在这篇博客里赘述了，下一篇博客会写关于这方面的内容。</p><p>当然由于人之初，性本懒 （  : P  ），更新还是随缘。</p><p>最后还是感谢读者看完这篇文章，谢谢支持</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="https://juejin.im/post/6844904049800642568" target="_blank" rel="noopener">https://juejin.im/post/6844904049800642568</a></li><li><a href="https://www.jianshu.com/p/ad7cd1d5be45" target="_blank" rel="noopener">https://www.jianshu.com/p/ad7cd1d5be45</a></li><li><a href="https://juejin.im/post/6844903766701899784" target="_blank" rel="noopener">https://juejin.im/post/6844903766701899784</a></li><li><a href="https://sspai.com/post/52523" target="_blank" rel="noopener">https://sspai.com/post/52523</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文只是记录自己在学习和做项目过程中，折腾的一些东西，并非专业，本人也是linux入门的小白，因为任务驱动，而产生了兴趣，遂</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.matrix-world.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.matrix-world.top/tags/Linux/"/>
    
    <category term="运维" scheme="https://blog.matrix-world.top/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="Ubuntu" scheme="https://blog.matrix-world.top/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>JVM 笔记 - 16 垃圾回收相关概念</title>
    <link href="https://blog.matrix-world.top/2020/08/29/JVM%20-%2016.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <id>https://blog.matrix-world.top/2020/08/29/JVM%20-%2016.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</id>
    <published>2020-08-29T07:31:00.000Z</published>
    <updated>2021-03-15T10:38:03.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc() 的理解"></a>System.gc() 的理解</h1><ul><li>在默认情况下，通过 System.gc() 或者 Runtime.getRuntime().gc() 的调用，<strong>会显式触发Full GC</strong>，同时对老年嗲和新生代进行回收，尝试释放被丢弃对象占用的内存</li><li>然而 System.gc() 调用附带一个免责申明，无法保证对垃圾收集器的调用</li><li>JVM实现者可以通过 System.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无需手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用 System.gc()</li></ul><h1 id="内存溢出（OOM）"><a href="#内存溢出（OOM）" class="headerlink" title="内存溢出（OOM）"></a>内存溢出（OOM）</h1><ul><li>内存溢出相对于内存泄露来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一</li><li>由于GC一直在发展，所以一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况</li><li>大多数情况下，GC会进行各种年龄段的垃圾回收，知道最后会Full GC，这时候会回收大量内存，供应用程序继续使用</li><li>javadoc中对于OutOfMemoryError的解释是，<strong>没有空闲内存，并且垃圾收集器也无法提供贡多内存</strong></li></ul><h2 id="没有空闲内存的情况"><a href="#没有空闲内存的情况" class="headerlink" title="没有空闲内存的情况"></a>没有空闲内存的情况</h2><p>Java虚拟机的堆内存不够，原因有二：</p><ol><li><p>Java虚拟机的堆内存设置不够</p><p>比如：可能存在内存泄露问题；也很有可能是堆的大小不合理，比如我们要处理比较客观的数据量，但是没有显示指定JVM堆大小或者指定数值偏小。我们可以通过 -Xms 和 -Xmx 来设置</p></li><li><p>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</p><p>对于老版本的Oracle JDK，因为用接待的大小是有限的，并且JVM对于永久代垃圾回收（如：常量池回收、卸载不再需要的类）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError非常多见，尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间， 也会导致OOM问题。对应的异常信息会标记出来和永久代相关：</p><p><strong>“java.lang.OutOfMemoryError: PermGen space”</strong></p><p>随着元空间的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，信息变成了：</p><p><strong>“java.lang.OutOfMemoryError: Metaspace”</strong></p></li></ol><p>这里面隐含着一层意思是，在抛出OutOfMemoryError之前，通常垃圾收集器会被处罚，尽其所能去清除出空间</p><ul><li>例如：在引用机制分析中，涉及到JVM回去尝试回收<strong>软引用指向的对象</strong>等</li><li>在java.nio.BIts.reservememory()中，我们能清楚的看到，System.gc()会被调用，以清除空间</li></ul><p>当然，也不是任何情况下垃圾收集器都会被触发的</p><ul><li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutOfMemoryError</li></ul><h1 id="内存泄漏（Memory-Leak）"><a href="#内存泄漏（Memory-Leak）" class="headerlink" title="内存泄漏（Memory Leak）"></a>内存泄漏（Memory Leak）</h1><p>也称为“存储渗漏”。<strong>严格来说，只有对象不在呗程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏</strong></p><p>但实际情况下很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做<strong>宽泛意义上的“内存泄露”</strong></p><p>尽管内存泄露并不会立即引起程序崩溃，但是一旦发生内存泄露，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutOfMemory异常，导致程序崩溃</p><p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200831163504.png" alt=""></p><h1 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h1><p>Stop-the-World，简称STW，指的是GC时间发生过程中，<strong>会产生应用程序的停顿。停顿产生时整个应用程序线程会被暂停，没有任何响应</strong>，有点像卡死的感觉，这个停顿称为STW</p><p>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿</p><ul><li>分析工作必须在一个能确保一致性的快照中进行</li><li>一致性指整个分析期间整个执行系统看起来像是被冻结在某个时间点上</li><li><strong>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</strong></li></ul><p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是卡顿造成，所以需要减少STW的发生</p><ul><li>STW和采用哪款GC无关，所有的GC都有这个事件</li><li>哪怕是G1也不能完全避免STW情况下在，只能说垃圾回收器越来越优秀，收集效率越来越高，尽可能地缩短了暂停时间</li><li>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉</li><li>开发中不要用System.gc()，会导致STW的发生</li></ul><h1 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h1><h2 id="并发（Concurrent）"><a href="#并发（Concurrent）" class="headerlink" title="并发（Concurrent）"></a>并发（Concurrent）</h2><ul><li>在操作系统各种，是指一个时间段中有几个程序都除以以启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行</li><li>并发并不是真正意义上的“同时执行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间内来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时进行</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200831171808.png" alt=""></p><h2 id="并行（Parallel）"><a href="#并行（Parallel）" class="headerlink" title="并行（Parallel）"></a>并行（Parallel）</h2><ul><li>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称为并行</li><li>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行</li><li>适合科学计算，后台处理等弱交互场景</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200831172407.png" alt=""></p><h2 id="垃圾回收的并行和并发"><a href="#垃圾回收的并行和并发" class="headerlink" title="垃圾回收的并行和并发"></a>垃圾回收的并行和并发</h2><p>并发与并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p><ul><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程任处于等待状态，如ParNew、Parallel Scavenge、Parallel Old</li><li>串行（Serial）：相较于并行的概念，单线程执行。如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收，回收完在启动程序的线程</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200831173635.png" alt=""></p><ul><li>并发（Concurrent）：值用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行<ul><li>用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上</li><li>如：CMS、G1</li></ul></li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200831174317.png" alt=""></p><h1 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h1><h2 id="安全点（Safe-Point）"><a href="#安全点（Safe-Point）" class="headerlink" title="安全点（Safe Point）"></a>安全点（Safe Point）</h2><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点”</p><p>Safe Point的选择很重要，<strong>如果太少可能导致GC等待时间太长，如果太频繁可能导致运行时的性能问题</strong>。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。</p><p>比如：<strong>选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等</strong></p><hr><p>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p><ul><li><p>抢先式中断：（目前没有虚拟机采用了）</p><p>首先中断所有线程，如果还有线程不在安全点，就恢复线程，让线程跑到安全点</p></li><li><p>主动式中断：</p><p>设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起</p></li></ul><h2 id="安全区域（Safe-Region）"><a href="#安全区域（Safe-Region）" class="headerlink" title="安全区域（Safe Region）"></a>安全区域（Safe Region）</h2><p>Safe Point机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safe Point。</p><p><strong>但是程序“不执行”的时候？</strong>例如线程处于Sleep状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决</p><p><strong>安全区域是指一段代码中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的</strong>。我们吧Safe Region看作是被扩展了的Safe Point</p><hr><p>实际执行时：</p><ol><li>当线程运行到Safe Region的代码时，首先表示已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略表示为Safe Region状态的线程；</li><li>当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止</li></ol><h1 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h1><p>我们希望能描述这样一类对象：当内存空间还不够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象</p><p>在JDK1.2版本之后，Java对于引用的概念进行了扩充，将引用分为了强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Week Reference）和虚引用（Phantom Reference）4中，这4中引用强度一次逐渐减弱</p><p>除了强引用之外，其他三种引用均可以在java.lang.ref包中找到</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200901173040.png" alt=""></p><p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用</p><ul><li><strong>强引用（Strong Reference）：</strong>最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似 “Object object = new Object()” 这种引用关系。<strong>无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象</strong></li><li><strong>软引用（Soft Reference）：</strong>在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果回收后还没有足够的内存，才会抛出内存溢出异常（即，内存不足就回收）</li><li><strong>弱引用（Week Reference）：</strong>被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象</li><li><strong>虚引用（Phantom Reference）：</strong>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时，收到一个系统通知</li></ul><h2 id="强引用（Strong-Reference）——-不回收"><a href="#强引用（Strong-Reference）——-不回收" class="headerlink" title="强引用（Strong Reference）——  不回收"></a>强引用（Strong Reference）——  不回收</h2><p>在Java程序中，最常见的引用类型就是强引用（<strong>普通系统99%以上都是强引用</strong>），也就是我们最常见的普通对象引用，<strong>也是默认的引用类型</strong></p><p>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为一个指向该对象的强引用。</p><p><strong>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象</strong></p><p>对于普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应引用赋值为null，就是可以当做垃圾被收集了，当然具体回收机制还是要看垃圾收集策略</p><p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及、虚可触及的，在一定条件下，都是可以被回收的。所以<strong>强引用是造成Java内存泄露的主要原因</strong></p><h2 id="软引用（Soft-Reference）——-内存不足即回收"><a href="#软引用（Soft-Reference）——-内存不足即回收" class="headerlink" title="软引用（Soft Reference）——  内存不足即回收"></a>软引用（Soft Reference）——  内存不足即回收</h2><p>软引用是用来描述一些还有用，但是非必须的对象。<strong>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收</strong>，如果这次回收还没有足够的内存，才会抛出内存溢出异常</p><p>软引用通常用来实现内存敏感的缓存。比如：<strong>高速缓存</strong>就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）</p><p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理</p><h2 id="弱引用（Week-Reference）——-发现即回收"><a href="#弱引用（Week-Reference）——-发现即回收" class="headerlink" title="弱引用（Week Reference）——  发现即回收"></a>弱引用（Week Reference）——  发现即回收</h2><p>弱引用也是用来描述那些非必须对象，<strong>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止</strong>。在系统GC时，只要发现弱引用，不管系统堆空间是否充足，都会回收掉只被弱引用关联的对象</p><p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，<strong>弱引用对象可以存在较长的时间</strong></p><p>弱引用和软引用一样，在构造弱引用时，也可以制定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况</p><p><strong>软引用、弱引用都非常适合来保存那些可有可无的缓存数据</strong>。如果这么做，当系统内存不足时，这些花奴才能数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用</p><h2 id="虚引用（Phantom-Reference）——-对象回收跟踪"><a href="#虚引用（Phantom-Reference）——-对象回收跟踪" class="headerlink" title="虚引用（Phantom Reference）——  对象回收跟踪"></a>虚引用（Phantom Reference）——  对象回收跟踪</h2><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个</p><p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时可能被垃圾回收器回收</p><p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法获取对象时，总是null</p><p><strong>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知</strong></p><h2 id="终结器引用（Final-Reference）"><a href="#终结器引用（Final-Reference）" class="headerlink" title="终结器引用（Final Reference）"></a>终结器引用（Final Reference）</h2><ul><li>它用于实现对象的finalize()方法，也可以成为终结器引用</li><li>无需动手编码，其内部配合引用队列使用</li><li>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize()方法，第二次GC时才能回首被引用对象</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;System-gc-的理解&quot;&gt;&lt;a href=&quot;#System-gc-的理解&quot; class=&quot;headerlink&quot; title=&quot;System.gc() 的理解&quot;&gt;&lt;/a&gt;System.gc() 的理解&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在默认情况下，通过 System</summary>
      
    
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/tags/JVM/"/>
    
    <category term="笔记" scheme="https://blog.matrix-world.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JVM 笔记 - 15 垃圾回收相关算法</title>
    <link href="https://blog.matrix-world.top/2020/08/24/JVM%20-%2015.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"/>
    <id>https://blog.matrix-world.top/2020/08/24/JVM%20-%2015.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</id>
    <published>2020-08-24T08:01:00.000Z</published>
    <updated>2021-03-15T10:38:03.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标记阶段：引用计数算法"><a href="#标记阶段：引用计数算法" class="headerlink" title="标记阶段：引用计数算法"></a>标记阶段：引用计数算法</h1><h2 id="垃圾标记阶段：对象存活判断"><a href="#垃圾标记阶段：对象存活判断" class="headerlink" title="垃圾标记阶段：对象存活判断"></a>垃圾标记阶段：对象存活判断</h2><ul><li>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先<strong>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象</strong>。只有被标记为已经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为<strong>垃圾标记阶段</strong></li><li>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡</li><li>判断对象存活一般有两种方法：<strong>引用计数法</strong> 和 <strong>可达性分析算法</strong></li></ul><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><ul><li>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的<strong>引用计数器属性，用于记录对象被引用的情况</strong></li><li>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收</li><li><strong>优点</strong>：实现简单，垃圾对象便于识别，判定效率高，回收没有延迟性</li><li><strong>缺点</strong>：<ul><li>它需要单独的字段存储计数器，这样的做法增加了存储空间的开销</li><li>每次幅值都需要重新更新计数器，伴随着加法与减法操作，增加了时间的开销</li><li>引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法</li></ul></li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200824163626.png" alt="循环引用"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>引用计数算法，是很多语言的资源回收选择，例如Python，它同时支持引用计数和垃圾收集机制</li><li>具体哪种最优是看具体场景，有些大规模的实践中仅保留技术机制，以提高吞吐量</li><li>Java并没有选择引用计数，是因为其无法解决循环引用</li></ul><h1 id="标记阶段：可达性分析算法"><a href="#标记阶段：可达性分析算法" class="headerlink" title="标记阶段：可达性分析算法"></a>标记阶段：可达性分析算法</h1><h2 id="可达性分析（或跟搜索算法、跟踪性垃圾收集）"><a href="#可达性分析（或跟搜索算法、跟踪性垃圾收集）" class="headerlink" title="可达性分析（或跟搜索算法、跟踪性垃圾收集）"></a>可达性分析（或跟搜索算法、跟踪性垃圾收集）</h2><ul><li>相对于引用计数算法而言，可行性分析算法不仅永阳具备实现简单和执行高效等特点，更重要的是该算法可以有效地<strong>解决引用计数算法中循环引用的问题，放置内存泄露的发生</strong></li><li>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常叫做<strong>追踪性垃圾收集（Tracing Garbage Collection）</strong></li></ul><hr><ul><li>所谓“GC Roots”根集合就是一组必须活跃的引用</li><li>基本思路：<ul><li>可达性分析算法是以根对象集合（GC Roots）为起始点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达</strong></li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接地连接着，搜索过的路径成为<strong>引用链</strong>（Reference Chain）</li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象</li><li>在可达性分析算法中，只有能够被根对象集合直接或间接链接的对象才是存活对象</li></ul></li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200824170230.png" alt="可达性分析算法"></p><h2 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h2><p>在Java语言中，GC Roots包括以下几类元素：</p><ul><li>虚拟机栈中引用的对象，比如：各个线程被调用的方法中时用到的参数、局部变量等</li><li>本地方法栈内JNI（通常说的本地方法）引用的对象</li><li>方法区中类静态属性引用的对象，比如：Java类的引用类型静态变量</li><li>方法区中常量引用的对象，比如：字符串常量池（String Table）里的引用</li><li>所有被同步锁synchronized持有的对象</li><li>Java虚拟机内部的引用，比如基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统累计加载器等</li><li>反应Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200824172028.png" alt=""></p><ul><li>除了这些固定的GC Roots集合以外，根据用户选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（Partial GC）</li><li>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这店不满足的话，分析结果的准确性就无法保证</li><li>这单也是导致GC进行时必须 <strong>“Stop The World”</strong> 的一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，<strong>枚举根节点时也是必须要停顿的</strong></li></ul><h1 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>Java语言提供了对象终止（finalization）机制来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong></li><li>当垃圾收集器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个 对象的finalize()方法</li><li>finalize()方法允许在子类中重写，<strong>用于在对象被回收时进行资源释放</strong>。通常这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等</li><li>永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点：<ul><li>在finalize()时可能会导致对象复活</li><li>finalize()方法的执行时间是没有保障的，它完全有GC线程决定，极端情况下，若不发生GC，则finalize()没有执行的机会</li><li>一个糟糕的finalize()会严重的影响GC的性能</li></ul></li><li>由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态</li><li>如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了。一般来说，此对象需要被回收。但事实上， 也并非是“非死不可”的，这时候它们暂时处于“缓刑”的阶段。<strong>一个无法触及的对象有可能在某一个条件下“复活自己”</strong>，如果这样，那么对于它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态，如下：<ul><li><strong>可触及的：</strong>从根节点开始，可以到达这个对象</li><li><strong>可复活的：</strong>对象的所有引用都被释放，但是独享有可能在finalize()中复活</li><li><strong>不可触及的：</strong>对象的finalize()被嗲用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，<strong>因为finalize()只会被调用一次</strong></li></ul></li><li>以上三种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收</li></ul><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><p>判断一个对象objA是否可回收，至少姚经理两次标记过程：</p><ol><li>如果对象objA到 GC Roots 没有引用链，则进行第一次标记</li><li>如果筛选，判断此对象是否有必要执行finalize()方法<ol><li>如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的</li><li>如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，有一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行</li><li><strong>finalize()方法是对象脱逃死亡的最后机会</strong>，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后对象再次出现没有引用存在的情况。在这种情况下，finalize()方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize()方法只会被调用一次</li></ol></li></ol><h1 id="清除阶段：标记-清除（Mark-Sweep）算法"><a href="#清除阶段：标记-清除（Mark-Sweep）算法" class="headerlink" title="清除阶段：标记 - 清除（Mark - Sweep）算法"></a>清除阶段：标记 - 清除（Mark - Sweep）算法</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>标记-清除算法是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并应用于lisp语言</p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>当堆中的有效内存空间被耗尽的时候，就会停止整个程序（stop the world），然后进行两项工作，第一项是标记，第二项则是清楚</p><ul><li>标记：Collector从引用的根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象</li><li>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200828151731.png" alt=""></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>效率不太高</li><li>在进行GC时，需要停止整个程序，导致用户体验差</li><li>这种方式清理出来的空闲内存是不连续的，产生内存碎片。需要维护一个空闲列表</li></ul><h2 id="注意：何为清除？"><a href="#注意：何为清除？" class="headerlink" title="注意：何为清除？"></a>注意：何为清除？</h2><ul><li>这里所谓的清除并不是真的置空，而是把需要清楚地对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够用，如果够，则存放</li></ul><h1 id="清除阶段：幅值算法"><a href="#清除阶段：幅值算法" class="headerlink" title="清除阶段：幅值算法"></a>清除阶段：幅值算法</h1><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage”。其在论文中描述的算法被人们称为幅值（Copying）算法</p><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存角色，最后完成垃圾回收</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200828153302.png" alt=""></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>幅值过去以后保证空间的连续性，不会出现“碎片”问题</li></ul><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><ul><li>此算法的缺点也很明显，就是需要两倍的内存空间</li><li>对于G1这种分拆成为大连region的GC，幅值而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li><li>除非系统中的垃圾对象非常多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在新生代，对常规应用的垃圾回收，一次通常可以回收70~99%的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代</p><h1 id="清楚阶段：标记-压缩（或标记-整理、Mark-Compact）算法"><a href="#清楚阶段：标记-压缩（或标记-整理、Mark-Compact）算法" class="headerlink" title="清楚阶段：标记 - 压缩（或标记-整理、Mark - Compact）算法"></a>清楚阶段：标记 - 压缩（或标记-整理、Mark - Compact）算法</h1><h2 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h2><p>幅值算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，<strong>基于老年垃圾回收的特性，需要使用其他的算法</strong></p><p>标记-清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后哈辉产生内存碎片，所以JVM的设计者需要在此基础上进行修改。标记-压缩算法由此诞生</p><h2 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h2><ul><li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用的对象</li><li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放</li><li>之后清除边界外的所有空间</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200828155104.png" alt=""></p><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><ul><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可</li><li>消除了复制算法中，内存减半的高额代价</li></ul><h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><ul><li>从效率上来说，标记-整理算法是要低于复制算法的</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li><li>移动过程中，需要全称暂停用户应用程序，即STW</li></ul><h1 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h1><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200828161433.png" alt=""></p><p>效率上来说，复制算法是比较不错的，但是却浪费了太多的内存</p><p>为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说跟平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段</p><h1 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h1><p>Q：难道就没有一种最好的算法吗？</p><p>A：无，没有最好的算法，只有最合适的算法</p><hr><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生</p><p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，<strong>不同生命周期的对象可以采取不同的收集方式，以便提高收集效率</strong>。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p><p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如<strong>Http请求中的Seesion对象、线程、Socket链接</strong>，这类对象跟语无直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，，这些对象生命周期会比较短，比如：<strong>String对象</strong>，由于其不可变得特性，系统会产生大量的这些对象，有些对象甚至只使用一次即可回收</p><hr><p>目前几乎所有的GC都是采用分代收集（Generational Collecting）算法执行垃圾回收的</p><p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点</p><ul><li>年轻代：<ul><li>特点：区域相对老年代较小，对象生命周期短，存活率低，回收频繁</li><li>这种情况复制算法的回收整理，速度是最快的。复制算法的效率之和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过HotSpot中的两个Survivor区的设计得到缓解</li></ul></li><li>老年代：<ul><li>特点：区域较大，对象生命周期较长，存活率高，回收不及年轻代频繁</li><li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现<ul><li>Mark阶段的开销与存活对象的数量成正比</li><li>Sweep阶段的开销与所管理区域的大小成正比</li><li>Compact阶段的开销与存活对象的数据成正比</li></ul></li></ul></li></ul><hr><p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施；当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理</p><p>分代思想被现有的虚拟机刚放使用。几乎所有的垃圾回收器都区分新生代和老年代</p><h1 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h1><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在<strong>Stop the World</strong>状态下，应用程序所以的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，<strong>将严重影响用户体验或者系统的稳定性</strong>。为了解决这个问题，即对实时垃圾收集算法的研究直接导致增量收集（Incremental Collecting）算法的诞生</p><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，<strong>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成</strong></p><p>总的来说，增量收集算法的基础仍然是传统的标记-清除和复制算法。增量收集算法通过<strong>对线程冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</strong></p><h2 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h2><p>使用这种方法，由于在垃圾回收过程中，间接性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，<strong>造成系统吞吐量的下降</strong></p><h1 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h1><p>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间也越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理的回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿</p><p>分代算法将按照对象的生命周期长短划分为两个部分，分区算法将整个堆空间划分成连续的不同小区间</p><p>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;标记阶段：引用计数算法&quot;&gt;&lt;a href=&quot;#标记阶段：引用计数算法&quot; class=&quot;headerlink&quot; title=&quot;标记阶段：引用计数算法&quot;&gt;&lt;/a&gt;标记阶段：引用计数算法&lt;/h1&gt;&lt;h2 id=&quot;垃圾标记阶段：对象存活判断&quot;&gt;&lt;a href=&quot;#垃圾标记</summary>
      
    
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/tags/JVM/"/>
    
    <category term="笔记" scheme="https://blog.matrix-world.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JVM 笔记 - 14 垃圾回收概述</title>
    <link href="https://blog.matrix-world.top/2020/08/22/JVM%20-%2014.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/"/>
    <id>https://blog.matrix-world.top/2020/08/22/JVM%20-%2014.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/</id>
    <published>2020-08-22T02:24:00.000Z</published>
    <updated>2021-03-15T10:38:03.772Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200822102843.png" alt=""></p><ul><li>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生</li><li>关于垃圾收集有三个经典问题：<ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul></li><li>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为了现代语言的标配，即使经过了如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战。</li></ul><h1 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h1><ul><li>什么是垃圾（Garbage）？<ul><li>垃圾是指在运行程序汇总没有任何指针指向的对象，这个对象就是需要被回收的垃圾</li><li>外文：An object is considered garbage when it can no longer be reached from any pointer in the running program.</li></ul></li><li>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出</li></ul><h1 id="为什么需要GC"><a href="#为什么需要GC" class="headerlink" title="为什么需要GC"></a>为什么需要GC</h1><ul><li>对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都要被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样</li><li>除了释放没用的对象，垃圾回收也可以清楚内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一段，以便JVM将整理出来的内存分配给新的对象</li><li>随着应用程序所应付的业务越来越庞大，复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化</li></ul><h1 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h1><ul><li><p>在早起的C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> cmBaseGroupBridge();</span><br><span class="line"><span class="keyword">if</span>(pBridge-&gt;Register(kDestroy) != NO_ERROR)</span><br><span class="line">    <span class="keyword">delete</span> pBridge;</span><br></pre></td></tr></table></figure></li><li><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，知道出现内存溢出并造成应用程序崩溃</p></li><li><p>现在，除了Java以外，C#、Python、Ruby等语言都是用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式已经成为现代开发语言必备的标准</p></li></ul><h1 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h1><ul><li>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险<ul><li>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让人头疼</li></ul></li><li>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</li></ul><hr><p>担忧：</p><ul><li>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就是<strong>弱化了Java开发人员在程序出现内存溢出时，定位问题和解决问题的能力</strong></li><li>此时，了解JVM的自动内存分配和内存回收勋就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutOfMemoryError时，快速地根据错误异常日志定位问题和解决问题</li><li>当需要排查各种内存溢出、内存泄露问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术<strong>实施必要的监控和调节</strong></li></ul><hr><ul><li>垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收，其中Java堆是垃圾收集器的工作重点</li><li>从次数上讲<ul><li>频繁收集Young区</li><li>较少收集Old区</li><li>基本不动Perm区（或元空间）</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200822102843.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使</summary>
      
    
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/tags/JVM/"/>
    
    <category term="笔记" scheme="https://blog.matrix-world.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>用PY查找固定代码所在的文件</title>
    <link href="https://blog.matrix-world.top/2020/08/19/%E7%94%A8PY%E6%9F%A5%E6%89%BE%E5%9B%BA%E5%AE%9A%E4%BB%A3%E7%A0%81%E6%89%80%E5%9C%A8%E7%9A%84%E6%96%87%E4%BB%B6/"/>
    <id>https://blog.matrix-world.top/2020/08/19/%E7%94%A8PY%E6%9F%A5%E6%89%BE%E5%9B%BA%E5%AE%9A%E4%BB%A3%E7%A0%81%E6%89%80%E5%9C%A8%E7%9A%84%E6%96%87%E4%BB%B6/</id>
    <published>2020-08-19T08:46:00.000Z</published>
    <updated>2021-03-15T10:38:03.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h1><p>今天给我们项目组的某一个项目集成友盟+的统计。由于该项目之前集成过firebase，然后因为一些原因，firebase被弃用了，相关sdk都删掉了，原来的统计事件都给注释掉了（还好我当时机制，没有删掉，而是给注释上了，否则这次相当于重新找统计的点，更麻烦）。</p><p>由于C#文件巨多，一个一个找那怕是要累死我。突然我一想，之前自己学过一点爬虫，写了几个小demo，尤其是正则表达式让我印象深刻。所以我就在想，可不可以用正则，来找出有之前注释掉的代码。</p><h1 id="具体逻辑"><a href="#具体逻辑" class="headerlink" title="具体逻辑"></a>具体逻辑</h1><p>在写这段代码之前，我思考了一下，可能后续会有文件夹，所以在这段代码里我用了递归，如果检测到当前路径是文件夹，则会对当前路径再次调用该方法。</p><p>如果是.cs文件，则读取代码内容，让后通过正则表达式匹配，如果匹配上了，则打印当前文件名。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(path, pattern)</span>:</span></span><br><span class="line">    files = os.listdir(path)</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        filepath = path+<span class="string">'\\'</span>+file</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(filepath):</span><br><span class="line">            find(filepath, pattern)</span><br><span class="line">        <span class="keyword">elif</span> file.endswith(<span class="string">".cs"</span>):</span><br><span class="line">            content = open(filepath, mode=<span class="string">'r'</span>, encoding=<span class="string">'UTF-8'</span>).read()</span><br><span class="line">            items = re.findall(pattern, content)</span><br><span class="line">            <span class="keyword">if</span> len(items):</span><br><span class="line">                print(file)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 此处是需要寻找的目标代码</span></span><br><span class="line">    pattern = re.compile(<span class="string">'XXXXXXXX'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 此处path是需要寻找的文件夹</span></span><br><span class="line">    find(path=<span class="string">r'XXXXXXXXXXXX'</span>, pattern=pattern)</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有的时候，有些较为机械且重复的活，其实是可以借助工具来做，人来做费时又费力，效率不高。</p><p>之前在训练测试脚本的时候，也用到了python来写文件转换，比起认为来做，确实方便了不少。</p><p>平时在工作学习中，还是要善于用这种思维来考虑事情，对于重复度高的事情，可以借助脚本，增加效率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;缘由&quot;&gt;&lt;a href=&quot;#缘由&quot; class=&quot;headerlink&quot; title=&quot;缘由&quot;&gt;&lt;/a&gt;缘由&lt;/h1&gt;&lt;p&gt;今天给我们项目组的某一个项目集成友盟+的统计。由于该项目之前集成过firebase，然后因为一些原因，firebase被弃用了，相关sdk都</summary>
      
    
    
    
    <category term="脚本工具" scheme="https://blog.matrix-world.top/categories/%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="脚本工具" scheme="https://blog.matrix-world.top/tags/%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>JVM 笔记 - 13 StringTable</title>
    <link href="https://blog.matrix-world.top/2020/08/15/JVM%20-%2013.StringTable/"/>
    <id>https://blog.matrix-world.top/2020/08/15/JVM%20-%2013.StringTable/</id>
    <published>2020-08-15T09:30:00.000Z</published>
    <updated>2021-03-15T10:38:03.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String的基本特性"><a href="#String的基本特性" class="headerlink" title="String的基本特性"></a>String的基本特性</h1><ul><li>String：字符串，使用一对””引起来表示</li><li>String声明为final的，不可被继承</li><li>String实现了Serializable接口：表示字符串是支持序列化的；也实现了Comparable接口：表示String可以比较大小</li><li>String在 jdk8 及以前内部定义了 final char[ ] value 用于存储字符串数据，jdk9 时改为了 byte[ ]</li><li>String的 String Pool 是一个固定大小的Hashtable，默认值大小长度为1009.如果放进 String Pool 的String很多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降</li><li>使用-XX:StringTableSize可设置StringTable的长度</li><li>在jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快</li><li>在jdk7中，StringTable的长度默认值是60013,1009是可设置的最小值</li></ul><h1 id="String的内存分配"><a href="#String的内存分配" class="headerlink" title="String的内存分配"></a>String的内存分配</h1><ul><li>在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</li><li>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的换成常量池比较特殊。它主要使用方法有两种<ul><li>直接使用双引号生命出来的String对象会直接存储在常量池中。比如：String info = “abc”</li><li>如果不是用双引号声明的String对象，可以使用String提供的intern()方法</li></ul></li><li>Java 6以前，字符串常量池存放在永久代中</li><li>Java 7对字符串的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内<ul><li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以在调优应用时，仅需调整堆大小即可</li><li>字符串常量池概念原本使用的比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String.intern()</li></ul></li><li>Java 8中字符串常量在堆中</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200817160832.png" alt=""></p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200817160856.png" alt=""></p><p><strong>为什么StringTable要调整？</strong></p><ol><li>permSize默认比较小</li><li>永久代垃圾回收频率低</li></ol><h1 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h1><ol><li>常量与常量的拼接结果在常量池，原理是<strong>编译器优化</strong></li><li>常量池中不会存在相同内容的常量</li><li>只要其中有一个是变量，结果就在堆中。<strong>拼接变量的原理是StringBuilder</strong></li><li>如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符创对象放入池中，并返回此对象的地址</li></ol><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200817170054.png" alt=""></p><ol><li>字符串拼接操作不一定使用的是StringBuilder，如果拼接符号左右两百年都是字符串变量或常量引用，则仍然使用编译器优化，即非StringBuilder的方式</li><li>针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能用final尽量使用final</li></ol><h1 id="intern-的使用"><a href="#intern-的使用" class="headerlink" title="intern()的使用"></a>intern()的使用</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>如果不是双引号声明的String对象，可以使用String提供的intern方法；intern方法会从字符串常量池中查询当年字符串是否存在，若不存在就会将当前字符串放入常量池中。</p><ul><li>比如：String myInfo = new String(“abc”).intern();</li></ul><p>也就是说，如果在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此下列表达式的值必定是true：</p><ul><li>(“a” + “b” + “c”).intern() == “abc”</li></ul><p>通俗点讲，Interned String 就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p><hr><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>Q：new String(“ab”)会创建几个对象？</strong></p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200818205305.png" alt=""></p><p><strong>A：</strong>2个，一个是”ab”字符串常量，放在常量池中，另一个是new出来的String对象实例</p><h1 id="StringTable的垃圾回收"><a href="#StringTable的垃圾回收" class="headerlink" title="StringTable的垃圾回收"></a>StringTable的垃圾回收</h1><p>-XX:+PrintStringTableStatistics，用来查看字符串信息</p><h1 id="G1中的String去重操作"><a href="#G1中的String去重操作" class="headerlink" title="G1中的String去重操作"></a>G1中的String去重操作</h1><ul><li><p>背景：许多Java应用做的测试得出以下结果：</p><ul><li>堆存活数据集合里面String对象占了25%</li><li>堆存活数据集合里面重复的String对象有13.5%</li><li>String对象的平均长度是45</li></ul></li><li><p>许多大规模的Java应用的瓶颈在于内存，测试表明在这些类型的应用里面，Java堆中存活的数据集合差不多25%是String对象。更进一步，这里面差不多一半String对象都是重复的，重复的意思是说：</p><p>string1.equals(string2) = true</p><p>堆上存在重复的String对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复String对象进行去重，这样就能避免浪费内存</p></li><li><p>实现：</p><ul><li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象</li><li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重他引用的String对象</li><li>使用hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组</li><li>如果存在，String对象会被调整引用那个数组，释放对原来的引用，最终会被垃圾收集器回收掉</li><li>如果查找失败，char数组会被插入到hashtable，这样以后就可以共享这个数组</li></ul></li><li><p>命令行选项：</p><ul><li>UseStringDeduplication (bool)：开启String去重，默认是不开启的，需要手动开启</li><li>PrintStringDeduplicationStatistics (bool)：打印详细的去重统计信息</li><li>StringDeduplicationAgeThreshold (uintx)：设置被认为是去重候选对象的年龄门槛</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;String的基本特性&quot;&gt;&lt;a href=&quot;#String的基本特性&quot; class=&quot;headerlink&quot; title=&quot;String的基本特性&quot;&gt;&lt;/a&gt;String的基本特性&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;String：字符串，使用一对””引起来表示&lt;/li&gt;
</summary>
      
    
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/tags/JVM/"/>
    
    <category term="笔记" scheme="https://blog.matrix-world.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JVM 笔记 - 12 执行引擎</title>
    <link href="https://blog.matrix-world.top/2020/08/12/JVM%20-%2012.%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>https://blog.matrix-world.top/2020/08/12/JVM%20-%2012.%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</id>
    <published>2020-08-12T02:55:00.000Z</published>
    <updated>2021-03-15T10:38:03.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="执行引擎概述"><a href="#执行引擎概述" class="headerlink" title="执行引擎概述"></a>执行引擎概述</h1><ul><li>执行引擎是Java虚拟机核心的组成部分之一</li><li>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的。<strong>而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地指定指令集和执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式</strong></li><li>JVM的主要任务是负责<strong>装载字节码到其内部</strong>，但字节码并不能直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息</li><li>那么想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是<strong>将字节码指令解释/编译为对应平台上的本地机器指令才可以</strong>。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200813104449.png" alt=""></p><ol><li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器</li><li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址</li><li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息</li></ol><h1 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h1><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下图的各个步骤：</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200813104904.png" alt=""></p><p>Java代码编译是由Java源码编译器来完成，流程图如下：</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200813105243.png" alt=""></p><hr><p><strong>问题：什么是解释器（interpreter），什么是JIT编译器？</strong></p><ul><li>解释器：当Java虚拟机启动时，会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行</li><li>JIT（Just In Time Compiler）编译器：虚拟机将源代码直接编译成和本地机器平台相关的机器语言</li></ul><h1 id="机器码、指令、汇编语言"><a href="#机器码、指令、汇编语言" class="headerlink" title="机器码、指令、汇编语言"></a>机器码、指令、汇编语言</h1><h2 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h2><ul><li>各种用二进制编码方式表示的指令，叫做机器指令码。最开始，人们就用它编写程序，这就是机器语言</li><li>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出错</li><li>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快</li><li>机器指令和CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同</li></ul><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ul><li>由于机器码是由0和1组成的二进制序列，可读性太差，于是人们发明了指令</li><li>指令就是把机器码汇总特定的0和1序列，简化成对应的指令（一般为英文缩写，如mov，inc等），可读性稍好</li><li>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一指令（比如mov），对应的机器码也可能不同</li></ul><h2 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h2><ul><li>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集</li></ul><h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><ul><li>由于指令的可读性还是太差，于是人们又发明了汇编语言</li><li>在汇编语言中，用<strong>助记符（Mnemonics）代替机器指令的操作码</strong>，用<strong>地址符号（Symbol）或标号（Label）</strong>代替指令或操作数的地址</li><li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200813112354.png" alt=""></p><h1 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h1><p>JVM设计者们的初衷仅仅只是单纯地为了<strong>满足Java程序实现跨平台特性</strong>，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法</p><ul><li>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机械指令执行</li><li>当一条字节码指令被解释执行完成后，根据PC寄存器中记录的下一条需要被执行的字节码指令操作解释操作</li></ul><hr><p>现状：</p><ul><li>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，<strong>基于解释器执行已经沦落为抵消的代名词</strong>，并且时常被一些C/C++程序员所调侃</li><li>为了解决这个问题，JVM平台支持一种叫做即时编译的技术。即时编译的目的是避免函数被解释执行，而是<strong>将整个函数体译成为机器码，每次函数执行时，只执行编译后的机器码即可</strong>，种方式可以使执行效率大幅度提升</li><li>不过无论何时，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献</li></ul><h1 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h1><h2 id="既然JIT编译器速度很快，那为什么HotSpot仍然还包含解释器呢？"><a href="#既然JIT编译器速度很快，那为什么HotSpot仍然还包含解释器呢？" class="headerlink" title="既然JIT编译器速度很快，那为什么HotSpot仍然还包含解释器呢？"></a>既然JIT编译器速度很快，那为什么HotSpot仍然还包含解释器呢？</h2><p>首先明确：</p><p>当程序启动后，解释器可以马上发挥作用，省去编译时间，立即执行</p><p>而编译器想要发挥作用，把代码编译为本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高</p><p>所以当Java虚拟机启动时，计时器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去很多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码变异成本地代码，获得更高的执行效率</p><p>同时，解释执行在编译器进行激进优化不成立时，作为编译器的“逃生门”</p><h2 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h2><ul><li>Java语言的“编译期”其实是一段“不确定”的操作过程，它可能是是指一个<strong>前端编译器</strong>，把.java文件转化为.class文件的过程</li><li>也可能是<strong>后端运行期编译器</strong>（JIT编译器），把字节码转化成机器码</li><li>害可能是<strong>静态提前编译器</strong>（AOT编译器，Ahead Of Time Compiler）直接把.java文件编译成本地机器代码</li></ul><h2 id="热点代码即探测方式"><a href="#热点代码即探测方式" class="headerlink" title="热点代码即探测方式"></a>热点代码即探测方式</h2><ul><li><strong>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”</strong>，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，简称为OSR（On Stack Replacement）编译</li><li>一个方法究竟要被嗲用多少次，或者一个循环体究竟要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，这里主要依靠热点探测技术</li><li>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测</li><li>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建议2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）<ul><li>方法调用计数器用于统计方法的调用次数</li><li>回边计数器则用于统计循环体执行的循环次数</li></ul></li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200813163312.png" alt=""></p><h2 id="HotSpot-VM可以设置程序执行方式"><a href="#HotSpot-VM可以设置程序执行方式" class="headerlink" title="HotSpot VM可以设置程序执行方式"></a>HotSpot VM可以设置程序执行方式</h2><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是<strong>完全采用计时器</strong>执行，还是<strong>完全采用即时编译器</strong>执行，如下：</p><ul><li>-Xint：完全采用解释器模式执行程序</li><li>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li><li>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序</li></ul><h2 id="HotSpot-VM中JIT分类"><a href="#HotSpot-VM中JIT分类" class="headerlink" title="HotSpot VM中JIT分类"></a>HotSpot VM中JIT分类</h2><p>在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器和C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到达地使用哪一种即时编译器，如下：</p><ul><li>-client：指定Java虚拟机运行在Client模式，并使用C1编译器；C1编译器会对字节码<strong>进行简单和可靠的优化，耗时短</strong>。以达到更快的编译速度</li><li>-server：指定Java虚拟机运行在Server模式，并使用C2编译器；C2编译器进行<strong>耗时较长的优化，以及激进优化</strong>。但优化的代码执行效率更高</li></ul><h2 id="C1和C2编译器不同的优化策略"><a href="#C1和C2编译器不同的优化策略" class="headerlink" title="C1和C2编译器不同的优化策略"></a>C1和C2编译器不同的优化策略</h2><ul><li>不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化，冗余消除<ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少战争的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现类进行内敛</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul></li><li>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上右如下几种优化：<ul><li>标量替换：用标量值代替聚合对象的属性值</li><li>栈上分配：对于未逃逸的对象分配在栈上而不是堆上</li><li>同步消除：清除同步操作，通常是synchronized</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;执行引擎概述&quot;&gt;&lt;a href=&quot;#执行引擎概述&quot; class=&quot;headerlink&quot; title=&quot;执行引擎概述&quot;&gt;&lt;/a&gt;执行引擎概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;执行引擎是Java虚拟机核心的组成部分之一&lt;/li&gt;
&lt;li&gt;“虚拟机”是一个相对于“物理机”的</summary>
      
    
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/tags/JVM/"/>
    
    <category term="笔记" scheme="https://blog.matrix-world.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JVM 笔记 - 11 直接内存</title>
    <link href="https://blog.matrix-world.top/2020/08/12/JVM%20-%2011.%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/"/>
    <id>https://blog.matrix-world.top/2020/08/12/JVM%20-%2011.%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/</id>
    <published>2020-08-12T02:04:00.000Z</published>
    <updated>2021-03-15T10:38:03.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="直接内存概述"><a href="#直接内存概述" class="headerlink" title="直接内存概述"></a>直接内存概述</h1><ul><li>直接内存不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域</li><li>直接内存是在Java堆外的、直接向系统申请的内存空间</li><li>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</li><li>通常，访问直接内存的速度会优于Java堆。即读写性能高<ul><li>因此处于性能考虑， 读写频繁地场合可能会考虑使用直接内存</li><li>Java的NIO库允许Java程序直接使用直接内存，用于数据缓冲区</li></ul></li></ul><p>非直接缓冲区：</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200812103850.png" alt=""></p><p>直接缓冲区：</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200812104014.png" alt=""></p><ul><li>当然直接内存也会导致OutOfMemory异常</li><li>由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和仍然受限于操作系统能给出的最大内存</li><li>缺点：<ul><li>分配回收成本较高</li><li>不收JVM内存回收管理</li></ul></li><li>直接内存大小可以通过MaxDirectMemorySize设置</li><li>如果不指定，默认与堆的最大值-Xmx参数一致</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;直接内存概述&quot;&gt;&lt;a href=&quot;#直接内存概述&quot; class=&quot;headerlink&quot; title=&quot;直接内存概述&quot;&gt;&lt;/a&gt;直接内存概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;直接内存不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域&lt;/li&gt;
</summary>
      
    
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/tags/JVM/"/>
    
    <category term="笔记" scheme="https://blog.matrix-world.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JVM 笔记 - 10 对象的实例化内存布局与访问定位</title>
    <link href="https://blog.matrix-world.top/2020/08/10/JVM%20-%2010.%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/"/>
    <id>https://blog.matrix-world.top/2020/08/10/JVM%20-%2010.%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/</id>
    <published>2020-08-10T01:47:00.000Z</published>
    <updated>2021-03-15T10:38:03.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h1><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200810095052.png" alt="对象实例化"></p><p>过程：</p><ol><li>加载类元信息</li><li>为对象分配内存</li><li>处理并发问题</li><li>属性的默认初始化（零值初始化）</li><li>设置对象头的信息</li><li>属性的显式初始化、代码块中初始化、构造器中初始化</li></ol><h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200810202502.png" alt=""></p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200810203942.png" alt=""></p><h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200810204632.png" alt=""></p><ul><li><p>句柄访问</p><p><img src="https://upload.cc/i1/2020/05/23/FnTVys.png" alt="句柄访问"></p></li><li><p>指针访问（HotSpot采用）</p><p><img src="https://upload.cc/i1/2020/05/23/yMAOhs.png" alt="直接指针访问"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;对象的实例化&quot;&gt;&lt;a href=&quot;#对象的实例化&quot; class=&quot;headerlink&quot; title=&quot;对象的实例化&quot;&gt;&lt;/a&gt;对象的实例化&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/Javen-Liu/blogimage/raw/ma</summary>
      
    
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/tags/JVM/"/>
    
    <category term="笔记" scheme="https://blog.matrix-world.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JVM 笔记 - 9 方法区</title>
    <link href="https://blog.matrix-world.top/2020/08/03/JVM%20-%209.%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
    <id>https://blog.matrix-world.top/2020/08/03/JVM%20-%209.%E6%96%B9%E6%B3%95%E5%8C%BA/</id>
    <published>2020-08-03T08:47:00.000Z</published>
    <updated>2021-03-15T10:38:03.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h1><h2 id="1-运行时数据区结构图"><a href="#1-运行时数据区结构图" class="headerlink" title="1. 运行时数据区结构图"></a>1. 运行时数据区结构图</h2><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200803170016.png" alt=""></p><h2 id="2-栈、堆、方法区的关系"><a href="#2-栈、堆、方法区的关系" class="headerlink" title="2. 栈、堆、方法区的关系"></a>2. 栈、堆、方法区的关系</h2><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200803170335.png" alt=""></p><h1 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h1><h2 id="1-方法区在哪里？"><a href="#1-方法区在哪里？" class="headerlink" title="1. 方法区在哪里？"></a>1. 方法区在哪里？</h2><p>《Java虚拟机规范》中明确说明：“尽管所以的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩”，但对于HotSpot JVM而言，方法区还有一个别名叫做Non-Heap，目的就是为了和堆分开。</p><p>所以方法区看做是一块独立于Java堆的内存空间。</p><h2 id="2-基本理解"><a href="#2-基本理解" class="headerlink" title="2. 基本理解"></a>2. 基本理解</h2><ul><li>方法区（Method Area）和Java堆一样，是各个线程共享的内存区域</li><li>方法区在JVM启动的时候被创建，并且它的实际武理内存空间中和Java堆区一样都可以是不连续的</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多类，导致方法区溢出，虚拟机同样会抛出：java.lang.OutOfMemoryError: Metaspace</li><li>关闭JVM就会释放这个区域的内存</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200803174517.png" alt=""></p><h1 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h1><h2 id="1-设置方法区内存的大小"><a href="#1-设置方法区内存的大小" class="headerlink" title="1. 设置方法区内存的大小"></a>1. 设置方法区内存的大小</h2><ul><li>方法区的大小不必是固定的，jvm可以根据应用的需要动态调整</li><li>jdk7及以前：<ul><li>通过-XX:PermSize来设置永久代初始分配空间。默认值是20.75M</li><li>通过-XX:MaxPermSize来设置永久代最大可分配空间。32位机器默认是64M，64位机器默认是82M</li><li>当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError:PermGenspace</li></ul></li><li>jdk8及以后：<ul><li>元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定，替换上述原有的两个参数</li><li>默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制</li><li>与永久代不同，如果不指定大小，默认情况下，虚拟机会好近所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</li><li>对于一个64位的服务器端JVM来说，其默认的-XX:MetaspaceSize值为21MB，这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置</li><li>新的高水位线的值取决于GC后释放了多少元空间。如果释放的内存不足，那么在不超过MaxMetaspaceSize的情况下，适当提高该值。如果释放空间过多，则适当降低该值</li></ul></li></ul><h2 id="2-如何结局OOM"><a href="#2-如何结局OOM" class="headerlink" title="2. 如何结局OOM"></a>2. 如何结局OOM</h2><ol><li>要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是先分清楚到底是出现了内存泄露（Memory Leak）还是内存溢出（Memory Overflow）</li><li>如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾回收器无法自动回收他们的。掌握了泄露对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄露代码的位置</li><li>如果不存在内存泄露，换句话说就是内存中的对象却是都还必须存活着，那就应当检查虚拟机的堆参数，与机器武理内存对比看是否可以调大，从代码检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期间的内存消耗</li></ol><h1 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h1><h2 id="1-方法区存储什么？"><a href="#1-方法区存储什么？" class="headerlink" title="1. 方法区存储什么？"></a>1. 方法区存储什么？</h2><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200804174820.png" alt=""></p><p>方法区用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等</p><h2 id="2-方法区内部结构"><a href="#2-方法区内部结构" class="headerlink" title="2. 方法区内部结构"></a>2. 方法区内部结构</h2><h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储一下类型信息：</p><ul><li>这个类型的完整有效名称（全名=包名.类名）</li><li>这个类型直接父类的完整有效类名（对于interface或是java.lang.object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ul><h3 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h3><ul><li>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</li><li>域的相关信息包括：域名称、域类型、域修饰符</li></ul><h3 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h3><p>JVM必须保存所有方法的以下信息，同域信息一样包括生命顺序：</p><ul><li>方法名称</li><li>方法的返回类型（或void）</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符</li><li>方法的字节码、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外）：包括了每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul><h3 id="non-final的类变量"><a href="#non-final的类变量" class="headerlink" title="non-final的类变量"></a>non-final的类变量</h3><ul><li>静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分</li><li>类变量被类的所有实例共享，即时没有类实例时也可以访问</li></ul><h2 id="3-运行时常量池-VS-常量池"><a href="#3-运行时常量池-VS-常量池" class="headerlink" title="3. 运行时常量池 VS 常量池"></a>3. 运行时常量池 VS 常量池</h2><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200805173907.png" alt=""></p><ul><li>方法区，内部包含了运行时常量池</li><li>字节码文件，内部包含了常量池</li><li>要弄清楚方法区，需要理解清楚ClassFile，因为家在类的信息都在方法区</li><li>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池</li></ul><h2 id="4-为什么需要常量池？"><a href="#4-为什么需要常量池？" class="headerlink" title="4. 为什么需要常量池？"></a>4. 为什么需要常量池？</h2><p>一个java源文件中的类、接口，编译后产生一个字节码文件。而java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存在常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池</p><h2 id="5-常量池中有什么？"><a href="#5-常量池中有什么？" class="headerlink" title="5. 常量池中有什么？"></a>5. 常量池中有什么？</h2><ul><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ul><h2 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6. 运行时常量池"></a>6. 运行时常量池</h2><ul><li>运行时常量池（Runtime Constant Pool）是方法区的一部分</li><li>常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号应用，这部分内容将在类加载后存放到方法区的运行时常量池中</li><li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池</li><li>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像是数组项一样，是通过索引访问的</li><li>运行时常量池中包含多种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址</li><li>运行时常量池类似于传统编程语言中的符号表（symbol table），但是它包含的数据却比符号表要更丰富一些</li><li>当创建类或接口的运行时常量时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛出OutOfMemoryError异常</li></ul><h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a>7. 小结</h2><p>常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</p><h1 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h1><ol><li><p>首先明确：只有HotSpot有永久代</p></li><li><p>HotSpot中方法区的变化：</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200806162557.png" alt=""></p></li></ol><h1 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h1><p>有些人认为方法区是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（例如JDK11中的ZGC就不支持类卸载）</p><p>一般来说<strong>这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻</strong>。但是这部分区域回收<strong>有时又确实是必要的</strong>。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄露</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型</p><h2 id="1-常量池中的两大类常量"><a href="#1-常量池中的两大类常量" class="headerlink" title="1. 常量池中的两大类常量"></a>1. 常量池中的两大类常量</h2><ul><li>常量池中的两大类常量：字面量和符号应用</li><li>字面量比较接近Java语言层次的常量概念，如文本字符串、被蛇您为final的常量值</li><li>符号应用则属于编译原理方面的概念</li><li>HotSpot虚拟机对常量池的回收策略是很明确地，只要常量池中的常量没有被任何地方引用，就可以被回收了</li><li>回收废弃常量与回收Java堆中的对象非常类似</li></ul><h2 id="2-垃圾收集"><a href="#2-垃圾收集" class="headerlink" title="2. 垃圾收集"></a>2. 垃圾收集</h2><ul><li>判断一个常量是否“废弃”还是相对简单的，而要判断一个类型是否属于“不在被使用的类”的条件就比较苛刻了。同时需要满足下面三个条件：<ol><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例</li><li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi的重加载等，否则通常是很难达成的</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问到该类的方法</li></ol></li><li>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并非和对象一样，没有引用了，就必然会被回收。</li><li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;栈、堆、方法区的交互关系&quot;&gt;&lt;a href=&quot;#栈、堆、方法区的交互关系&quot; class=&quot;headerlink&quot; title=&quot;栈、堆、方法区的交互关系&quot;&gt;&lt;/a&gt;栈、堆、方法区的交互关系&lt;/h1&gt;&lt;h2 id=&quot;1-运行时数据区结构图&quot;&gt;&lt;a href=&quot;#1-</summary>
      
    
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/tags/JVM/"/>
    
    <category term="笔记" scheme="https://blog.matrix-world.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JVM 笔记 - 8 堆</title>
    <link href="https://blog.matrix-world.top/2020/07/28/JVM%20-%208.%E5%A0%86/"/>
    <id>https://blog.matrix-world.top/2020/07/28/JVM%20-%208.%E5%A0%86/</id>
    <published>2020-07-28T12:38:00.000Z</published>
    <updated>2021-03-15T10:38:03.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆的核心概述"><a href="#堆的核心概述" class="headerlink" title="堆的核心概述"></a>堆的核心概述</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul><li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域</li><li>Java堆区在JVM启动的时候被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间，且大小是可以调节的</li><li>《Java虚拟机规范》规定，堆可以处于<strong>物理不连续</strong>的内存空间中，但在逻辑上它应该是被视为连续的</li><li>所有线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）</li><li>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上（<strong>“几乎”</strong>所有的对象实例都在这里分配，也就是说并不是全部）</li><li>数组和对象可能永远不会存储在栈上，因为栈帧中保存应用，这个应用指向对象或者数组在堆中的位置</li><li>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会别移除</li><li>堆，是GC执行垃圾回收的重点区域</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200728210153.png" alt="堆"></p><hr><h2 id="2-内存细分"><a href="#2-内存细分" class="headerlink" title="2. 内存细分"></a>2. 内存细分</h2><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200728210818.png" alt=""></p><hr><h2 id="3-堆内部结构"><a href="#3-堆内部结构" class="headerlink" title="3. 堆内部结构"></a>3. 堆内部结构</h2><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200728211631.png" alt="堆内部结构"></p><h1 id="设置堆内存大小与OOM"><a href="#设置堆内存大小与OOM" class="headerlink" title="设置堆内存大小与OOM"></a>设置堆内存大小与OOM</h1><h2 id="1-堆空间大小的设置"><a href="#1-堆空间大小的设置" class="headerlink" title="1. 堆空间大小的设置"></a>1. 堆空间大小的设置</h2><ul><li>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项 <strong>“-Xmx”</strong> 和 <strong>“-Xms”</strong> 来进行设置</li><li>“-Xms” 用于表示堆区的起始内存，等价于 -XX:InitialHeapSize</li><li>“-Xmx” 则用于表示堆区的最大内存，等价于 -XX:MaxHeapSize</li><li>一旦堆区中的内存大小超过 “-Xmx” 所指定的最大内存时，将会抛出 OutOfMemoryError 异常</li><li>通常会将 -Xms 和 -Xmx 设置为相同的值，目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区大小，一次提高性能</li><li>默认情况下，初始内存大小：物理电脑内存大小 / 64</li><li>最大内存大小： 物理电脑内存大小 / 4</li></ul><h2 id="2-OutOfMemory"><a href="#2-OutOfMemory" class="headerlink" title="2. OutOfMemory"></a>2. OutOfMemory</h2><h1 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h1><ul><li>存储在JVM中的Java对象可以被划分为两类<ul><li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li><li>另外一类对象的声明周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li></ul></li><li>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（OldGen）</li><li>其中年轻代又可划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫from区、to区）</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200729101709.png" alt="年轻代和老年代"></p><ul><li>在HotSpot中，Eden空间和另外两个Survivor空间缺省所占比例是8:1:1</li><li>当然开发人员可以通过 “-XX:SurvivorRatio” 来调整这个空间比例，例如-XX:SurvivorRatio=8</li><li>几乎所有的Java对象都是在Eden区被new出来的</li><li>绝大部分的Java对象的销毁都是在新生代进行的，即80%的对象“朝生夕死”</li></ul><h1 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配，在哪里分配等问题，而且由于内存分配算法和内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片</p><ol><li>new的对象先放在伊甸园区，此区有大小限制</li><li>当伊甸园的空间被填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不在被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li><li>然后伊甸园中的剩余对象转移到幸存者0区</li><li>如果再次出发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区</li><li>如果再精力垃圾回收，此时会重新放回幸存者0区，接着再取幸存者1区</li><li>什么时候可以去养老区呢？可以设置次数，默认是15次（-XX:MaxTenuringThreshold=<N>进行设置）</li><li>在养老区，相对悠闲。当养老区内存不足时，会触发GC：Major GC，进行养老区的内存清理</li><li>若养老区执行了Major GC之后发现仍然无法进行对象的保存，就会产生OOM异常</li></ol><h2 id="2-对象分配的特殊情况"><a href="#2-对象分配的特殊情况" class="headerlink" title="2. 对象分配的特殊情况"></a>2. 对象分配的特殊情况</h2><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200729110625.png" alt="特殊情况"></p><h1 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a>Minor GC、Major GC、Full GC</h1><h2 id="1-GC概述"><a href="#1-GC概述" class="headerlink" title="1. GC概述"></a>1. GC概述</h2><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收，大部分时候回收的都是指新生代</p><p>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）</p><ul><li>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：<ul><li>新生代收集（Minor GC / Young GC）：只是新生代的垃圾回收</li><li>老年代收集（Major GC / Old GC）：只是老年代的垃圾回收（目前只有CMS GC会有单独收集老年代的行为）</li><li>混合收集（Mixed GC）：收集很饿新生代以及部分老年代的垃圾收集（目前只有G1 GC会有这种行为）</li></ul></li><li>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾回收</li></ul><hr><h2 id="2-新生代GC（Minor-GC）触发机制"><a href="#2-新生代GC（Minor-GC）触发机制" class="headerlink" title="2. 新生代GC（Minor GC）触发机制"></a>2. 新生代GC（Minor GC）触发机制</h2><ul><li>当年轻代空间不足时，就会触发Minor GC，这里的年轻代区满是指Eden区满了，Survivor区满并不会引发GC，每次Minor GC会清理年轻代的内存</li><li>因为Java对象<strong>大多数都具备朝生夕灭</strong>的特性，所以Minor GC非常频繁，一般回收速度也比较快</li><li>Minor GC会引发STW，暂停其他用户的线程，等垃圾回收结束，用户线程才回复运行</li></ul><hr><h2 id="3-老年代GC（Major-GC-）触发机制："><a href="#3-老年代GC（Major-GC-）触发机制：" class="headerlink" title="3. 老年代GC（Major GC ）触发机制："></a>3. 老年代GC（Major GC ）触发机制：</h2><ul><li>指发生在老年代的GC，对象从老年代消失时，我们说”Major GC”或”Full GC”发生了</li><li>出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的手机策略里，就有直接进行Major GC的策略选择过程）</li><li>Major GC的速度一般会比Minor GC慢上10倍以上，STW的时间更长</li><li>如果Major GC后，内存还不足，就报OOM了</li></ul><hr><h2 id="4-Full-GC的触发机制"><a href="#4-Full-GC的触发机制" class="headerlink" title="4. Full GC的触发机制"></a>4. Full GC的触发机制</h2><ul><li>调用System.gc()时，系统建议执行Full GC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden取、Survivor0区向Survivor1区复制时，对象大小大于Survivor1区可用内存时，这把对象转存到老年代，且老年代的可用内存大小小于对象大小</li></ul><blockquote><p>Full GC是开发或者调优中尽量避免的</p></blockquote><h1 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h1><p>为什么需要把Java堆分代？不分代就不能正常工作了吗？</p><ul><li>经研究，不同对象的生命周期不同，70-99%的对象是临时对象</li><li>新生代：有Eden，两块大小相同的Survivor去构成</li><li>老年代：存放新生代精力多次GC仍然存活的对象</li><li>其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室里。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某个地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间来</li></ul><h1 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h1><p>如果对象在Eden出生，并经历过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将年龄设置为1。</p><p>对象在Survivor区中，每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁）时，就会被晋升到老年代区</p><p>对象晋升老年代的阈值，可以通过 -XX:MaxTenuringThreshold 来设置</p><hr><p>针对不同年龄段的对象分配原则如下所示：</p><ul><li>优先分配到Eden</li><li>大对象直接分配到老年代（尽量避免程序中出现过多的大对象）</li><li>长期存活的对象分配到老年代</li><li>动态对象年龄判断（如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一般，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到阈值）</li><li>空间分配担保：-XX:HandlePromotionFailure</li></ul><h1 id="为对象分配内存：TLAB"><a href="#为对象分配内存：TLAB" class="headerlink" title="为对象分配内存：TLAB"></a>为对象分配内存：TLAB</h1><h2 id="1-为什么要有TLAB（Thread-Local-Allocation-Buffer）？"><a href="#1-为什么要有TLAB（Thread-Local-Allocation-Buffer）？" class="headerlink" title="1. 为什么要有TLAB（Thread Local Allocation Buffer）？"></a>1. 为什么要有TLAB（Thread Local Allocation Buffer）？</h2><ul><li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为了避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li></ul><h2 id="2-什么是TLAB？"><a href="#2-什么是TLAB？" class="headerlink" title="2. 什么是TLAB？"></a>2. 什么是TLAB？</h2><ul><li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为<strong>每一个线程分配了一个私有缓冲区域</strong>，它包含在Eden空间内</li><li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong></li></ul><h2 id="3-说明"><a href="#3-说明" class="headerlink" title="3. 说明"></a>3. 说明</h2><ul><li>尽管不是所有的对象实例都能够在TLAB中成功分配，但是<strong>JVM确实是将TLAB作为内存分配的首选</strong></li><li>在程序中，开发人员可以通过选项 “-XX:UseTLAB” 设置是否开启TLAB空间</li><li>默认情况下，TLAB空间的内存非常小，<strong>仅占有整个Eden空间的1%</strong>，当然我们可以通过选项 “-XX:TLABWasteTargetPercent” 设置TLAB空间所占用Eden空间的百分比大小</li><li>一旦对象在TLAB空间分配内存失败，JVM就会尝试着通过<strong>使用加锁机制</strong>确保数据操作的原子性，从而直接在Eden空间中分配内存</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200730163429.png" alt="内存分配"></p><h1 id="小结：堆空间的参数设置"><a href="#小结：堆空间的参数设置" class="headerlink" title="小结：堆空间的参数设置"></a>小结：堆空间的参数设置</h1><p>官网说明：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200731155117.png" alt=""></p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200731155252.png" alt=""></p><p>在发生Minor GC之前，虚拟机会<strong>检查老年代最大可用的连续空间是否大于新生代所有对象的总空间</strong></p><p>如果大于，则此次Minor GC是安全的</p><p>如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允许担保失败</p><ul><li>如果HandlePromotionFailure=true，那么会继续<strong>检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小</strong><ul><li>如果大于，则尝试进行一次Minor GC，但这次GC仍然是有风险的</li><li>如果小于，则改为进行一次Full GC</li></ul></li><li>如果HandlePromotionFailure=false，则直接进行一次Ful GC</li></ul><p>在JDK6 Update24（或JDK7）之后的规则变成，<strong>只要老年代的连续空间大于新生代对象总大小</strong>，或者<strong>历次晋升的平均大小就会进行Minor GC</strong>，否则将进行Full GC</p><h1 id="堆是分配对象的唯一选择吗？"><a href="#堆是分配对象的唯一选择吗？" class="headerlink" title="堆是分配对象的唯一选择吗？"></a>堆是分配对象的唯一选择吗？</h1><h2 id="1-回答"><a href="#1-回答" class="headerlink" title="1. 回答"></a>1. 回答</h2><p>在《深入理解Java虚拟机》中，关于Java堆内存有这样一段描述：</p><blockquote><p>随着JIT编译的发展和<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换优化技术</strong>将会导致一些微妙的变化，所有的对象都分配到堆上变得不那么“绝对”了。</p></blockquote><p>在Java虚拟机中，对象是在Java堆内分配内存的，这是一个普遍的常识。但是，有一种特殊的情况，那就是<strong>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无须在堆上分配内存，也无需进行垃圾回收，这也是最常见的堆外存储技术。</p><p>此外，前面提到的基于OpenJDK深度定制的TaoBaoVM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap转移至heap外，并且GC不能管理GCIH内部的Java对象，一次达到降低GC的回收频率和提升GC的回收效率的目的</p><h2 id="2-逃逸分析"><a href="#2-逃逸分析" class="headerlink" title="2. 逃逸分析"></a>2. 逃逸分析</h2><ul><li>如何将堆上的对象分配到栈，需要使用逃逸分析手段</li><li>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法</li><li>通过逃逸分析，Java HotSpot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上</li><li>逃逸分析的基本行为就是分析对象动态作用域：<ul><li>当一个对象在方法中被定义后，对象旨在方法内部使用，则认为没有发生逃逸</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生了逃逸。例如作为调用参数传递到其他方法中去</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;堆的核心概述&quot;&gt;&lt;a href=&quot;#堆的核心概述&quot; class=&quot;headerlink&quot; title=&quot;堆的核心概述&quot;&gt;&lt;/a&gt;堆的核心概述&lt;/h1&gt;&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/tags/JVM/"/>
    
    <category term="笔记" scheme="https://blog.matrix-world.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JVM 笔记 - 7 本地方法栈</title>
    <link href="https://blog.matrix-world.top/2020/07/25/JVM%20-%207.%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/"/>
    <id>https://blog.matrix-world.top/2020/07/25/JVM%20-%207.%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/</id>
    <published>2020-07-25T03:00:00.000Z</published>
    <updated>2021-03-15T10:38:03.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><ul><li>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</li><li>本地方法栈，也是线程私有的</li><li>允许被是线程固定或者是可动态扩展的内存大小<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryErorr异常</li></ul></li><li>本地方法是使用C语言实现的</li><li>它的具体做法是Native Method Stack中登记native方法，在执行引擎执行时加载本地方法库</li></ul><hr><ul><li>当某个线程调用一个本地方法时，他就进入了一个全新的并且不再受虚拟机限制的世界。他和虚拟机拥有同样的权限<ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存</li></ul></li><li>并不是所有的JVM都支持本地方法，因为Java虚拟机规范中并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈</li><li>在HotSpot JVM中，直接将本地方法栈和虚拟机栈合二为一</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;本地方法栈&quot;&gt;&lt;a href=&quot;#本地方法栈&quot; class=&quot;headerlink&quot; title=&quot;本地方法栈&quot;&gt;&lt;/a&gt;本地方法栈&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用&lt;/li&gt;
&lt;li&gt;本地方</summary>
      
    
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/tags/JVM/"/>
    
    <category term="笔记" scheme="https://blog.matrix-world.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JVM 笔记 - 6 本地方法接口</title>
    <link href="https://blog.matrix-world.top/2020/07/25/JVM%20-%206.%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/"/>
    <id>https://blog.matrix-world.top/2020/07/25/JVM%20-%206.%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-07-25T02:21:00.000Z</published>
    <updated>2021-03-15T10:38:03.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是本地方法"><a href="#什么是本地方法" class="headerlink" title="什么是本地方法"></a>什么是本地方法</h1><p>简单地讲，<strong>一个Native Method就是一个Java调用非Java代码的接口</strong>。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特性并非Java所特有，很多其他的变成语言都有这一机制，比如在C++中，你可以使用extern “C” 告知C++编译器去调用一个C的函数</p><h1 id="为什么要用Native-Method？"><a href="#为什么要用Native-Method？" class="headerlink" title="为什么要用Native Method？"></a>为什么要用Native Method？</h1><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了</p><ul><li><p>与Java环境外交互：</p><p>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想象Java需要和一些底层系统，如操作系统或某些硬件交流信息时的情况。本地方法正是这样一种交流机制：它为我们提供了非常简洁的接口，而且我们无需去了解Java应用之外的繁琐细节</p></li><li><p>与操作系统交互：</p><p>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的空间，它由一个解释器和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整地系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。<strong>通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些不分就是用C写的</strong></p></li><li><p>Sun’s Java</p><p>Sun的解释器使用C实现的，这使得它能像一些普通的C一样与外部进行交互</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是本地方法&quot;&gt;&lt;a href=&quot;#什么是本地方法&quot; class=&quot;headerlink&quot; title=&quot;什么是本地方法&quot;&gt;&lt;/a&gt;什么是本地方法&lt;/h1&gt;&lt;p&gt;简单地讲，&lt;strong&gt;一个Native Method就是一个Java调用非Java代码的接口&lt;/</summary>
      
    
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/tags/JVM/"/>
    
    <category term="笔记" scheme="https://blog.matrix-world.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JVM 笔记 - 5 虚拟机栈</title>
    <link href="https://blog.matrix-world.top/2020/07/20/JVM%20-%205.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
    <id>https://blog.matrix-world.top/2020/07/20/JVM%20-%205.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</id>
    <published>2020-07-20T01:08:00.000Z</published>
    <updated>2021-03-15T10:38:03.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚拟机栈概述"><a href="#虚拟机栈概述" class="headerlink" title="虚拟机栈概述"></a>虚拟机栈概述</h1><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。</p><p>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p><hr><p>栈是运行时的单位，而堆是存储的单位。</p><p>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。</p><h2 id="1-虚拟机栈基本内容"><a href="#1-虚拟机栈基本内容" class="headerlink" title="1. 虚拟机栈基本内容"></a>1. 虚拟机栈基本内容</h2><ul><li><p>Java虚拟机栈是什么？</p><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</p><p>虚拟机栈是线程私有的</p></li><li><p>生命周期</p><p>生命周期与线程一致。</p></li><li><p>作用</p><p>主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p></li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200720101835.png" alt="大概示意图"></p><ul><li><p>栈的优点：</p><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</p><p>JVM直接对Java栈的操作只有两个：每个方法执行，伴随着入栈；方法执行结束后，进行出栈</p><p>对于栈来说，不存在垃圾回收问题</p></li></ul><h2 id="2-设置虚拟机栈大小"><a href="#2-设置虚拟机栈大小" class="headerlink" title="2. 设置虚拟机栈大小"></a>2. 设置虚拟机栈大小</h2><p>例：-Xss256k</p><h1 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h1><h2 id="1-栈中存储什么？"><a href="#1-栈中存储什么？" class="headerlink" title="1. 栈中存储什么？"></a>1. 栈中存储什么？</h2><ul><li>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在</li><li>在这个线程中正在执行的每个方法都各自对应一个栈帧（Stack Frame）</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li></ul><h2 id="2-栈运行原理"><a href="#2-栈运行原理" class="headerlink" title="2. 栈运行原理"></a>2. 栈运行原理</h2><ul><li>JVM直接对Java栈的操作只有两个，就是对栈的<strong>“压栈”</strong>和<strong>“出栈”</strong>，遵循“先进后出“原则</li><li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<strong>当前栈帧</strong>（Current Frame），与当前栈帧相对应的方法就是<strong>当前方法</strong>（Current Method），定义这个方法的类就是<strong>当前类</strong>（Current Class）</li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li><li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前帧</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200720105414.png" alt="栈运行图"></p><ul><li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li><li>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出</li></ul><h2 id="3-栈帧的内部结构"><a href="#3-栈帧的内部结构" class="headerlink" title="3. 栈帧的内部结构"></a>3. 栈帧的内部结构</h2><p>每个栈帧中存储着：</p><ul><li><strong>局部变量表</strong>（Local Variables）</li><li><strong>操作数栈</strong>（Operand Stack）（或表达式栈）</li><li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><h1 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h1><h2 id="1-什么是局部变量表"><a href="#1-什么是局部变量表" class="headerlink" title="1. 什么是局部变量表"></a>1. 什么是局部变量表</h2><ul><li>局部变量表也被称之为<strong>局部变量数组</strong>或<strong>本地变量表</strong></li><li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括基本数据类型、对象引用（reference），以及returnAddress类型</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li><li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的 maximum local varibales 数据项中，在方法运行期间是不会改变局部变量表的大小的</li><li>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多</li><li><strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁</li></ul><h2 id="2-Slot"><a href="#2-Slot" class="headerlink" title="2. Slot"></a>2. Slot</h2><ul><li>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束</li><li>局部变量表最基本的存储单元是Slot（变量槽）</li><li>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量</li><li>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress乐行），64位的类型（long和double）占用两个slot</li><li>byte、short、char在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true</li></ul><hr><ul><li>JVM会为局部变量表汇总的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li><li>当一个实例方法被调用时，它的方法参数和方法体内部定义的局部变量将会按照顺序被幅值到局部变量表中的每一个slot上</li><li>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如long和double）</li><li>如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200720134405.png" alt="slot"></p><h2 id="3-静态变量与局部变量的对比"><a href="#3-静态变量与局部变量的对比" class="headerlink" title="3. 静态变量与局部变量的对比"></a>3. 静态变量与局部变量的对比</h2><ul><li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配</li><li>我们知道类变量表有两次初始化阶段，第一次是在“准备阶段“，执行系统初始化，对类变量设置零值，另一次是在”初始化“阶段，赋予程序员在代码中定义的初始值</li><li>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用</li></ul><h2 id="4-补充"><a href="#4-补充" class="headerlink" title="4. 补充"></a>4. 补充</h2><ul><li>栈帧中，与性能调优关系最密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用的局部变量表完成方法的传递</li><li><strong>局部变量表中的变量也是非常重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></li></ul><h1 id="操作数栈（operand-stack）"><a href="#操作数栈（operand-stack）" class="headerlink" title="操作数栈（operand stack）"></a>操作数栈（operand stack）</h1><ul><li>每一个独立的栈帧中除了包含局部变量表以外，还包含一个先进后出（first in last out）的操作数栈，也可以称之为表达式栈（Expression Stack）</li><li>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/ 出栈（pop）</li><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈，使用他们后在把结果压入栈，例如：执行复制、交换、求和等操作</li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200722170326.png" alt="操作数栈出栈与入栈"></p><ul><li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong></li><li>操作数栈就是JVM执行引擎的一个工作区，当一个方法开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>这个方法的操作数栈是空的</strong></li><li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译器就定义好了，保存在方法的Code属性中，为max_stack的值</li><li>栈中的任何一个元素可以是Java的任意类型：32bit的类型占用一个栈单位深度，64bit的类型占用两个栈单位深度</li><li>操作数栈<strong>并非采用访问索引的方式来进行数据访问</strong>的，而是只能通过入栈和出栈操作来完成一次数据访问</li><li><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>，并更新PC寄存器中下一条需要执行的字节码指令</li><li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段再次验证</li><li>另外，Java虚拟机的<strong>解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈</li></ul><h1 id="栈顶缓存（Top-of-Stack-Cashing）技术"><a href="#栈顶缓存（Top-of-Stack-Cashing）技术" class="headerlink" title="栈顶缓存（Top-of-Stack-Cashing）技术"></a>栈顶缓存（Top-of-Stack-Cashing）技术</h1><ul><li>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着需要更多的指令分配（instruction dispatch）次数和内存读/写次数</li><li>由于操作数是存储在内存中的，因此频繁地执行内存读写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，一次降低对内存的读写次数，提升执行引擎的执行效率</strong></li></ul><h1 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h1><ul><li>每一个栈帧内部都包含一个<strong>指向运行时常量池中该栈帧所属方法的应用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令</li><li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号应用（Symbolic Reference）保存在class文件的常量池中。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号应用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转化为调用方法的直接引用</strong></li></ul><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200722191045.png" alt="动态链接"></p><h1 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h1><h3 id="1-解析与分派"><a href="#1-解析与分派" class="headerlink" title="1. 解析与分派"></a>1. 解析与分派</h3><p>在JVM中，将符号引用转化为调用方法的直接引用与方法的绑定机制相关</p><ul><li><p>静态链接：</p><p>当一个字节码文件被装载进JVM内部时，如果<strong>被调用的目标方法在编译期可知</strong>，且运行期保持不变，这种情况下将调用方法的符号引用转换为直接引用的过程，称之为静态链接</p></li><li><p>动态链接：</p><p>如果<strong>被调用的方法在编译期无法被确定下来</strong>，也就是说，只能够在程序运行期将调用方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接</p></li></ul><hr><p>对应的方法的绑定机制为：早起绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次</strong></p><ul><li><p>早期绑定：</p><p>早期绑定就是指被调用的目标方法如果<strong>在编译期间可知，且运行期保持不变时</strong>，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转化为直接引用</p></li><li><p>晚期绑定：</p><p><strong>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期间根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定</p></li></ul><blockquote><p>OOP语言一大特点是多态，如果要支持多态，那么就必须要具备早期绑定和晚期绑定两种绑定方式</p></blockquote><h3 id="2-虚方法与非虚方法"><a href="#2-虚方法与非虚方法" class="headerlink" title="2. 虚方法与非虚方法"></a>2. 虚方法与非虚方法</h3><p>非虚方法：</p><ul><li>如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变得。这样的方法称为非虚方法</li><li>静态方法、私有方法、、final方法、实例构造器、父类方法都是非虚方法</li><li>其他方法则称为虚方法</li></ul><p>调用指令：</p><ul><li>普通调用指令：<ol><li><strong>invokestatic：调用静态方法，解析阶段确定唯一方法版本</strong></li><li><strong>invokespecial：调用<init>方法、私有父类方法，解析阶段确定唯一方法版本</strong></li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ol></li><li>动态调用指令：<ol><li>invokedynamic：动态解析出需要调用的方法，然后执行</li></ol></li></ul><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持有用户确定方法版本。其中invokestatic指令和invokespecial指令电泳的方法称为非虚方法，其余的（除了final修饰的）都成为虚方法</p><h3 id="3-关于invokedynamic指令"><a href="#3-关于invokedynamic指令" class="headerlink" title="3. 关于invokedynamic指令"></a>3. 关于invokedynamic指令</h3><ul><li>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现 <strong>动态类型语言</strong> 支持而做的一种改进</li><li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层自己吗工具来产生invokedynamic指令。<strong>直到Java8的Lambda表达式的出现，invokeddynamic指令的生成，在Java中才有了直接的生成方式</strong></li><li>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来说比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器</li></ul><h3 id="4-方法重写的本质"><a href="#4-方法重写的本质" class="headerlink" title="4. 方法重写的本质"></a>4. 方法重写的本质</h3><ol><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作c</li><li>如果在类型c中找到与常量中的描述符合，简单名称都相符的方法，则进行访问权限效验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.IllegalAccessError 异常</li><li>否则，按照继承关系从下往上依次对c的各个父类进行第2步的搜索和验证过程</li><li>如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError 异常</li></ol><h3 id="5-虚方法表："><a href="#5-虚方法表：" class="headerlink" title="5. 虚方法表："></a>5. 虚方法表：</h3><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200724163925.png" alt="虚方法表"></p><h1 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h1><ul><li>存放调用该方法的pc寄存器的值</li><li>一个方法的结束，有两种方式：1.正常执行完成；2.出现未处理的异常，非正常退出</li><li>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常推出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息</li></ul><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><ol><li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；</li></ol><blockquote><ol><li>一个方法按在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值得实际数据类型而定</li><li>在字节码指令中，返回指令包含ireturn、lreturn、freturn、dreturn以及areturn，另外还有一个return让你指令供声明为void的方法、实力初始化方法、类和接口的初始化方法使用</li></ol></blockquote><ol start="2"><li>在方法执行过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称异常完成出口</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;虚拟机栈概述&quot;&gt;&lt;a href=&quot;#虚拟机栈概述&quot; class=&quot;headerlink&quot; title=&quot;虚拟机栈概述&quot;&gt;&lt;/a&gt;虚拟机栈概述&lt;/h1&gt;&lt;p&gt;由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。&lt;</summary>
      
    
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/tags/JVM/"/>
    
    <category term="笔记" scheme="https://blog.matrix-world.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>我的 2020 上半年 - 个人的一些感想与总结</title>
    <link href="https://blog.matrix-world.top/2020/07/18/%E6%88%91%E7%9A%842020%E4%B8%8A%E5%8D%8A%E5%B9%B4%20-%20%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.matrix-world.top/2020/07/18/%E6%88%91%E7%9A%842020%E4%B8%8A%E5%8D%8A%E5%B9%B4%20-%20%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3%E4%B8%8E%E6%80%BB%E7%BB%93/</id>
    <published>2020-07-18T14:56:00.000Z</published>
    <updated>2021-03-15T10:38:03.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我的-2020-上半年-个人的一些感想与总结"><a href="#我的-2020-上半年-个人的一些感想与总结" class="headerlink" title="我的 2020 上半年 - 个人的一些感想与总结"></a>我的 2020 上半年 - 个人的一些感想与总结</h1><h2 id="躲过了年前的武汉封城-1月上旬-1月末"><a href="#躲过了年前的武汉封城-1月上旬-1月末" class="headerlink" title="躲过了年前的武汉封城 | 1月上旬 ~ 1月末"></a>躲过了年前的武汉封城 | 1月上旬 ~ 1月末</h2><p>2020年1月，考研初试已经结束，考完后感觉整个人都松了口气。</p><p>想着玩几天，再开始学习一些感兴趣东西。</p><p>考完后前几天每天早上睡到9点10点起床，真的很爽，晚上玩玩游戏，打打牌，同学聚在某一个宿舍边打牌边聊天，想晚睡就晚睡，那日子真的很轻松舒服。</p><p>考研期间压抑久了，就像没事出去一起吃好吃的。正好班上玩得好的基本都是一喊恰饭就走，所以那几天吃了不少好吃的，想吃就买。</p><p>最后2019年12月末到2020年1月10日，都是在很欢乐的状态，每天学学感兴趣的东西，晚上吃完饭就娱乐，也没有那么多的拘束，真的很舒服。</p><p>虽然期间还有个课设，同时还参观了武汉当地的一个公司，但也没给我增加啥烦恼。</p><p>然后1月10日之后，由于找的导师的要求，要我们在实验室里体验几天，感受一下实验室的氛围，被留到了16日。</p><p>实验室氛围挺不错的，而且冬天开着空调，很暖和，我的临时位置靠着空调，所以甚至有点热，那几天虽然和之前的规划差不多，但是规定了早上到和晚上走的时间，而且同学们都陆陆续续回家了，所以也安耐不住想回家的心。</p><p>最后还是定了15号的票回了家。</p><p>回来后没啥感觉，当时甚至以为武汉之前传出来的类似“非典“的传染病已经控制住了，就没太在意。</p><p>谁知道没过几天，新闻里的报道让全国都紧张起来了，原来这个传染病不仅没有被控制，甚至有“非典”的势头。同时20号武汉宣布封城，突然庆幸自己早点回来了，要么困在武汉，没有亲戚，没有地方住，那日子太难了。</p><p>不过虽然是从武汉“逃”了回来，但是还是担心自己会不会也携带了病毒。当时还是有点怕的，同时也害怕传给自己的爸妈，我年轻身体可以抗，他们中老年人不一定遭得住。</p><p>虽然疫情像是迷雾一般笼罩着日常的生活，但是渐渐也没有那么担忧和害怕了。甚至一开始还在担心这次疫情，会不会导致我们国家经济大衰落，同时美国等对我们施加制裁。（不过没想到原来我们控制的竟然还算不错的）</p><h2 id="在家与父母度过了一个难忘的“寒假”-2月-4月"><a href="#在家与父母度过了一个难忘的“寒假”-2月-4月" class="headerlink" title="在家与父母度过了一个难忘的“寒假” | 2月 ~ 4月"></a>在家与父母度过了一个难忘的“寒假” | 2月 ~ 4月</h2><p>突然的封城，以及国家和政府的命令，让本来过年串门的计划落空。</p><p>我大哥的两个儿子，也就是我的两个侄子，都和我是从小一起长大，每年过年都一起见面，吃饭。俩侄子中老大比我大两岁，老二比我小一岁，每年就盼望着过年聚在一起，吃个饭。</p><p>尤其是回老家，我们仨总是混在一起，今年因为疫情，没聚在一起，可惜。</p><p>以往过年，初一到初五，就没在家里待过，今年倒是在家老老实实地待着。</p><p>三月初，武汉的疫情形式仍然严峻，我们十堰本来有个二汽，也就是东风汽车，后来总部搬到了武汉，所以有很多二汽员工到了武汉工作，正值过年，都会回来过年。这样一来，本来我们算是离武汉比较远的市，最后也有大概700左右的感染。</p><p>这两个月，我上不了学，爸爸上不了班，妈妈常年待在家中，这样的场面倒是不多见。</p><p>现在想想，好像从开始上学开始，在家就没带过这么长时间。</p><p>我爸也是上班习惯了，突然“放假”这么久，在家坐不住，三月中旬那会，每天吃了中午饭，不运动，搞得晚上都不饿，有的时候晚上都不吃饭。最后结果就是我们家中午蒸米饭的量减少了1/3。</p><p>每天的日程就是：</p><p>我、爸和妈都不约而同地早上10点起床，过一会了直接吃午饭。一是在家出不了门，运动不了，吃多了反而不消化；二是没法采购，省着点吃。经常那个时候太阳也正好挺暖和，我就坐在阳台上看看书。要是早上起不来，那一上午就睡过去了。:D</p><p>中午就正常吃一顿，下午我开始学习自己感兴趣的东西，爸妈中午跑来我的卧室，睡睡午觉，醒了就玩玩手机。</p><p>那段时间不知道为什么，慢慢地能静下心来看看书，这两个月我把《算法》给看完了，当年没好好学，现在觉得这些东西还是挺有意思的。对照着书上，每种数据结构和算法都手敲一遍，基本都弄得清楚来龙去脉（除了那个该死的红黑树，最后的代码实在有点晦涩难懂）</p><p>晚上就简单吃点面条，不过可不是普通的青菜汤面，而是“苞谷碜面条”，不知道其他地方又没有这样吃的（笑）。苞谷碜就是市面上磨碎的那种玉米面，不知道为啥我爸妈特喜欢这样吃，我倒是无感，总不能不吃吧。（苦笑</p><p>那段时间挺舒服的，虽然在家憋得慌，但是挺值得回忆的，难得一家三口都在，虽然爸妈有时候会拌拌嘴，不过最后屁事没有。</p><p>以后可能就没有这样的时间和机会了，害。</p><h2 id="考研的收尾-复试-5月-6月中旬"><a href="#考研的收尾-复试-5月-6月中旬" class="headerlink" title="考研的收尾 - 复试 | 5月 ~ 6月中旬"></a>考研的收尾 - 复试 | 5月 ~ 6月中旬</h2><p>五月初，得知可能五六月份就要复试时，立马去把指定的数目复习了一遍，也就是我们专业课那几门。</p><p>当时还没有准确的通知，表明是否要线上笔试，大家都非常纠结，就怕复习了，结果不笔试；不复习吧，要是通知要笔试，那直接凉了。</p><p>反正这段时间就在忐忑中一直复习。早上起来学习一个半小时，中午休息一会，下午学到五点左右。然后晚上学学java，日子倒也挺充实。</p><p>复试完后，没多久就出结果了，虽然我有优录，并且初试分也不算低，还算可以。但是多多少少还有点开奖前的那种紧张。</p><p>不过最后还是没啥大问题。录取结果出的也不算慢，但是就像刚考完试，等待成绩时焦急的状态一样，总是想着：都复试完了，管那么多干嘛，但还是没事就打开考研群，看到老哥们和我一样，边吹水，边焦急等待，自己也一样莫名急切地看到结果，好让焦虑的心缓一缓。</p><h2 id="初入项目组-6月下旬-写下这篇文章的此时（7月18日开始写的，但是一直拖到了8月11日）"><a href="#初入项目组-6月下旬-写下这篇文章的此时（7月18日开始写的，但是一直拖到了8月11日）" class="headerlink" title="初入项目组 | 6月下旬 ~ 写下这篇文章的此时（7月18日开始写的，但是一直拖到了8月11日）"></a>初入项目组 | 6月下旬 ~ 写下这篇文章的此时（7月18日开始写的，但是一直拖到了8月11日）</h2><p>六月初，复试结束，急急忙忙地进入了现在的项目组。</p><p>初来乍到，之前只学过Java和一点python，不过还好自己对于编程有一定的兴趣，不至于被unity劝退。</p><p>一开始unity对于我来说完全是陌生的，图形界面、C#以及两者的结合使用，让我有点措手不及。</p><p>习惯了对着命令行，那一行一行出来的结果，突然转成GUI形式，有点不适应。</p><p>第一件任务，也算是给我们热身的任务，是集成firebase，一个轻量级的后台，可以为游戏或者应用提供统计事件之类的支持。</p><p>我记得我做的是remote_config以及dynamic_linking。</p><p>一开始什么都不懂，搜了半天中文社区论坛，没有发现和firebase有关的东西，说难听点，自己就是在垃圾堆里找垃圾吃，csdn真的差劲，根本没有相关文章，有一篇，那也都是到处复制粘贴的，真的垃圾（原谅我爆粗口，但是csdn论坛的水平真的是由于平台不作为和垃圾运营造成的）</p><p>这也逼迫着我开始看英文文档，也开始看之前知道，但是看得少的stackoverflow社区，问题也一个个地排解了，实验demo也搞通了，还是挺自豪的:D</p><p>慢慢地也开始上手项目，虽然C#没深入学过，但是其语法和Java蛮像的，因此我上手也算快。</p><p>从六月开始也开始学习JVM，书算是过了一遍，目前在看视频复习，消化。</p><p>项目上，正好遇到要做关于图的搜索，之前算法那本书上学了关于图的算法，所以在项目里也贡献了一些代码。</p><p>而且学长学姐也主要做业务方面的任务，放任我去搞些开放性的东西，正好把我之前学的算法用上了，感觉还是挺好。</p><h2 id="尾声，总结"><a href="#尾声，总结" class="headerlink" title="尾声，总结"></a>尾声，总结</h2><p>这上半年，有偷懒，也有勤奋学习的时候，下半年，要到学校了，继续学习，keep learning！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;我的-2020-上半年-个人的一些感想与总结&quot;&gt;&lt;a href=&quot;#我的-2020-上半年-个人的一些感想与总结&quot; class=&quot;headerlink&quot; title=&quot;我的 2020 上半年 - 个人的一些感想与总结&quot;&gt;&lt;/a&gt;我的 2020 上半年 - 个人的一</summary>
      
    
    
    
    <category term="个人总结" scheme="https://blog.matrix-world.top/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="2020" scheme="https://blog.matrix-world.top/tags/2020/"/>
    
    <category term="个人总结" scheme="https://blog.matrix-world.top/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>JVM 笔记 - 4 程序计数器</title>
    <link href="https://blog.matrix-world.top/2020/07/16/JVM%20-%204.%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
    <id>https://blog.matrix-world.top/2020/07/16/JVM%20-%204.%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/</id>
    <published>2020-07-16T08:33:00.000Z</published>
    <updated>2021-03-15T10:38:03.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PC-Register"><a href="#PC-Register" class="headerlink" title="PC Register"></a>PC Register</h1><p>JVM中的程序记数寄存器（Program Counter Register）中，Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。</p><p>在这里，并非是广义上所指的物理寄存器，或许将其翻译为PC技术器（或指令计数器）更加贴切。JVM中的PC寄存器是对物理PC寄存器的一种<strong>抽象模拟</strong>。</p><p>作用：PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。有执行引擎读取下一条指令。</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200718160916.png" alt="PC寄存器"></p><p>PC寄存器：</p><ul><li>它是一块很小的内存空间，几乎乐意忽略不计。也是运行速度最快的存储区域。</li><li>在JVM规范中，每个线程都要它自己的程序计数器，是线程私有的，生命周期与线程生命保持一致。</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址。</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程回复等基础操作功能都需要依赖这个计数器来完成。</li><li>字节码解释器工作时就是通过这个计数器的值来选取下一条需要执行的字节码指令。</li><li>它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</li></ul><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200718162343.png" alt="举例"></p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200718162814.png" alt="举例2"></p><h1 id="两个常见问题"><a href="#两个常见问题" class="headerlink" title="两个常见问题"></a>两个常见问题</h1><h2 id="1-使用PC寄存器存储字节码指令地址有什么用呢？"><a href="#1-使用PC寄存器存储字节码指令地址有什么用呢？" class="headerlink" title="1. 使用PC寄存器存储字节码指令地址有什么用呢？"></a>1. 使用PC寄存器存储字节码指令地址有什么用呢？</h2><p>因为CPU需要不停的切换各个线程，这时候切换回来之后，就得知道接着从哪里开始继续执行。</p><p>JVM的字节码解释器就需要通过改变PC寄存器的值类明确下一条应该执行什么样的字节码指令。</p><h2 id="2-PC寄存器为什么会被设定为线程私有？"><a href="#2-PC寄存器为什么会被设定为线程私有？" class="headerlink" title="2. PC寄存器为什么会被设定为线程私有？"></a>2. PC寄存器为什么会被设定为线程私有？</h2><p>所谓的多线程在一个特定的时间段内只会执行某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断和恢复。</p><p>为了能够准确地记录各个县城正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可独立进行计算，不会出现相互干扰。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PC-Register&quot;&gt;&lt;a href=&quot;#PC-Register&quot; class=&quot;headerlink&quot; title=&quot;PC Register&quot;&gt;&lt;/a&gt;PC Register&lt;/h1&gt;&lt;p&gt;JVM中的程序记数寄存器（Program Counter Regis</summary>
      
    
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://blog.matrix-world.top/tags/JVM/"/>
    
    <category term="笔记" scheme="https://blog.matrix-world.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Crafting Interpreters -  The Lox Language</title>
    <link href="https://blog.matrix-world.top/2020/07/14/Crafting%20Interpreters-[3]/"/>
    <id>https://blog.matrix-world.top/2020/07/14/Crafting%20Interpreters-[3]/</id>
    <published>2020-07-14T13:27:00.000Z</published>
    <updated>2021-03-15T10:38:03.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Crafting-Interpreters-1-3-The-Lox-Language"><a href="#Crafting-Interpreters-1-3-The-Lox-Language" class="headerlink" title="Crafting Interpreters - [1-3] The Lox Language"></a>Crafting Interpreters - [1-3] The Lox Language</h1><blockquote><p>你可以为某人做些比让他们吃早餐更好的事情吗？</p><p>​    - Anthony Bourdain</p></blockquote><blockquote><p>因为项目的原因（其实是自己懒），第三节迟迟没有翻译更新，之后应该也是随缘，佛系更新（虽然也确实没人康）。不过这本书确实还不错，顺便还能锻炼阅读英文的能力。</p></blockquote><p>我们将用本书的其余部分来详细阐明Lox语言的每个角落，但是！让你立即开始编写解释器的代码，而不了解我们最终会将Lox实现成什么样，那可能不太现实。</p><p>同时，在接触到文本编辑器之前，我不想让你了解大量的规范术语。所以对于Lox，我会温和、友好地介绍它。这可能会忽略很多细节和边界情况，但我们有足够的时间稍后再做这些。</p><h2 id="3-1-你好，Lox（你好，世界）"><a href="#3-1-你好，Lox（你好，世界）" class="headerlink" title="3.1 你好，Lox（你好，世界）"></a>3.1 你好，Lox（你好，世界）</h2><p>这是我们用Lox写的第一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Your first Lox program!</span><br><span class="line">print &quot;Hello, world!&quot;;</span><br></pre></td></tr></table></figure><blockquote><p>这两行代码应该是所有人学编程都绕不开的东西。“你好，世界”，简单的一句话，对于编程，或者说整个计算机知识体系大厦来说，就像那个不起眼的门，门外的人只看到了高耸的大厦，而真正吸引人，让这么多计算机专家痴迷的，则是这个大厦里面所包含的精华，即构建信息时代的基石。</p><p>– 来自译者的胡言乱语</p></blockquote><p>正如//注释和尾随分号所暗示的那样，Lox的语法是C系列的成员。 （因为打印是一个内置语句，而不是库函数，所以字符串周围没有括号。）</p><p>不过现在，我不会夸赞说C具有出色的语法。 如果我们想要的是一种精致的东西，那我们可能会模仿Pascal或Smalltalk。 如果我们想全面了解斯堪的纳维亚家具的极简主义，则我们也有方法去实现。精致和极简各有各的好处。</p><p>与c类似的语法相反，你会发现在一门语言中更有价值的东西是：熟悉的感觉。我知道你已经习惯了你所熟悉的风格，因为我们将用于实现Lox的两种语言Java和C也继承了它。在Lox中使用类似的语法可以让你少学一点东西。</p><h2 id="3-2-高级语言"><a href="#3-2-高级语言" class="headerlink" title="3.2 高级语言"></a>3.2 高级语言</h2><p>虽然这本书的内容比我希望的要多，但它仍然不足以容纳像Java这样的大型语言。为了在这本书中展示两个完整的Lox实现，我们的Lox本身必须非常紧凑。</p><p>当我想到那些小而有用的语言时，我首先想到的是高级脚本语言，比如JavaScript、Scheme和Lua。在这三种语言中，Lox看起来最像JavaScript，主要是因为大多数c语法语言都是这样。我们稍后将了解到，Lox确定作用域的方法与Scheme密切相关。我们将在第三部分中构建的C风格的Lox在很大程度上得益于Lua干净、高效的实现。</p><p>Lox与这三种语言在其他两个方面有相同之处：</p><h3 id="3-2-1-动态类型"><a href="#3-2-1-动态类型" class="headerlink" title="3.2.1 动态类型"></a>3.2.1 动态类型</h3><p>Lox是动态类型的。变量可以存储任何类型的值，单个变量甚至可以在不同时间存储不同类型的值。如果你尝试对错误类型的值执行操作，例如，用一个数字除以一个字符串，那么运行时将会检测到错误到并报告。</p><p>而静态类型被人喜欢的原因有很多，但是这些原因都没重要到，让Lox放弃动态类型。静态类型系统需要学习和实现大量的工作。跳过它，我们的书会更加的精简。如果我们把类型检查推迟到运行时，我们就能让解释器启动并更快地执行代码。</p><h3 id="3-2-2-自动内存管理"><a href="#3-2-2-自动内存管理" class="headerlink" title="3.2.2 自动内存管理"></a>3.2.2 自动内存管理</h3><p>高级语言的存在是为了消除容易出错的、低层次的苦差事，没啥比手动管理存储的分配和释放更乏味（c++大佬们可能会乐于其中，我这种渣渣还是希望语言所依附的虚拟机来帮我把这些都安排妥当 <strong>:D</strong> ）。</p><p>有两种主要的内存管理技术:引用计数和跟踪垃圾收集(通常称为垃圾收集或GC)。Ref计数器的实现要简单得多，我认为这就是为什么Perl、PHP和Python一开始都使用它们的原因。但是，随着时间的推移，ref计数的限制变得太麻烦了。所有这些语言最终都添加了完整的跟踪GC，或者至少添加了足够的GC来清理对象循环。</p><p>跟踪垃圾收集乍一听还是挺高端，且让人望而却步的，因为直接在内存的层次上操作确实是有点痛苦的。调试GC有时会让你在梦中看到十六进制转储。但是，请记住，这本书是关于驱散魔法和杀死那些怪物的，所以我们要写我们自己的垃圾收集器。我想你会发现这个算法非常简单，写起来也很有趣。</p><h2 id="3-3-数据类型"><a href="#3-3-数据类型" class="headerlink" title="3.3 数据类型"></a>3.3 数据类型</h2><p>在Lox的小小小小小宇宙中，组成所有物质的原子是内建的数据类型。有以下几种：</p><ul><li><p><strong>Booleans</strong> 布朗值：</p><p>你编代码不可能没有逻辑，同时没有逻辑值你也无法在代码中表示逻辑。<strong>“True” *<em>和 *</em>“False”</strong>，软件的<strong>阴</strong>和<strong>阳</strong>。与一些古老的语言不同的是，Lox有一个专用的布尔类型，它将现有的类型用于表示真与假。</p><p>而布朗值只有两种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true; &#x2F;&#x2F; Not false.</span><br><span class="line">false; &#x2F;&#x2F; Not *not* false. 套娃？</span><br></pre></td></tr></table></figure></li><li><p><strong>Numbers</strong> 数值：</p><p>Lox只有一种数字:双精度浮点数。由于浮点数还可以表示范围广泛的整数，因此它在保持简单的同时涵盖了很多领域。</p><p>功能齐全的语言有大量的数字语法，十六进制，科学的表示法，八进制，各种有趣的东西。我们将满足于基本的整数和十进制文字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1234; &#x2F;&#x2F; An integer.</span><br><span class="line">12.34; &#x2F;&#x2F; a deciaml number.</span><br></pre></td></tr></table></figure></li><li><p><strong>Strings</strong> 字符串：</p><p>在第一个例子中我们已经看到了一个字符串文字。像大多数语言一样，它们被括在双引号中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;I am a string&quot;;</span><br><span class="line">&quot;&quot;;      &#x2F;&#x2F; The empty string.</span><br><span class="line">&quot;123&quot;; &#x2F;&#x2F; This is a string, not a number.</span><br></pre></td></tr></table></figure><p>当我们开始实现它们时，我们将看到，在那些无害的字符序列中隐藏了相当多的复杂性。</p></li><li><p><strong>Nil</strong> 空（类似null）：</p><p>还有最后一个我们并没有邀请加入到我们这本书中，但似乎总是出现的一位常客。它不代表任何值。它在许多其他语言中被称为null。在Lox中，我们拼写为nil。(当我们实现它时，这将有助于区分当我们讨论Lox的nil和Java或C的null）</p><p>在语言中不使用空值是有很好的理由的，因为空指针错误是对于Java设计人员来说，简直是家常便饭。如果我们在做一种统计类型的语言，可能值得去尝试禁止它。然而，在动态类型的代码中，删除它通常比使用它更烦人。</p></li></ul><h2 id="3-4-表达式"><a href="#3-4-表达式" class="headerlink" title="3.4 表达式"></a>3.4 表达式</h2><p>如果内置数据类型及其文字是原子，那么表达式就必须是分子。其中大多数都是我们所熟悉的。</p><h3 id="3-4-1-算数"><a href="#3-4-1-算数" class="headerlink" title="3.4.1 算数"></a>3.4.1 算数</h3><p>Lox提供了我们熟知的C和其他语言中的基本算术运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add + me;</span><br><span class="line">subtract - me;</span><br><span class="line">multiply * me;</span><br><span class="line">divide &#x2F; me;</span><br></pre></td></tr></table></figure><p>操作符两边的子表达式都是操作数。因为有两个，它们被称为二元运算符。(它与二进制的“1 - 0”用法无关)因为操作符固定在操作数的中间，所以这些操作符也称为中缀操作符，而不是前缀操作符(操作符位于操作数的前面)和后缀操作符(它位于操作数的后面)。</p><p>同时有一个算术运算符，它既是中缀又是前缀。那就是 - 操作符，其用于取反：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-negateMe;</span><br></pre></td></tr></table></figure><p>所有这些运算符都用于数字，其他类型都是错误的。唯独有一个例外，那就是 + 操作符，+ 操作符可以连接两个字符串。</p><h3 id="3-4-2-比较与等于"><a href="#3-4-2-比较与等于" class="headerlink" title="3.4.2 比较与等于"></a>3.4.2 比较与等于</h3><p>and go on，我们还有一些总是返回布尔结果的运算符。我们可以比较数字(而且只能比较数字)，同时返回比较的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">less &lt; than;</span><br><span class="line">lessThen &lt;&#x3D; orEqual;</span><br><span class="line">greater &gt; than;</span><br><span class="line">greaterThen &gt;&#x3D; orEqual;</span><br></pre></td></tr></table></figure><p>我们可以测试任何类型的两个值是相等，还是不相等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &#x3D;&#x3D; 2;          &#x2F;&#x2F;false</span><br><span class="line">&quot;cat&quot; !&#x3D; &quot;dog&quot;;  &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><p>甚至是不同类型的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">314 &#x3D;&#x3D; &quot;pi&quot;;     &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure><p>当然，结果肯定为false，任何两种不同类型的数据比较，结果都为false：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123 &#x3D;&#x3D; &quot;123&quot;;    &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure><p>正如我说的，我通常是反对隐式转换的。（原作者如是说道，不过译者认为隐式转换在开发者了解其原理的情况下，合理利用，还是很方便的，毕竟高级程序语言就是为了贴合人的思维）</p><h3 id="3-4-3-逻辑操作符"><a href="#3-4-3-逻辑操作符" class="headerlink" title="3.4.3 逻辑操作符"></a>3.4.3 逻辑操作符</h3><p>如果操作数为真，则作为前缀!的not操作符返回false，反之亦然：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!true;    &#x2F;&#x2F;false</span><br><span class="line">!false;   &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><p>另外两个逻辑操作符实际上是伪装为表达式的控制流（Control Flow）构造。and表达式确定两个值是否都为真。如果为false，则返回左操作数，否则返回右操作数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false or false;   &#x2F;&#x2F;false</span><br><span class="line">true or false;    &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><p>and 和 or 之所以说是控制流，是因为它们遵从了短路效应。当 and 操作符左边的操作数为 true 时，该表达式不仅返回 true，其甚至不会执行右边的操作数（当然该操作数也可能是一个表达式）。相反的，如果 or 操作符左边的操作数为 false，那么该表达式会直接返回 false，同时右边的操作数不会执行。</p><h3 id="3-4-4-优先级和分组"><a href="#3-4-4-优先级和分组" class="headerlink" title="3.4.4 优先级和分组"></a>3.4.4 优先级和分组</h3><p>所有这些运算符都具有相同的优先级和结合性，并且和c语言相同。如果优先级没有符合开发者的期望，则可以使用()对内容进行分组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var average &#x3D; (min + max) &#x2F; 2;</span><br></pre></td></tr></table></figure><p>因为它们在技术上不是很有趣，所以我从我们的小语言中去掉了典型操作符的其余部分，所以我们的Lox没有按位、移位、模或条件运算符。但如果你能自己实现它，那我会对你刮目相看的 : p</p><p>这些是表达形式(除了一些与我们将在后面讨论的特定特性相关的形式)，所以让我们再上一层。</p><h2 id="3-5-语句式（Statement）"><a href="#3-5-语句式（Statement）" class="headerlink" title="3.5 语句式（Statement）"></a>3.5 语句式（Statement）</h2><p>现在我们来到了语句。表达式（Expression）的主要任务是生成值，而语句（Statement）的主要任务是产生效果。根据定义，语句并不会产生任何值，因此表达式想要改变世界，通常是修改某种状态、读取输入或生成输出。</p><p>下面是一个语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &quot;Hello, world!&quot;;</span><br></pre></td></tr></table></figure><p>一个 print 语句计算单个表达式的值，并将结果显示给用户，下面又是一个语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;some expression&quot;;</span><br></pre></td></tr></table></figure><p>表达式后添加分号 ; ，便提升为语句，这被称为表达式语句。</p><p>如果希望在需要一个语句的地方封装一系列语句，可以将它们封装在一个块中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">print &quot;One statement.&quot;;</span><br><span class="line">print &quot;Two statement.&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>块</strong> 也会影响作用域，那就是以下部分的东西了。。。</p><h2 id="3-6-变量"><a href="#3-6-变量" class="headerlink" title="3.6 变量"></a>3.6 变量</h2><p>使用var语句声明变量。如果省略了初始化器，则变量的值默认为nil：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var imAVariable &#x3D; &quot;here is my value&quot;;</span><br><span class="line">var iAmNil;</span><br></pre></td></tr></table></figure><p>一旦声明，你自然通过变量名来访问和对其幅值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var breakfast &#x3D; &quot;bagels&quot;;</span><br><span class="line">print breakfast;  &#x2F;&#x2F; &quot;bagels&quot;</span><br><span class="line">breakfast &#x3D; &quot;beignets&quot;;</span><br><span class="line">print breakfast;  &#x2F;&#x2F; &quot;beignets&quot;</span><br></pre></td></tr></table></figure><p>在这里我们没有讨论变量作用域的问题，因为后面的章节中，我们会花大量的时间来实现这些规则，其规则也和C与Java一样。</p><h2 id="3-7-控制流（Control-Flow）"><a href="#3-7-控制流（Control-Flow）" class="headerlink" title="3.7 控制流（Control Flow）"></a>3.7 控制流（Control Flow）</h2><p>如果不能跳过一些代码，或者不止一次地执行某些代码，那对于开发者来讲，简直是噩梦。所以我们需要控制流，控制代码执行的流向。除了我们已经说的逻辑操作符，Lox直接从C的规范中搬过来了三个控制流。</p><p>首当其冲的就是 if 语句，它根据某些条件，来执行两个语句中的一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">  print &quot;yes&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  print &quot;no&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次是 while 语句，只要符合条件，它就会不断执行其body中的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">while (a &lt; 10) &#123;</span><br><span class="line">  print a;</span><br><span class="line">  a &#x3D; a + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及最后的 for 循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var a &#x3D; 1; a &lt; 10; a &#x3D; a + 1) &#123;</span><br><span class="line">  print a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for 循环的操作与之前的 while 循环相同。大多数现代语言还具有某种 for-in 或 foreach 循环，用于显式地遍历各种序列类型。在真正的语言中，这比我们在这里得到的原始的c风格的for循环要好。不过我们的Lox还是保持原始的味道 。:D</p><h2 id="3-8-方法（Function）"><a href="#3-8-方法（Function）" class="headerlink" title="3.8 方法（Function）"></a>3.8 方法（Function）</h2><p>Lox的方法调用和C很像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makeBreakfast(bacon, eggs, toast);</span><br></pre></td></tr></table></figure><p>你还可以不传任何参数地调用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makeBreakfast();</span><br></pre></td></tr></table></figure><p>与Ruby不同，括号在Lox中是必需的。如果你把它们去掉，解释器执行时不会调用这个函数，而只是把它当做一个引用。</p><p>一个语言不能定义方法，那就不算合格。在Lox中，你可以用 fun 来声明方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun printSum(a, b) &#123;</span><br><span class="line">  print a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，那现在该澄清一些术语。有些人将 <strong>“argument”</strong> 和 <strong>“parameter”</strong> 混淆，甚至很多人认为这两个没啥区别。实际上这两个词在语义上是有细微差别的，所以让我们精确定义一下：</p><ul><li><strong>“argument”</strong> 是在调用函数时传递给函数的实际值，函数在调用时，是有一个 argument 列表的。所以其也被称为”actual parameter”，即<strong>实参</strong>。</li><li><strong>“parameter”</strong> 是保存函数体内参数值的变量。因此，函数声明有一个 parameter 列表。也可以成为 “formal parameter” 或者就简单地叫 “formals”，即<strong>形参</strong>。</li></ul><p>函数的主体总是一个块。在其中，可以使用return语句返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun returnSum(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Lox中，如果执行到块的末尾而没有返回，则隐式返回nil。</p><h3 id="3-8-1闭包（-Closures）"><a href="#3-8-1闭包（-Closures）" class="headerlink" title="3.8.1闭包（ Closures）"></a>3.8.1闭包（ Closures）</h3><p>函数是Lox中的 “first class”，这意味着它是你可以获得引用的、存储在变量中的、传递的以及等等的真实值，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun addPair(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun identity(a) &#123;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print identity(addPair)(1, 2); &#x2F;&#x2F; Prints &quot;3&quot;.</span><br></pre></td></tr></table></figure><p>由于函数声明是语句，所以可以在另一个函数中声明局部函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun outerFunction() &#123;</span><br><span class="line">  fun localFunction() &#123;</span><br><span class="line">    print &quot;I&#39;m local!&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  localFunction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果结合使用本地函数、一级函数和块作用域，就会遇到这种有趣的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun returnFunction() &#123;</span><br><span class="line">  var outside &#x3D; &quot;outside&quot;;</span><br><span class="line"></span><br><span class="line">  fun inner() &#123;</span><br><span class="line">    print outside;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn &#x3D; returnFunction();</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><blockquote><p>该语法和Java实际上是大相径庭的，Lox反而更像js</p></blockquote><p>在上面代码中，inner()访问在周围函数中其主体之外声明的局部变量。这是真的可以吗（来自Java程序员疑惑的眼光）？现在很多语言都从Lisp借用了这个特性，所以答案是肯定的。</p><p>为了实现这一点，inner()必须保留对它所使用的任何周围变量的引用，这样即使在外部函数返回之后，这些变量仍然存在。我们将执行此操作的函数称为闭包（Closures）。这个术语经常用于很多一级函数，尽管如果函数没有关闭任何变量，它就有点用词不当。</p><p>读到这里，你的想法没错，实现这些会增加一些（serious ?）复杂性，因为我们不能再假设变量作用域严格地像堆栈一样工作，即局部变量在函数返回时就蒸发掉了。后面我们会具体陈述这方面的实现。</p><h2 id="3-9-类"><a href="#3-9-类" class="headerlink" title="3.9 类"></a>3.9 类</h2><p>由于Lox具有动态类型、词法(简单来说就是块)作用域和闭包，它距离成为函数式语言仍然还有一半的距离。不过你也看到了，它差不多已经有面向对象语言的内味（那种味道）了。这两种范式都有很多优点，所以我认为有必要介绍其中的一些。</p><p>类是面向对象语言中不可获取的东西，但是它的表现并没有像宣传的那样那么耀眼，不过还是让我先解释一下为什么我仍把它放在Lox和本书中。这里有两个问题：</p><h3 id="3-9-1-为什么无论任何一种语言，都想成为一种面向对象的语言？"><a href="#3-9-1-为什么无论任何一种语言，都想成为一种面向对象的语言？" class="headerlink" title="3.9.1 为什么无论任何一种语言，都想成为一种面向对象的语言？"></a>3.9.1 为什么无论任何一种语言，都想成为一种面向对象的语言？</h3><p>现在，像Java这样的面向对象语言已经火过了，并在很多场合有应用，人们对其可能有点审美疲劳了，不再那么喜欢它们了。那么为什么会有人用对象创造一种新语言呢？这不就像发行8音轨的音乐吗？（译者不太懂这个梗）</p><p>不过的确，90年代的“无论何时无论何物全都有继承”的热潮产生了一些可怕的类层次结构，但面向对象编程仍然相当出色。今天，很可能大多数工作的程序员都在使用面向对象的语言，总不能是这些经验老到的程序员们都错了吧。</p><p>特别是，对于动态类型语言，对象非常方便。我们需要一些方法来定义复合数据类型，以便将大量的东西捆绑在一起。</p><p>如果我们也可以挂起这些方法，那么就可以避免在所有函数前面加上它们操作的数据类型的名称，以避免与针对不同类型的类似函数发生冲突。比如，在Racket软件中，你不得不给函数命名为hash-copy(复制哈希表)和vector-copy(复制矢量)，这样它们就不会相互踩到。方法的作用域被限定在对象上，这样问题就消失了。</p><h3 id="3-9-2-那为什么Lox也要是面向对象呢？"><a href="#3-9-2-那为什么Lox也要是面向对象呢？" class="headerlink" title="3.9.2 那为什么Lox也要是面向对象呢？"></a>3.9.2 那为什么Lox也要是面向对象呢？</h3><p>我可以声明对象是groovy，但仍然超出了本书的范围。大多数编程语言书籍，尤其是那些试图实现一门完整语言的书籍，都忽略了对象。对我来说，这意味着这个话题没有被很好地涵盖。在如此广泛的范式下，这种遗漏让我感到悲哀。</p><p>考虑到我们中有多少人整天都在使用OOP语言，我们似乎可以使用一些文档来说明如何创建OOP。如你所见，这很有趣。不像你担心的那么难，但也不像你想象的那么简单。</p><h3 id="3-9-3-类还是原型？"><a href="#3-9-3-类还是原型？" class="headerlink" title="3.9.3 类还是原型？"></a>3.9.3 类还是原型？</h3><p>对于对象，实际上有两种方法，类和原型。首先出现的是类，由于c++、Java、c#和朋友的帮助，类更加常见。原型实际上是一个被遗忘的分支，直到JavaScript意外地接管了世界。（指js在web端的称霸）</p><p>在基于类的语言中，有两个核心概念:实例和类。实例存储每个对象的状态，并引用实例的类。类包含方法和继承链。要在实例上调用方法，总是存在间接级别。查找实例类，然后在那里找到方法：</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200718221214.png" alt="类与实例"></p><p>基于原型的语言合并了这两个概念。只有对象，没有类，每个单独的对象可以包含状态和方法。对象可以直接相互继承(或者用原型术语表示委托)</p><p><img src="https://gitee.com/Javen-Liu/blogimage/raw/master/img/20200718221406.png" alt="原型"></p><p>这意味着原型语言在某种程度上比类更基础。它们实现起来非常好，因为它们非常简单。此外，它们还可以表示许多不寻常的模式，这些模式是类引导您避开的。</p><p>但是我看过很多用原型语言编写的代码，包括一些我自己设计的。你知道人们通常用原型的强大和灵活性做什么吗？他们用它来重新创建类。（哈哈哈，本末倒置）</p><p>我不知道为什么，但是人们似乎很自然地更喜欢基于类的(经典？优雅的？)的风格。在语言中，原型更简单，但它们似乎只能通过将复杂性推给用户来实现。因此，对于Lox，我们将为用户省去麻烦并直接编写类。</p><h3 id="3-9-4-Lox中的类"><a href="#3-9-4-Lox中的类" class="headerlink" title="3.9.4 Lox中的类"></a>3.9.4 Lox中的类</h3><p>有足够的理论基础，我们了解到：类包含了大多数语言中的一系列特性。对于Lox，我选择了我认为最合适的东西，比如像这样声明一个类及其方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Breakfast &#123;</span><br><span class="line">  cook() &#123;</span><br><span class="line">    print &quot;Eggs a-fryin&#39;!&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  serve(who) &#123;</span><br><span class="line">    print &quot;Enjoy your breakfast, &quot; + who + &quot;.&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的主体包含它的方法，它们看起来像函数声明，但是没有fun关键字。当执行类声明时，它创建一个类对象并将其存储在以类命名的变量中。与函数一样，类是Lox中的第一类（first class）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Store it in variables.</span><br><span class="line">var someVariable &#x3D; Breakfast;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Pass it to functions.</span><br><span class="line">someFunction(Breakfast);</span><br></pre></td></tr></table></figure><p>接下来，我们需要一种创建实例的方法。我们可以添加一些new关键字，但为了保持简单，在Lox中，类本身是实例的工厂函数。像调用函数一样调用一个类，它就会为自己生成一个新的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var breakfast &#x3D; Breakfast();</span><br><span class="line">print breakfast; &#x2F;&#x2F; &quot;Breakfast instance&quot;.</span><br></pre></td></tr></table></figure><h3 id="3-9-5-实例化和初始化"><a href="#3-9-5-实例化和初始化" class="headerlink" title="3.9.5 实例化和初始化"></a>3.9.5 实例化和初始化</h3><p>只有行为的类并不是特别有用。面向对象编程背后的思想是将行为和状态封装在一起。为此，Lox的类中需要字段。与其他动态类型语言一样，Lox允许开发者自由地向对象添加属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">breakfast.meat &#x3D; &quot;sausage&quot;;</span><br><span class="line">breakfast.bread &#x3D; &quot;sourdough&quot;;</span><br></pre></td></tr></table></figure><p>如果该变量，或者说叫属性，不存在的话，那么对其赋值则会创建它。</p><p>如果你想在一个方法里访问当前对象实例中的一个变量或者方法，你需要用到那个老牌，且有用的 <strong>this</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Breakfast &#123;</span><br><span class="line">serve(who) &#123;</span><br><span class="line">print &quot;Enjoy your &quot; + this.meat + &quot; and &quot; +</span><br><span class="line">this.bread + &quot;, &quot; + who + &quot;.&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对象中封装数据的一部分是为了确保对象在创建时处于有效状态。为此，可以定义初始化器。如果类有一个名为init()的方法，则在构造对象时自动调用该方法，传递给类的任何参数都被转发给它的初始化器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Breakfast &#123;</span><br><span class="line">  init(meat, bread) &#123;</span><br><span class="line">    this.meat &#x3D; meat;</span><br><span class="line">    this.bread &#x3D; bread;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var baconAndToast &#x3D; Breakfast(&quot;bacon&quot;, &quot;toast&quot;);</span><br><span class="line">baconAndToast.serve(&quot;Dear Reader&quot;);</span><br><span class="line">&#x2F;&#x2F; &quot;Enjoy your bacon and toast, Dear Reader.&quot;</span><br></pre></td></tr></table></figure><h3 id="3-9-6-继承"><a href="#3-9-6-继承" class="headerlink" title="3.9.6 继承"></a>3.9.6 继承</h3><p>每种面向对象语言都允许您不仅定义方法，而且跨多个类或对象重用它们。为此，Lox支持单继承。在声明类时，可以使用 <strong>&lt;</strong> 指定它继承的类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Brunch &lt; Breakfast &#123;</span><br><span class="line">  drink() &#123;</span><br><span class="line">    print &quot;How about a Bloody Mary?&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，Brunch是派生类或子类，而Breakfast是基类或超类。超类中定义的每个方法对它的子类也是可用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var benedict &#x3D; Brunch(&quot;ham&quot;, &quot;English muffin&quot;);</span><br><span class="line">benedict.serve(&quot;Noble Reader&quot;);</span><br></pre></td></tr></table></figure><p>甚至init()方法也会被继承。实际上，子类通常也希望定义自己的init()方法。但是也需要调用原始类，以便超类能够维护其状态。我们需要一些方法在我们自己的实例上调用一个方法而不触及我们自己的方法。</p><p>正如Java中的一样，我们是可以使用super关键字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Brunch &lt; Breakfast &#123;</span><br><span class="line">  init(meat, bread, drink) &#123;</span><br><span class="line">    super.init(meat, bread);</span><br><span class="line">    this.drink &#x3D; drink;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK all right，我们的Lox就是这些了。我尽量把它所包含的内容降到最低。这本书的结构确实迫使我们做出妥协。Lox不是一种纯粹的面向对象语言。在真正的OOP语言中，每个对象都是类的实例，即使是像数字和布尔值这样的原始对象。</p><p>因为我们直到开始使用内置类型后才实现类，所以实现类会很困难。因此，从类的实例的意义上说，基本类型的值不是真正的对象。它们没有方法或属性。如果我试图让Lox成为针对实际用户的一种真正的语言，我就会解决这个问题。</p><h2 id="3-10-标准库"><a href="#3-10-标准库" class="headerlink" title="3.10 标准库"></a>3.10 标准库</h2><p>我们要做的基本快到头了。这就是整个语言，剩下的就是核心或标准库，这是解释器中直接实现的一组功能，所有用户定义的行为都是在其上构建的。</p><p>但我们的Lox则没那么理想了。它的标准库超越了极简主义，接近于彻底的虚无主义。对于书中的示例代码，我们只需要演示代码正在运行并执行它应该执行的操作。为此，我们已经有了内置的print语句。</p><p>之后，在开始优化时，我们将编写一些基准测试，看看执行代码需要多长时间。这意味着我们需要跟踪时间，因此我们将定义一个内置函数clock()，它返回自应用程序启动以来的秒数。</p><p>所有的库就是这样。emmmm，我知道，就这么点标准库，确实是有点尬。</p><p>如果你想将Lox变成一种实际有用的语言，则首先要做的就是充实它。 字符串操作，三角函数，文件I / O，联网，扩展，甚至从用户读取输入都将有所帮助。 但是我们在本书中不需要任何内容，添加它也不会教给您任何有趣的东西，因此我将其省略。</p><p>别担心，语言本身会有很多令人兴奋的东西让我们忙个不停。</p><blockquote><p>原文链接：<a href="https://www.craftinginterpreters.com/introduction.html" target="_blank" rel="noopener">Introduction</a></p><p>阅读并翻译者：Javen Liu</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Crafting-Interpreters-1-3-The-Lox-Language&quot;&gt;&lt;a href=&quot;#Crafting-Interpreters-1-3-The-Lox-Language&quot; class=&quot;headerlink&quot; title=&quot;Crafting</summary>
      
    
    
    
    <category term="Crafting Interpreters" scheme="https://blog.matrix-world.top/categories/Crafting-Interpreters/"/>
    
    
    <category term="解释器" scheme="https://blog.matrix-world.top/tags/%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    
    <category term="外文书籍" scheme="https://blog.matrix-world.top/tags/%E5%A4%96%E6%96%87%E4%B9%A6%E7%B1%8D/"/>
    
    <category term="Crafting Interpreters" scheme="https://blog.matrix-world.top/tags/Crafting-Interpreters/"/>
    
  </entry>
  
</feed>
